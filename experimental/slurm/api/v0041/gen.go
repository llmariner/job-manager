//go:build go1.22

// Package v0041 provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package v0041

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
	TokenScopes      = "token.Scopes"
	UserScopes       = "user.Scopes"
)

// Defines values for V0041AccountFlags.
const (
	V0041AccountFlagsDELETED          V0041AccountFlags = "DELETED"
	V0041AccountFlagsNoUsersAreCoords V0041AccountFlags = "NoUsersAreCoords"
	V0041AccountFlagsUsersAreCoords   V0041AccountFlags = "UsersAreCoords"
	V0041AccountFlagsWithAssociations V0041AccountFlags = "WithAssociations"
	V0041AccountFlagsWithCoordinators V0041AccountFlags = "WithCoordinators"
)

// Defines values for V0041AssocFlags.
const (
	V0041AssocFlagsDELETED          V0041AssocFlags = "DELETED"
	V0041AssocFlagsExact            V0041AssocFlags = "Exact"
	V0041AssocFlagsNoUpdate         V0041AssocFlags = "NoUpdate"
	V0041AssocFlagsNoUsersAreCoords V0041AssocFlags = "NoUsersAreCoords"
	V0041AssocFlagsUsersAreCoords   V0041AssocFlags = "UsersAreCoords"
)

// Defines values for V0041AssocSharesObjWrapType.
const (
	ASSOCIATION V0041AssocSharesObjWrapType = "ASSOCIATION"
	USER        V0041AssocSharesObjWrapType = "USER"
)

// Defines values for V0041ClusterRecFlags.
const (
	V0041ClusterRecFlagsEXTERNAL       V0041ClusterRecFlags = "EXTERNAL"
	V0041ClusterRecFlagsFEDERATION     V0041ClusterRecFlags = "FEDERATION"
	V0041ClusterRecFlagsFRONTEND       V0041ClusterRecFlags = "FRONT_END"
	V0041ClusterRecFlagsMULTIPLESLURMD V0041ClusterRecFlags = "MULTIPLE_SLURMD"
	V0041ClusterRecFlagsREGISTERING    V0041ClusterRecFlags = "REGISTERING"
)

// Defines values for V0041CronEntryFlags.
const (
	WILDDAYOFMONTH V0041CronEntryFlags = "WILD_DAY_OF_MONTH"
	WILDDAYOFWEEK  V0041CronEntryFlags = "WILD_DAY_OF_WEEK"
	WILDHOUR       V0041CronEntryFlags = "WILD_HOUR"
	WILDMINUTE     V0041CronEntryFlags = "WILD_MINUTE"
	WILDMONTH      V0041CronEntryFlags = "WILD_MONTH"
)

// Defines values for V0041JobFlags.
const (
	V0041JobFlagsCLEARSCHEDULING   V0041JobFlags = "CLEAR_SCHEDULING"
	V0041JobFlagsNONE              V0041JobFlags = "NONE"
	V0041JobFlagsNOTSET            V0041JobFlags = "NOT_SET"
	V0041JobFlagsSTARTEDONBACKFILL V0041JobFlags = "STARTED_ON_BACKFILL"
	V0041JobFlagsSTARTEDONSCHEDULE V0041JobFlags = "STARTED_ON_SCHEDULE"
	V0041JobFlagsSTARTEDONSUBMIT   V0041JobFlags = "STARTED_ON_SUBMIT"
	V0041JobFlagsSTARTRECEIVED     V0041JobFlags = "START_RECEIVED"
)

// Defines values for V0041JobStateCurrent.
const (
	V0041JobStateCurrentBOOTFAIL     V0041JobStateCurrent = "BOOT_FAIL"
	V0041JobStateCurrentCANCELLED    V0041JobStateCurrent = "CANCELLED"
	V0041JobStateCurrentCOMPLETED    V0041JobStateCurrent = "COMPLETED"
	V0041JobStateCurrentCOMPLETING   V0041JobStateCurrent = "COMPLETING"
	V0041JobStateCurrentCONFIGURING  V0041JobStateCurrent = "CONFIGURING"
	V0041JobStateCurrentDEADLINE     V0041JobStateCurrent = "DEADLINE"
	V0041JobStateCurrentFAILED       V0041JobStateCurrent = "FAILED"
	V0041JobStateCurrentLAUNCHFAILED V0041JobStateCurrent = "LAUNCH_FAILED"
	V0041JobStateCurrentNODEFAIL     V0041JobStateCurrent = "NODE_FAIL"
	V0041JobStateCurrentOUTOFMEMORY  V0041JobStateCurrent = "OUT_OF_MEMORY"
	V0041JobStateCurrentPENDING      V0041JobStateCurrent = "PENDING"
	V0041JobStateCurrentPOWERUPNODE  V0041JobStateCurrent = "POWER_UP_NODE"
	V0041JobStateCurrentPREEMPTED    V0041JobStateCurrent = "PREEMPTED"
	V0041JobStateCurrentRECONFIGFAIL V0041JobStateCurrent = "RECONFIG_FAIL"
	V0041JobStateCurrentREQUEUED     V0041JobStateCurrent = "REQUEUED"
	V0041JobStateCurrentREQUEUEFED   V0041JobStateCurrent = "REQUEUE_FED"
	V0041JobStateCurrentREQUEUEHOLD  V0041JobStateCurrent = "REQUEUE_HOLD"
	V0041JobStateCurrentRESIZING     V0041JobStateCurrent = "RESIZING"
	V0041JobStateCurrentRESVDELHOLD  V0041JobStateCurrent = "RESV_DEL_HOLD"
	V0041JobStateCurrentREVOKED      V0041JobStateCurrent = "REVOKED"
	V0041JobStateCurrentRUNNING      V0041JobStateCurrent = "RUNNING"
	V0041JobStateCurrentSIGNALING    V0041JobStateCurrent = "SIGNALING"
	V0041JobStateCurrentSPECIALEXIT  V0041JobStateCurrent = "SPECIAL_EXIT"
	V0041JobStateCurrentSTAGEOUT     V0041JobStateCurrent = "STAGE_OUT"
	V0041JobStateCurrentSTOPPED      V0041JobStateCurrent = "STOPPED"
	V0041JobStateCurrentSUSPENDED    V0041JobStateCurrent = "SUSPENDED"
	V0041JobStateCurrentTIMEOUT      V0041JobStateCurrent = "TIMEOUT"
	V0041JobStateCurrentUPDATEDB     V0041JobStateCurrent = "UPDATE_DB"
)

// Defines values for V0041JobDescMsgCpuBindingFlags.
const (
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDMAP            V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDMAP"
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDMASK           V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDMASK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDLDRANK           V0041JobDescMsgCpuBindingFlags = "CPU_BIND_LDRANK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDMAP              V0041JobDescMsgCpuBindingFlags = "CPU_BIND_MAP"
	V0041JobDescMsgCpuBindingFlagsCPUBINDMASK             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_MASK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDNONE             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_NONE"
	V0041JobDescMsgCpuBindingFlagsCPUBINDONETHREADPERCORE V0041JobDescMsgCpuBindingFlags = "CPU_BIND_ONE_THREAD_PER_CORE"
	V0041JobDescMsgCpuBindingFlagsCPUBINDRANK             V0041JobDescMsgCpuBindingFlags = "CPU_BIND_RANK"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOCORES          V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_CORES"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOLDOMS          V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_LDOMS"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOSOCKETS        V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_SOCKETS"
	V0041JobDescMsgCpuBindingFlagsCPUBINDTOTHREADS        V0041JobDescMsgCpuBindingFlags = "CPU_BIND_TO_THREADS"
	V0041JobDescMsgCpuBindingFlagsVERBOSE                 V0041JobDescMsgCpuBindingFlags = "VERBOSE"
)

// Defines values for V0041JobDescMsgExclusive.
const (
	V0041JobDescMsgExclusiveFalse V0041JobDescMsgExclusive = "false"
	V0041JobDescMsgExclusiveMcs   V0041JobDescMsgExclusive = "mcs"
	V0041JobDescMsgExclusiveTopo  V0041JobDescMsgExclusive = "topo"
	V0041JobDescMsgExclusiveTrue  V0041JobDescMsgExclusive = "true"
	V0041JobDescMsgExclusiveUser  V0041JobDescMsgExclusive = "user"
)

// Defines values for V0041JobDescMsgFlags.
const (
	V0041JobDescMsgFlagsACCRUECOUNTCLEARED       V0041JobDescMsgFlags = "ACCRUE_COUNT_CLEARED"
	V0041JobDescMsgFlagsBACKFILLATTEMPTED        V0041JobDescMsgFlags = "BACKFILL_ATTEMPTED"
	V0041JobDescMsgFlagsCRONJOB                  V0041JobDescMsgFlags = "CRON_JOB"
	V0041JobDescMsgFlagsDEPENDENT                V0041JobDescMsgFlags = "DEPENDENT"
	V0041JobDescMsgFlagsEXACTCPUCOUNTREQUESTED   V0041JobDescMsgFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041JobDescMsgFlagsEXACTMEMORYREQUESTED     V0041JobDescMsgFlags = "EXACT_MEMORY_REQUESTED"
	V0041JobDescMsgFlagsEXACTTASKCOUNTREQUESTED  V0041JobDescMsgFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041JobDescMsgFlagsGRESBINDINGDISABLED      V0041JobDescMsgFlags = "GRES_BINDING_DISABLED"
	V0041JobDescMsgFlagsGRESBINDINGENFORCED      V0041JobDescMsgFlags = "GRES_BINDING_ENFORCED"
	V0041JobDescMsgFlagsHASSTATEDIRECTORY        V0041JobDescMsgFlags = "HAS_STATE_DIRECTORY"
	V0041JobDescMsgFlagsHETEROGENEOUSJOB         V0041JobDescMsgFlags = "HETEROGENEOUS_JOB"
	V0041JobDescMsgFlagsJOBACCRUETIMERESET       V0041JobDescMsgFlags = "JOB_ACCRUE_TIME_RESET"
	V0041JobDescMsgFlagsJOBKILLHURRY             V0041JobDescMsgFlags = "JOB_KILL_HURRY"
	V0041JobDescMsgFlagsJOBWASRUNNING            V0041JobDescMsgFlags = "JOB_WAS_RUNNING"
	V0041JobDescMsgFlagsKILLINVALIDDEPENDENCY    V0041JobDescMsgFlags = "KILL_INVALID_DEPENDENCY"
	V0041JobDescMsgFlagsMAGNETIC                 V0041JobDescMsgFlags = "MAGNETIC"
	V0041JobDescMsgFlagsNOKILLINVALIDDEPENDENCY  V0041JobDescMsgFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041JobDescMsgFlagsPARTITIONASSIGNED        V0041JobDescMsgFlags = "PARTITION_ASSIGNED"
	V0041JobDescMsgFlagsPREFERMINIMUMNODECOUNT   V0041JobDescMsgFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041JobDescMsgFlagsSCHEDULINGATTEMPTED      V0041JobDescMsgFlags = "SCHEDULING_ATTEMPTED"
	V0041JobDescMsgFlagsSENDJOBENVIRONMENT       V0041JobDescMsgFlags = "SEND_JOB_ENVIRONMENT"
	V0041JobDescMsgFlagsSIBLINGCLUSTERUPDATEONLY V0041JobDescMsgFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041JobDescMsgFlagsSKIPTRESSTRINGACCOUNTING V0041JobDescMsgFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041JobDescMsgFlagsSPREADJOB                V0041JobDescMsgFlags = "SPREAD_JOB"
	V0041JobDescMsgFlagsSTEPMGRENABLED           V0041JobDescMsgFlags = "STEPMGR_ENABLED"
	V0041JobDescMsgFlagsTESTINGBACKFILL          V0041JobDescMsgFlags = "TESTING_BACKFILL"
	V0041JobDescMsgFlagsTESTINGWHOLENODEBACKFILL V0041JobDescMsgFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041JobDescMsgFlagsTESTNOWONLY              V0041JobDescMsgFlags = "TEST_NOW_ONLY"
	V0041JobDescMsgFlagsTOPPRIORITYJOB           V0041JobDescMsgFlags = "TOP_PRIORITY_JOB"
	V0041JobDescMsgFlagsUSINGDEFAULTACCOUNT      V0041JobDescMsgFlags = "USING_DEFAULT_ACCOUNT"
	V0041JobDescMsgFlagsUSINGDEFAULTPARTITION    V0041JobDescMsgFlags = "USING_DEFAULT_PARTITION"
	V0041JobDescMsgFlagsUSINGDEFAULTQOS          V0041JobDescMsgFlags = "USING_DEFAULT_QOS"
	V0041JobDescMsgFlagsUSINGDEFAULTWCKEY        V0041JobDescMsgFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041JobDescMsgKillWarningFlags.
const (
	V0041JobDescMsgKillWarningFlagsARRAYTASK         V0041JobDescMsgKillWarningFlags = "ARRAY_TASK"
	V0041JobDescMsgKillWarningFlagsBATCHJOB          V0041JobDescMsgKillWarningFlags = "BATCH_JOB"
	V0041JobDescMsgKillWarningFlagsCRONJOBS          V0041JobDescMsgKillWarningFlags = "CRON_JOBS"
	V0041JobDescMsgKillWarningFlagsFEDERATIONREQUEUE V0041JobDescMsgKillWarningFlags = "FEDERATION_REQUEUE"
	V0041JobDescMsgKillWarningFlagsFULLJOB           V0041JobDescMsgKillWarningFlags = "FULL_JOB"
	V0041JobDescMsgKillWarningFlagsFULLSTEPSONLY     V0041JobDescMsgKillWarningFlags = "FULL_STEPS_ONLY"
	V0041JobDescMsgKillWarningFlagsHURRY             V0041JobDescMsgKillWarningFlags = "HURRY"
	V0041JobDescMsgKillWarningFlagsNOSIBLINGJOBS     V0041JobDescMsgKillWarningFlags = "NO_SIBLING_JOBS"
	V0041JobDescMsgKillWarningFlagsOUTOFMEMORY       V0041JobDescMsgKillWarningFlags = "OUT_OF_MEMORY"
	V0041JobDescMsgKillWarningFlagsRESERVATIONJOB    V0041JobDescMsgKillWarningFlags = "RESERVATION_JOB"
	V0041JobDescMsgKillWarningFlagsVERBOSE           V0041JobDescMsgKillWarningFlags = "VERBOSE"
	V0041JobDescMsgKillWarningFlagsWARNINGSENT       V0041JobDescMsgKillWarningFlags = "WARNING_SENT"
)

// Defines values for V0041JobDescMsgMailType.
const (
	V0041JobDescMsgMailTypeARRAYTASKS        V0041JobDescMsgMailType = "ARRAY_TASKS"
	V0041JobDescMsgMailTypeBEGIN             V0041JobDescMsgMailType = "BEGIN"
	V0041JobDescMsgMailTypeEND               V0041JobDescMsgMailType = "END"
	V0041JobDescMsgMailTypeFAIL              V0041JobDescMsgMailType = "FAIL"
	V0041JobDescMsgMailTypeINVALIDDEPENDENCY V0041JobDescMsgMailType = "INVALID_DEPENDENCY"
	V0041JobDescMsgMailTypeREQUEUE           V0041JobDescMsgMailType = "REQUEUE"
	V0041JobDescMsgMailTypeSTAGEOUT          V0041JobDescMsgMailType = "STAGE_OUT"
	V0041JobDescMsgMailTypeTIME100           V0041JobDescMsgMailType = "TIME=100%"
	V0041JobDescMsgMailTypeTIME50            V0041JobDescMsgMailType = "TIME=50%"
	V0041JobDescMsgMailTypeTIME80            V0041JobDescMsgMailType = "TIME=80%"
	V0041JobDescMsgMailTypeTIME90            V0041JobDescMsgMailType = "TIME=90%"
)

// Defines values for V0041JobDescMsgMemoryBindingType.
const (
	V0041JobDescMsgMemoryBindingTypeLOCAL   V0041JobDescMsgMemoryBindingType = "LOCAL"
	V0041JobDescMsgMemoryBindingTypeMAP     V0041JobDescMsgMemoryBindingType = "MAP"
	V0041JobDescMsgMemoryBindingTypeMASK    V0041JobDescMsgMemoryBindingType = "MASK"
	V0041JobDescMsgMemoryBindingTypeNONE    V0041JobDescMsgMemoryBindingType = "NONE"
	V0041JobDescMsgMemoryBindingTypePREFER  V0041JobDescMsgMemoryBindingType = "PREFER"
	V0041JobDescMsgMemoryBindingTypeRANK    V0041JobDescMsgMemoryBindingType = "RANK"
	V0041JobDescMsgMemoryBindingTypeSORT    V0041JobDescMsgMemoryBindingType = "SORT"
	V0041JobDescMsgMemoryBindingTypeVERBOSE V0041JobDescMsgMemoryBindingType = "VERBOSE"
)

// Defines values for V0041JobDescMsgOpenMode.
const (
	APPEND   V0041JobDescMsgOpenMode = "APPEND"
	TRUNCATE V0041JobDescMsgOpenMode = "TRUNCATE"
)

// Defines values for V0041JobDescMsgProfile.
const (
	V0041JobDescMsgProfileENERGY  V0041JobDescMsgProfile = "ENERGY"
	V0041JobDescMsgProfileLUSTRE  V0041JobDescMsgProfile = "LUSTRE"
	V0041JobDescMsgProfileNETWORK V0041JobDescMsgProfile = "NETWORK"
	V0041JobDescMsgProfileNONE    V0041JobDescMsgProfile = "NONE"
	V0041JobDescMsgProfileNOTSET  V0041JobDescMsgProfile = "NOT_SET"
	V0041JobDescMsgProfileTASK    V0041JobDescMsgProfile = "TASK"
)

// Defines values for V0041JobDescMsgShared.
const (
	V0041JobDescMsgSharedMcs           V0041JobDescMsgShared = "mcs"
	V0041JobDescMsgSharedNone          V0041JobDescMsgShared = "none"
	V0041JobDescMsgSharedOversubscribe V0041JobDescMsgShared = "oversubscribe"
	V0041JobDescMsgSharedTopo          V0041JobDescMsgShared = "topo"
	V0041JobDescMsgSharedUser          V0041JobDescMsgShared = "user"
)

// Defines values for V0041JobDescMsgX11.
const (
	BATCHNODE       V0041JobDescMsgX11 = "BATCH_NODE"
	FIRSTNODE       V0041JobDescMsgX11 = "FIRST_NODE"
	FORWARDALLNODES V0041JobDescMsgX11 = "FORWARD_ALL_NODES"
	LASTNODE        V0041JobDescMsgX11 = "LAST_NODE"
)

// Defines values for V0041JobInfoExclusive.
const (
	V0041JobInfoExclusiveFalse V0041JobInfoExclusive = "false"
	V0041JobInfoExclusiveMcs   V0041JobInfoExclusive = "mcs"
	V0041JobInfoExclusiveTopo  V0041JobInfoExclusive = "topo"
	V0041JobInfoExclusiveTrue  V0041JobInfoExclusive = "true"
	V0041JobInfoExclusiveUser  V0041JobInfoExclusive = "user"
)

// Defines values for V0041JobInfoFlags.
const (
	V0041JobInfoFlagsACCRUECOUNTCLEARED       V0041JobInfoFlags = "ACCRUE_COUNT_CLEARED"
	V0041JobInfoFlagsBACKFILLATTEMPTED        V0041JobInfoFlags = "BACKFILL_ATTEMPTED"
	V0041JobInfoFlagsCRONJOB                  V0041JobInfoFlags = "CRON_JOB"
	V0041JobInfoFlagsDEPENDENT                V0041JobInfoFlags = "DEPENDENT"
	V0041JobInfoFlagsEXACTCPUCOUNTREQUESTED   V0041JobInfoFlags = "EXACT_CPU_COUNT_REQUESTED"
	V0041JobInfoFlagsEXACTMEMORYREQUESTED     V0041JobInfoFlags = "EXACT_MEMORY_REQUESTED"
	V0041JobInfoFlagsEXACTTASKCOUNTREQUESTED  V0041JobInfoFlags = "EXACT_TASK_COUNT_REQUESTED"
	V0041JobInfoFlagsGRESBINDINGDISABLED      V0041JobInfoFlags = "GRES_BINDING_DISABLED"
	V0041JobInfoFlagsGRESBINDINGENFORCED      V0041JobInfoFlags = "GRES_BINDING_ENFORCED"
	V0041JobInfoFlagsHASSTATEDIRECTORY        V0041JobInfoFlags = "HAS_STATE_DIRECTORY"
	V0041JobInfoFlagsHETEROGENEOUSJOB         V0041JobInfoFlags = "HETEROGENEOUS_JOB"
	V0041JobInfoFlagsJOBACCRUETIMERESET       V0041JobInfoFlags = "JOB_ACCRUE_TIME_RESET"
	V0041JobInfoFlagsJOBKILLHURRY             V0041JobInfoFlags = "JOB_KILL_HURRY"
	V0041JobInfoFlagsJOBWASRUNNING            V0041JobInfoFlags = "JOB_WAS_RUNNING"
	V0041JobInfoFlagsKILLINVALIDDEPENDENCY    V0041JobInfoFlags = "KILL_INVALID_DEPENDENCY"
	V0041JobInfoFlagsMAGNETIC                 V0041JobInfoFlags = "MAGNETIC"
	V0041JobInfoFlagsNOKILLINVALIDDEPENDENCY  V0041JobInfoFlags = "NO_KILL_INVALID_DEPENDENCY"
	V0041JobInfoFlagsPARTITIONASSIGNED        V0041JobInfoFlags = "PARTITION_ASSIGNED"
	V0041JobInfoFlagsPREFERMINIMUMNODECOUNT   V0041JobInfoFlags = "PREFER_MINIMUM_NODE_COUNT"
	V0041JobInfoFlagsSCHEDULINGATTEMPTED      V0041JobInfoFlags = "SCHEDULING_ATTEMPTED"
	V0041JobInfoFlagsSENDJOBENVIRONMENT       V0041JobInfoFlags = "SEND_JOB_ENVIRONMENT"
	V0041JobInfoFlagsSIBLINGCLUSTERUPDATEONLY V0041JobInfoFlags = "SIBLING_CLUSTER_UPDATE_ONLY"
	V0041JobInfoFlagsSKIPTRESSTRINGACCOUNTING V0041JobInfoFlags = "SKIP_TRES_STRING_ACCOUNTING"
	V0041JobInfoFlagsSPREADJOB                V0041JobInfoFlags = "SPREAD_JOB"
	V0041JobInfoFlagsSTEPMGRENABLED           V0041JobInfoFlags = "STEPMGR_ENABLED"
	V0041JobInfoFlagsTESTINGBACKFILL          V0041JobInfoFlags = "TESTING_BACKFILL"
	V0041JobInfoFlagsTESTINGWHOLENODEBACKFILL V0041JobInfoFlags = "TESTING_WHOLE_NODE_BACKFILL"
	V0041JobInfoFlagsTESTNOWONLY              V0041JobInfoFlags = "TEST_NOW_ONLY"
	V0041JobInfoFlagsTOPPRIORITYJOB           V0041JobInfoFlags = "TOP_PRIORITY_JOB"
	V0041JobInfoFlagsUSINGDEFAULTACCOUNT      V0041JobInfoFlags = "USING_DEFAULT_ACCOUNT"
	V0041JobInfoFlagsUSINGDEFAULTPARTITION    V0041JobInfoFlags = "USING_DEFAULT_PARTITION"
	V0041JobInfoFlagsUSINGDEFAULTQOS          V0041JobInfoFlags = "USING_DEFAULT_QOS"
	V0041JobInfoFlagsUSINGDEFAULTWCKEY        V0041JobInfoFlags = "USING_DEFAULT_WCKEY"
)

// Defines values for V0041JobInfoJobState.
const (
	V0041JobInfoJobStateBOOTFAIL     V0041JobInfoJobState = "BOOT_FAIL"
	V0041JobInfoJobStateCANCELLED    V0041JobInfoJobState = "CANCELLED"
	V0041JobInfoJobStateCOMPLETED    V0041JobInfoJobState = "COMPLETED"
	V0041JobInfoJobStateCOMPLETING   V0041JobInfoJobState = "COMPLETING"
	V0041JobInfoJobStateCONFIGURING  V0041JobInfoJobState = "CONFIGURING"
	V0041JobInfoJobStateDEADLINE     V0041JobInfoJobState = "DEADLINE"
	V0041JobInfoJobStateFAILED       V0041JobInfoJobState = "FAILED"
	V0041JobInfoJobStateLAUNCHFAILED V0041JobInfoJobState = "LAUNCH_FAILED"
	V0041JobInfoJobStateNODEFAIL     V0041JobInfoJobState = "NODE_FAIL"
	V0041JobInfoJobStateOUTOFMEMORY  V0041JobInfoJobState = "OUT_OF_MEMORY"
	V0041JobInfoJobStatePENDING      V0041JobInfoJobState = "PENDING"
	V0041JobInfoJobStatePOWERUPNODE  V0041JobInfoJobState = "POWER_UP_NODE"
	V0041JobInfoJobStatePREEMPTED    V0041JobInfoJobState = "PREEMPTED"
	V0041JobInfoJobStateRECONFIGFAIL V0041JobInfoJobState = "RECONFIG_FAIL"
	V0041JobInfoJobStateREQUEUED     V0041JobInfoJobState = "REQUEUED"
	V0041JobInfoJobStateREQUEUEFED   V0041JobInfoJobState = "REQUEUE_FED"
	V0041JobInfoJobStateREQUEUEHOLD  V0041JobInfoJobState = "REQUEUE_HOLD"
	V0041JobInfoJobStateRESIZING     V0041JobInfoJobState = "RESIZING"
	V0041JobInfoJobStateRESVDELHOLD  V0041JobInfoJobState = "RESV_DEL_HOLD"
	V0041JobInfoJobStateREVOKED      V0041JobInfoJobState = "REVOKED"
	V0041JobInfoJobStateRUNNING      V0041JobInfoJobState = "RUNNING"
	V0041JobInfoJobStateSIGNALING    V0041JobInfoJobState = "SIGNALING"
	V0041JobInfoJobStateSPECIALEXIT  V0041JobInfoJobState = "SPECIAL_EXIT"
	V0041JobInfoJobStateSTAGEOUT     V0041JobInfoJobState = "STAGE_OUT"
	V0041JobInfoJobStateSTOPPED      V0041JobInfoJobState = "STOPPED"
	V0041JobInfoJobStateSUSPENDED    V0041JobInfoJobState = "SUSPENDED"
	V0041JobInfoJobStateTIMEOUT      V0041JobInfoJobState = "TIMEOUT"
	V0041JobInfoJobStateUPDATEDB     V0041JobInfoJobState = "UPDATE_DB"
)

// Defines values for V0041JobInfoMailType.
const (
	V0041JobInfoMailTypeARRAYTASKS        V0041JobInfoMailType = "ARRAY_TASKS"
	V0041JobInfoMailTypeBEGIN             V0041JobInfoMailType = "BEGIN"
	V0041JobInfoMailTypeEND               V0041JobInfoMailType = "END"
	V0041JobInfoMailTypeFAIL              V0041JobInfoMailType = "FAIL"
	V0041JobInfoMailTypeINVALIDDEPENDENCY V0041JobInfoMailType = "INVALID_DEPENDENCY"
	V0041JobInfoMailTypeREQUEUE           V0041JobInfoMailType = "REQUEUE"
	V0041JobInfoMailTypeSTAGEOUT          V0041JobInfoMailType = "STAGE_OUT"
	V0041JobInfoMailTypeTIME100           V0041JobInfoMailType = "TIME=100%"
	V0041JobInfoMailTypeTIME50            V0041JobInfoMailType = "TIME=50%"
	V0041JobInfoMailTypeTIME80            V0041JobInfoMailType = "TIME=80%"
	V0041JobInfoMailTypeTIME90            V0041JobInfoMailType = "TIME=90%"
)

// Defines values for V0041JobInfoProfile.
const (
	V0041JobInfoProfileENERGY  V0041JobInfoProfile = "ENERGY"
	V0041JobInfoProfileLUSTRE  V0041JobInfoProfile = "LUSTRE"
	V0041JobInfoProfileNETWORK V0041JobInfoProfile = "NETWORK"
	V0041JobInfoProfileNONE    V0041JobInfoProfile = "NONE"
	V0041JobInfoProfileNOTSET  V0041JobInfoProfile = "NOT_SET"
	V0041JobInfoProfileTASK    V0041JobInfoProfile = "TASK"
)

// Defines values for V0041JobInfoShared.
const (
	V0041JobInfoSharedMcs           V0041JobInfoShared = "mcs"
	V0041JobInfoSharedNone          V0041JobInfoShared = "none"
	V0041JobInfoSharedOversubscribe V0041JobInfoShared = "oversubscribe"
	V0041JobInfoSharedTopo          V0041JobInfoShared = "topo"
	V0041JobInfoSharedUser          V0041JobInfoShared = "user"
)

// Defines values for V0041JobInfoShowFlags.
const (
	V0041JobInfoShowFlagsALL        V0041JobInfoShowFlags = "ALL"
	V0041JobInfoShowFlagsDETAIL     V0041JobInfoShowFlags = "DETAIL"
	V0041JobInfoShowFlagsFEDERATION V0041JobInfoShowFlags = "FEDERATION"
	V0041JobInfoShowFlagsFUTURE     V0041JobInfoShowFlags = "FUTURE"
	V0041JobInfoShowFlagsLOCAL      V0041JobInfoShowFlags = "LOCAL"
	V0041JobInfoShowFlagsMIXED      V0041JobInfoShowFlags = "MIXED"
	V0041JobInfoShowFlagsSIBLING    V0041JobInfoShowFlags = "SIBLING"
)

// Defines values for V0041JobResNodesSelectType.
const (
	V0041JobResNodesSelectTypeAVAILABLE V0041JobResNodesSelectType = "AVAILABLE"
	V0041JobResNodesSelectTypeONEROW    V0041JobResNodesSelectType = "ONE_ROW"
	V0041JobResNodesSelectTypeRESERVED  V0041JobResNodesSelectType = "RESERVED"
)

// Defines values for V0041JobResSelectType.
const (
	V0041JobResSelectTypeBOARD                V0041JobResSelectType = "BOARD"
	V0041JobResSelectTypeCORE                 V0041JobResSelectType = "CORE"
	V0041JobResSelectTypeCOREDEFAULTDISTBLOCK V0041JobResSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041JobResSelectTypeCPU                  V0041JobResSelectType = "CPU"
	V0041JobResSelectTypeLINEAR               V0041JobResSelectType = "LINEAR"
	V0041JobResSelectTypeLLN                  V0041JobResSelectType = "LLN"
	V0041JobResSelectTypeMEMORY               V0041JobResSelectType = "MEMORY"
	V0041JobResSelectTypeONETASKPERCORE       V0041JobResSelectType = "ONE_TASK_PER_CORE"
	V0041JobResSelectTypePACKNODES            V0041JobResSelectType = "PACK_NODES"
	V0041JobResSelectTypeSOCKET               V0041JobResSelectType = "SOCKET"
)

// Defines values for V0041JobResCoreStatus.
const (
	V0041JobResCoreStatusALLOCATED   V0041JobResCoreStatus = "ALLOCATED"
	V0041JobResCoreStatusINUSE       V0041JobResCoreStatus = "IN_USE"
	V0041JobResCoreStatusINVALID     V0041JobResCoreStatus = "INVALID"
	V0041JobResCoreStatusUNALLOCATED V0041JobResCoreStatus = "UNALLOCATED"
)

// Defines values for V0041KillJobsMsgFlags.
const (
	V0041KillJobsMsgFlagsARRAYTASK         V0041KillJobsMsgFlags = "ARRAY_TASK"
	V0041KillJobsMsgFlagsBATCHJOB          V0041KillJobsMsgFlags = "BATCH_JOB"
	V0041KillJobsMsgFlagsCRONJOBS          V0041KillJobsMsgFlags = "CRON_JOBS"
	V0041KillJobsMsgFlagsFEDERATIONREQUEUE V0041KillJobsMsgFlags = "FEDERATION_REQUEUE"
	V0041KillJobsMsgFlagsFULLJOB           V0041KillJobsMsgFlags = "FULL_JOB"
	V0041KillJobsMsgFlagsFULLSTEPSONLY     V0041KillJobsMsgFlags = "FULL_STEPS_ONLY"
	V0041KillJobsMsgFlagsHURRY             V0041KillJobsMsgFlags = "HURRY"
	V0041KillJobsMsgFlagsNOSIBLINGJOBS     V0041KillJobsMsgFlags = "NO_SIBLING_JOBS"
	V0041KillJobsMsgFlagsOUTOFMEMORY       V0041KillJobsMsgFlags = "OUT_OF_MEMORY"
	V0041KillJobsMsgFlagsRESERVATIONJOB    V0041KillJobsMsgFlags = "RESERVATION_JOB"
	V0041KillJobsMsgFlagsVERBOSE           V0041KillJobsMsgFlags = "VERBOSE"
	V0041KillJobsMsgFlagsWARNINGSENT       V0041KillJobsMsgFlags = "WARNING_SENT"
)

// Defines values for V0041KillJobsMsgJobState.
const (
	V0041KillJobsMsgJobStateBOOTFAIL     V0041KillJobsMsgJobState = "BOOT_FAIL"
	V0041KillJobsMsgJobStateCANCELLED    V0041KillJobsMsgJobState = "CANCELLED"
	V0041KillJobsMsgJobStateCOMPLETED    V0041KillJobsMsgJobState = "COMPLETED"
	V0041KillJobsMsgJobStateCOMPLETING   V0041KillJobsMsgJobState = "COMPLETING"
	V0041KillJobsMsgJobStateCONFIGURING  V0041KillJobsMsgJobState = "CONFIGURING"
	V0041KillJobsMsgJobStateDEADLINE     V0041KillJobsMsgJobState = "DEADLINE"
	V0041KillJobsMsgJobStateFAILED       V0041KillJobsMsgJobState = "FAILED"
	V0041KillJobsMsgJobStateLAUNCHFAILED V0041KillJobsMsgJobState = "LAUNCH_FAILED"
	V0041KillJobsMsgJobStateNODEFAIL     V0041KillJobsMsgJobState = "NODE_FAIL"
	V0041KillJobsMsgJobStateOUTOFMEMORY  V0041KillJobsMsgJobState = "OUT_OF_MEMORY"
	V0041KillJobsMsgJobStatePENDING      V0041KillJobsMsgJobState = "PENDING"
	V0041KillJobsMsgJobStatePOWERUPNODE  V0041KillJobsMsgJobState = "POWER_UP_NODE"
	V0041KillJobsMsgJobStatePREEMPTED    V0041KillJobsMsgJobState = "PREEMPTED"
	V0041KillJobsMsgJobStateRECONFIGFAIL V0041KillJobsMsgJobState = "RECONFIG_FAIL"
	V0041KillJobsMsgJobStateREQUEUED     V0041KillJobsMsgJobState = "REQUEUED"
	V0041KillJobsMsgJobStateREQUEUEFED   V0041KillJobsMsgJobState = "REQUEUE_FED"
	V0041KillJobsMsgJobStateREQUEUEHOLD  V0041KillJobsMsgJobState = "REQUEUE_HOLD"
	V0041KillJobsMsgJobStateRESIZING     V0041KillJobsMsgJobState = "RESIZING"
	V0041KillJobsMsgJobStateRESVDELHOLD  V0041KillJobsMsgJobState = "RESV_DEL_HOLD"
	V0041KillJobsMsgJobStateREVOKED      V0041KillJobsMsgJobState = "REVOKED"
	V0041KillJobsMsgJobStateRUNNING      V0041KillJobsMsgJobState = "RUNNING"
	V0041KillJobsMsgJobStateSIGNALING    V0041KillJobsMsgJobState = "SIGNALING"
	V0041KillJobsMsgJobStateSPECIALEXIT  V0041KillJobsMsgJobState = "SPECIAL_EXIT"
	V0041KillJobsMsgJobStateSTAGEOUT     V0041KillJobsMsgJobState = "STAGE_OUT"
	V0041KillJobsMsgJobStateSTOPPED      V0041KillJobsMsgJobState = "STOPPED"
	V0041KillJobsMsgJobStateSUSPENDED    V0041KillJobsMsgJobState = "SUSPENDED"
	V0041KillJobsMsgJobStateTIMEOUT      V0041KillJobsMsgJobState = "TIMEOUT"
	V0041KillJobsMsgJobStateUPDATEDB     V0041KillJobsMsgJobState = "UPDATE_DB"
)

// Defines values for V0041NodeNextStateAfterReboot.
const (
	V0041NodeNextStateAfterRebootALLOCATED       V0041NodeNextStateAfterReboot = "ALLOCATED"
	V0041NodeNextStateAfterRebootCLOUD           V0041NodeNextStateAfterReboot = "CLOUD"
	V0041NodeNextStateAfterRebootCOMPLETING      V0041NodeNextStateAfterReboot = "COMPLETING"
	V0041NodeNextStateAfterRebootDOWN            V0041NodeNextStateAfterReboot = "DOWN"
	V0041NodeNextStateAfterRebootDRAIN           V0041NodeNextStateAfterReboot = "DRAIN"
	V0041NodeNextStateAfterRebootDYNAMICFUTURE   V0041NodeNextStateAfterReboot = "DYNAMIC_FUTURE"
	V0041NodeNextStateAfterRebootDYNAMICNORM     V0041NodeNextStateAfterReboot = "DYNAMIC_NORM"
	V0041NodeNextStateAfterRebootERROR           V0041NodeNextStateAfterReboot = "ERROR"
	V0041NodeNextStateAfterRebootFAIL            V0041NodeNextStateAfterReboot = "FAIL"
	V0041NodeNextStateAfterRebootFUTURE          V0041NodeNextStateAfterReboot = "FUTURE"
	V0041NodeNextStateAfterRebootIDLE            V0041NodeNextStateAfterReboot = "IDLE"
	V0041NodeNextStateAfterRebootINVALID         V0041NodeNextStateAfterReboot = "INVALID"
	V0041NodeNextStateAfterRebootINVALIDREG      V0041NodeNextStateAfterReboot = "INVALID_REG"
	V0041NodeNextStateAfterRebootMAINTENANCE     V0041NodeNextStateAfterReboot = "MAINTENANCE"
	V0041NodeNextStateAfterRebootMIXED           V0041NodeNextStateAfterReboot = "MIXED"
	V0041NodeNextStateAfterRebootNOTRESPONDING   V0041NodeNextStateAfterReboot = "NOT_RESPONDING"
	V0041NodeNextStateAfterRebootPLANNED         V0041NodeNextStateAfterReboot = "PLANNED"
	V0041NodeNextStateAfterRebootPOWERDOWN       V0041NodeNextStateAfterReboot = "POWER_DOWN"
	V0041NodeNextStateAfterRebootPOWERDRAIN      V0041NodeNextStateAfterReboot = "POWER_DRAIN"
	V0041NodeNextStateAfterRebootPOWEREDDOWN     V0041NodeNextStateAfterReboot = "POWERED_DOWN"
	V0041NodeNextStateAfterRebootPOWERINGDOWN    V0041NodeNextStateAfterReboot = "POWERING_DOWN"
	V0041NodeNextStateAfterRebootPOWERINGUP      V0041NodeNextStateAfterReboot = "POWERING_UP"
	V0041NodeNextStateAfterRebootPOWERUP         V0041NodeNextStateAfterReboot = "POWER_UP"
	V0041NodeNextStateAfterRebootREBOOTCANCELED  V0041NodeNextStateAfterReboot = "REBOOT_CANCELED"
	V0041NodeNextStateAfterRebootREBOOTISSUED    V0041NodeNextStateAfterReboot = "REBOOT_ISSUED"
	V0041NodeNextStateAfterRebootREBOOTREQUESTED V0041NodeNextStateAfterReboot = "REBOOT_REQUESTED"
	V0041NodeNextStateAfterRebootRESERVED        V0041NodeNextStateAfterReboot = "RESERVED"
	V0041NodeNextStateAfterRebootRESUME          V0041NodeNextStateAfterReboot = "RESUME"
	V0041NodeNextStateAfterRebootUNDRAIN         V0041NodeNextStateAfterReboot = "UNDRAIN"
	V0041NodeNextStateAfterRebootUNKNOWN         V0041NodeNextStateAfterReboot = "UNKNOWN"
)

// Defines values for V0041NodeState.
const (
	V0041NodeStateALLOCATED       V0041NodeState = "ALLOCATED"
	V0041NodeStateCLOUD           V0041NodeState = "CLOUD"
	V0041NodeStateCOMPLETING      V0041NodeState = "COMPLETING"
	V0041NodeStateDOWN            V0041NodeState = "DOWN"
	V0041NodeStateDRAIN           V0041NodeState = "DRAIN"
	V0041NodeStateDYNAMICFUTURE   V0041NodeState = "DYNAMIC_FUTURE"
	V0041NodeStateDYNAMICNORM     V0041NodeState = "DYNAMIC_NORM"
	V0041NodeStateERROR           V0041NodeState = "ERROR"
	V0041NodeStateFAIL            V0041NodeState = "FAIL"
	V0041NodeStateFUTURE          V0041NodeState = "FUTURE"
	V0041NodeStateIDLE            V0041NodeState = "IDLE"
	V0041NodeStateINVALID         V0041NodeState = "INVALID"
	V0041NodeStateINVALIDREG      V0041NodeState = "INVALID_REG"
	V0041NodeStateMAINTENANCE     V0041NodeState = "MAINTENANCE"
	V0041NodeStateMIXED           V0041NodeState = "MIXED"
	V0041NodeStateNOTRESPONDING   V0041NodeState = "NOT_RESPONDING"
	V0041NodeStatePLANNED         V0041NodeState = "PLANNED"
	V0041NodeStatePOWERDOWN       V0041NodeState = "POWER_DOWN"
	V0041NodeStatePOWERDRAIN      V0041NodeState = "POWER_DRAIN"
	V0041NodeStatePOWEREDDOWN     V0041NodeState = "POWERED_DOWN"
	V0041NodeStatePOWERINGDOWN    V0041NodeState = "POWERING_DOWN"
	V0041NodeStatePOWERINGUP      V0041NodeState = "POWERING_UP"
	V0041NodeStatePOWERUP         V0041NodeState = "POWER_UP"
	V0041NodeStateREBOOTCANCELED  V0041NodeState = "REBOOT_CANCELED"
	V0041NodeStateREBOOTISSUED    V0041NodeState = "REBOOT_ISSUED"
	V0041NodeStateREBOOTREQUESTED V0041NodeState = "REBOOT_REQUESTED"
	V0041NodeStateRESERVED        V0041NodeState = "RESERVED"
	V0041NodeStateRESUME          V0041NodeState = "RESUME"
	V0041NodeStateUNDRAIN         V0041NodeState = "UNDRAIN"
	V0041NodeStateUNKNOWN         V0041NodeState = "UNKNOWN"
)

// Defines values for V0041PartitionInfoMaximumsOversubscribeFlags.
const (
	Force V0041PartitionInfoMaximumsOversubscribeFlags = "force"
)

// Defines values for V0041PartitionInfoPartitionState.
const (
	V0041PartitionInfoPartitionStateDOWN     V0041PartitionInfoPartitionState = "DOWN"
	V0041PartitionInfoPartitionStateDRAIN    V0041PartitionInfoPartitionState = "DRAIN"
	V0041PartitionInfoPartitionStateINACTIVE V0041PartitionInfoPartitionState = "INACTIVE"
	V0041PartitionInfoPartitionStateUNKNOWN  V0041PartitionInfoPartitionState = "UNKNOWN"
	V0041PartitionInfoPartitionStateUP       V0041PartitionInfoPartitionState = "UP"
)

// Defines values for V0041PartitionInfoSelectType.
const (
	V0041PartitionInfoSelectTypeBOARD                V0041PartitionInfoSelectType = "BOARD"
	V0041PartitionInfoSelectTypeCORE                 V0041PartitionInfoSelectType = "CORE"
	V0041PartitionInfoSelectTypeCOREDEFAULTDISTBLOCK V0041PartitionInfoSelectType = "CORE_DEFAULT_DIST_BLOCK"
	V0041PartitionInfoSelectTypeCPU                  V0041PartitionInfoSelectType = "CPU"
	V0041PartitionInfoSelectTypeLINEAR               V0041PartitionInfoSelectType = "LINEAR"
	V0041PartitionInfoSelectTypeLLN                  V0041PartitionInfoSelectType = "LLN"
	V0041PartitionInfoSelectTypeMEMORY               V0041PartitionInfoSelectType = "MEMORY"
	V0041PartitionInfoSelectTypeONETASKPERCORE       V0041PartitionInfoSelectType = "ONE_TASK_PER_CORE"
	V0041PartitionInfoSelectTypePACKNODES            V0041PartitionInfoSelectType = "PACK_NODES"
	V0041PartitionInfoSelectTypeSOCKET               V0041PartitionInfoSelectType = "SOCKET"
)

// Defines values for V0041ProcessExitCodeVerboseStatus.
const (
	V0041ProcessExitCodeVerboseStatusCOREDUMPED V0041ProcessExitCodeVerboseStatus = "CORE_DUMPED"
	V0041ProcessExitCodeVerboseStatusERROR      V0041ProcessExitCodeVerboseStatus = "ERROR"
	V0041ProcessExitCodeVerboseStatusINVALID    V0041ProcessExitCodeVerboseStatus = "INVALID"
	V0041ProcessExitCodeVerboseStatusPENDING    V0041ProcessExitCodeVerboseStatus = "PENDING"
	V0041ProcessExitCodeVerboseStatusSIGNALED   V0041ProcessExitCodeVerboseStatus = "SIGNALED"
	V0041ProcessExitCodeVerboseStatusSUCCESS    V0041ProcessExitCodeVerboseStatus = "SUCCESS"
)

// Defines values for V0041QosFlags.
const (
	ADD                   V0041QosFlags = "ADD"
	DENYLIMIT             V0041QosFlags = "DENY_LIMIT"
	ENFORCEUSAGETHRESHOLD V0041QosFlags = "ENFORCE_USAGE_THRESHOLD"
	NODECAY               V0041QosFlags = "NO_DECAY"
	NORESERVE             V0041QosFlags = "NO_RESERVE"
	NOTSET                V0041QosFlags = "NOT_SET"
	OVERRIDEPARTITIONQOS  V0041QosFlags = "OVERRIDE_PARTITION_QOS"
	PARTITIONMAXIMUMNODE  V0041QosFlags = "PARTITION_MAXIMUM_NODE"
	PARTITIONMINIMUMNODE  V0041QosFlags = "PARTITION_MINIMUM_NODE"
	PARTITIONTIMELIMIT    V0041QosFlags = "PARTITION_TIME_LIMIT"
	RELATIVE              V0041QosFlags = "RELATIVE"
	REMOVE                V0041QosFlags = "REMOVE"
	REQUIREDRESERVATION   V0041QosFlags = "REQUIRED_RESERVATION"
	USAGEFACTORSAFE       V0041QosFlags = "USAGE_FACTOR_SAFE"
)

// Defines values for V0041QosPreemptMode.
const (
	V0041QosPreemptModeCANCEL   V0041QosPreemptMode = "CANCEL"
	V0041QosPreemptModeDISABLED V0041QosPreemptMode = "DISABLED"
	V0041QosPreemptModeGANG     V0041QosPreemptMode = "GANG"
	V0041QosPreemptModeREQUEUE  V0041QosPreemptMode = "REQUEUE"
	V0041QosPreemptModeSUSPEND  V0041QosPreemptMode = "SUSPEND"
)

// Defines values for V0041ReservationInfoFlags.
const (
	ALLNODES           V0041ReservationInfoFlags = "ALL_NODES"
	ANYNODES           V0041ReservationInfoFlags = "ANY_NODES"
	DAILY              V0041ReservationInfoFlags = "DAILY"
	DURATIONMINUS      V0041ReservationInfoFlags = "DURATION_MINUS"
	DURATIONPLUS       V0041ReservationInfoFlags = "DURATION_PLUS"
	FLEX               V0041ReservationInfoFlags = "FLEX"
	HOURLY             V0041ReservationInfoFlags = "HOURLY"
	IGNOREJOBS         V0041ReservationInfoFlags = "IGNORE_JOBS"
	MAGNETIC           V0041ReservationInfoFlags = "MAGNETIC"
	MAINT              V0041ReservationInfoFlags = "MAINT"
	NODAILY            V0041ReservationInfoFlags = "NO_DAILY"
	NOFLEX             V0041ReservationInfoFlags = "NO_FLEX"
	NOHOLDJOBSAFTEREND V0041ReservationInfoFlags = "NO_HOLD_JOBS_AFTER_END"
	NOHOURLY           V0041ReservationInfoFlags = "NO_HOURLY"
	NOIGNOREJOBS       V0041ReservationInfoFlags = "NO_IGNORE_JOBS"
	NOMAINT            V0041ReservationInfoFlags = "NO_MAINT"
	NOPARTNODES        V0041ReservationInfoFlags = "NO_PART_NODES"
	NOPURGECOMP        V0041ReservationInfoFlags = "NO_PURGE_COMP"
	NOSTATIC           V0041ReservationInfoFlags = "NO_STATIC"
	NOUSERDELETE       V0041ReservationInfoFlags = "NO_USER_DELETE"
	NOWEEKDAY          V0041ReservationInfoFlags = "NO_WEEKDAY"
	NOWEEKEND          V0041ReservationInfoFlags = "NO_WEEKEND"
	NOWEEKLY           V0041ReservationInfoFlags = "NO_WEEKLY"
	OVERLAP            V0041ReservationInfoFlags = "OVERLAP"
	PARTNODES          V0041ReservationInfoFlags = "PART_NODES"
	PURGECOMP          V0041ReservationInfoFlags = "PURGE_COMP"
	REOCCURRING        V0041ReservationInfoFlags = "REOCCURRING"
	REPLACE            V0041ReservationInfoFlags = "REPLACE"
	SKIP               V0041ReservationInfoFlags = "SKIP"
	SPECNODES          V0041ReservationInfoFlags = "SPEC_NODES"
	STATIC             V0041ReservationInfoFlags = "STATIC"
	TIMEFLOAT          V0041ReservationInfoFlags = "TIME_FLOAT"
	USERDELETE         V0041ReservationInfoFlags = "USER_DELETE"
	WEEKDAY            V0041ReservationInfoFlags = "WEEKDAY"
	WEEKEND            V0041ReservationInfoFlags = "WEEKEND"
	WEEKLY             V0041ReservationInfoFlags = "WEEKLY"
)

// Defines values for V0041StepState.
const (
	V0041StepStateBOOTFAIL     V0041StepState = "BOOT_FAIL"
	V0041StepStateCANCELLED    V0041StepState = "CANCELLED"
	V0041StepStateCOMPLETED    V0041StepState = "COMPLETED"
	V0041StepStateCOMPLETING   V0041StepState = "COMPLETING"
	V0041StepStateCONFIGURING  V0041StepState = "CONFIGURING"
	V0041StepStateDEADLINE     V0041StepState = "DEADLINE"
	V0041StepStateFAILED       V0041StepState = "FAILED"
	V0041StepStateLAUNCHFAILED V0041StepState = "LAUNCH_FAILED"
	V0041StepStateNODEFAIL     V0041StepState = "NODE_FAIL"
	V0041StepStateOUTOFMEMORY  V0041StepState = "OUT_OF_MEMORY"
	V0041StepStatePENDING      V0041StepState = "PENDING"
	V0041StepStatePOWERUPNODE  V0041StepState = "POWER_UP_NODE"
	V0041StepStatePREEMPTED    V0041StepState = "PREEMPTED"
	V0041StepStateRECONFIGFAIL V0041StepState = "RECONFIG_FAIL"
	V0041StepStateREQUEUED     V0041StepState = "REQUEUED"
	V0041StepStateREQUEUEFED   V0041StepState = "REQUEUE_FED"
	V0041StepStateREQUEUEHOLD  V0041StepState = "REQUEUE_HOLD"
	V0041StepStateRESIZING     V0041StepState = "RESIZING"
	V0041StepStateRESVDELHOLD  V0041StepState = "RESV_DEL_HOLD"
	V0041StepStateREVOKED      V0041StepState = "REVOKED"
	V0041StepStateRUNNING      V0041StepState = "RUNNING"
	V0041StepStateSIGNALING    V0041StepState = "SIGNALING"
	V0041StepStateSPECIALEXIT  V0041StepState = "SPECIAL_EXIT"
	V0041StepStateSTAGEOUT     V0041StepState = "STAGE_OUT"
	V0041StepStateSTOPPED      V0041StepState = "STOPPED"
	V0041StepStateSUSPENDED    V0041StepState = "SUSPENDED"
	V0041StepStateTIMEOUT      V0041StepState = "TIMEOUT"
	V0041StepStateUPDATEDB     V0041StepState = "UPDATE_DB"
)

// Defines values for V0041UpdateNodeMsgState.
const (
	V0041UpdateNodeMsgStateALLOCATED       V0041UpdateNodeMsgState = "ALLOCATED"
	V0041UpdateNodeMsgStateCLOUD           V0041UpdateNodeMsgState = "CLOUD"
	V0041UpdateNodeMsgStateCOMPLETING      V0041UpdateNodeMsgState = "COMPLETING"
	V0041UpdateNodeMsgStateDOWN            V0041UpdateNodeMsgState = "DOWN"
	V0041UpdateNodeMsgStateDRAIN           V0041UpdateNodeMsgState = "DRAIN"
	V0041UpdateNodeMsgStateDYNAMICFUTURE   V0041UpdateNodeMsgState = "DYNAMIC_FUTURE"
	V0041UpdateNodeMsgStateDYNAMICNORM     V0041UpdateNodeMsgState = "DYNAMIC_NORM"
	V0041UpdateNodeMsgStateERROR           V0041UpdateNodeMsgState = "ERROR"
	V0041UpdateNodeMsgStateFAIL            V0041UpdateNodeMsgState = "FAIL"
	V0041UpdateNodeMsgStateFUTURE          V0041UpdateNodeMsgState = "FUTURE"
	V0041UpdateNodeMsgStateIDLE            V0041UpdateNodeMsgState = "IDLE"
	V0041UpdateNodeMsgStateINVALID         V0041UpdateNodeMsgState = "INVALID"
	V0041UpdateNodeMsgStateINVALIDREG      V0041UpdateNodeMsgState = "INVALID_REG"
	V0041UpdateNodeMsgStateMAINTENANCE     V0041UpdateNodeMsgState = "MAINTENANCE"
	V0041UpdateNodeMsgStateMIXED           V0041UpdateNodeMsgState = "MIXED"
	V0041UpdateNodeMsgStateNOTRESPONDING   V0041UpdateNodeMsgState = "NOT_RESPONDING"
	V0041UpdateNodeMsgStatePLANNED         V0041UpdateNodeMsgState = "PLANNED"
	V0041UpdateNodeMsgStatePOWERDOWN       V0041UpdateNodeMsgState = "POWER_DOWN"
	V0041UpdateNodeMsgStatePOWERDRAIN      V0041UpdateNodeMsgState = "POWER_DRAIN"
	V0041UpdateNodeMsgStatePOWEREDDOWN     V0041UpdateNodeMsgState = "POWERED_DOWN"
	V0041UpdateNodeMsgStatePOWERINGDOWN    V0041UpdateNodeMsgState = "POWERING_DOWN"
	V0041UpdateNodeMsgStatePOWERINGUP      V0041UpdateNodeMsgState = "POWERING_UP"
	V0041UpdateNodeMsgStatePOWERUP         V0041UpdateNodeMsgState = "POWER_UP"
	V0041UpdateNodeMsgStateREBOOTCANCELED  V0041UpdateNodeMsgState = "REBOOT_CANCELED"
	V0041UpdateNodeMsgStateREBOOTISSUED    V0041UpdateNodeMsgState = "REBOOT_ISSUED"
	V0041UpdateNodeMsgStateREBOOTREQUESTED V0041UpdateNodeMsgState = "REBOOT_REQUESTED"
	V0041UpdateNodeMsgStateRESERVED        V0041UpdateNodeMsgState = "RESERVED"
	V0041UpdateNodeMsgStateRESUME          V0041UpdateNodeMsgState = "RESUME"
	V0041UpdateNodeMsgStateUNDRAIN         V0041UpdateNodeMsgState = "UNDRAIN"
	V0041UpdateNodeMsgStateUNKNOWN         V0041UpdateNodeMsgState = "UNKNOWN"
)

// Defines values for V0041UserAdministratorLevel.
const (
	V0041UserAdministratorLevelAdministrator V0041UserAdministratorLevel = "Administrator"
	V0041UserAdministratorLevelNone          V0041UserAdministratorLevel = "None"
	V0041UserAdministratorLevelNotSet        V0041UserAdministratorLevel = "Not Set"
	V0041UserAdministratorLevelOperator      V0041UserAdministratorLevel = "Operator"
)

// Defines values for V0041UserFlags.
const (
	V0041UserFlagsDELETED V0041UserFlags = "DELETED"
	V0041UserFlagsNONE    V0041UserFlags = "NONE"
)

// Defines values for V0041UserShortAdminlevel.
const (
	V0041UserShortAdminlevelAdministrator V0041UserShortAdminlevel = "Administrator"
	V0041UserShortAdminlevelNone          V0041UserShortAdminlevel = "None"
	V0041UserShortAdminlevelNotSet        V0041UserShortAdminlevel = "Not Set"
	V0041UserShortAdminlevelOperator      V0041UserShortAdminlevel = "Operator"
)

// Defines values for V0041WckeyFlags.
const (
	V0041WckeyFlagsDELETED V0041WckeyFlags = "DELETED"
)

// Defines values for V0041WckeyTagStructFlags.
const (
	ASSIGNEDDEFAULT V0041WckeyTagStructFlags = "ASSIGNED_DEFAULT"
)

// Defines values for SlurmV0041DeleteJobParamsFlags.
const (
	ARRAYTASK         SlurmV0041DeleteJobParamsFlags = "ARRAY_TASK"
	BATCHJOB          SlurmV0041DeleteJobParamsFlags = "BATCH_JOB"
	CRONJOBS          SlurmV0041DeleteJobParamsFlags = "CRON_JOBS"
	FEDERATIONREQUEUE SlurmV0041DeleteJobParamsFlags = "FEDERATION_REQUEUE"
	FULLJOB           SlurmV0041DeleteJobParamsFlags = "FULL_JOB"
	FULLSTEPSONLY     SlurmV0041DeleteJobParamsFlags = "FULL_STEPS_ONLY"
	HURRY             SlurmV0041DeleteJobParamsFlags = "HURRY"
	NOSIBLINGJOBS     SlurmV0041DeleteJobParamsFlags = "NO_SIBLING_JOBS"
	OUTOFMEMORY       SlurmV0041DeleteJobParamsFlags = "OUT_OF_MEMORY"
	RESERVATIONJOB    SlurmV0041DeleteJobParamsFlags = "RESERVATION_JOB"
	VERBOSE           SlurmV0041DeleteJobParamsFlags = "VERBOSE"
	WARNINGSENT       SlurmV0041DeleteJobParamsFlags = "WARNING_SENT"
)

// Defines values for SlurmV0041GetJobParamsFlags.
const (
	SlurmV0041GetJobParamsFlagsALL        SlurmV0041GetJobParamsFlags = "ALL"
	SlurmV0041GetJobParamsFlagsDETAIL     SlurmV0041GetJobParamsFlags = "DETAIL"
	SlurmV0041GetJobParamsFlagsFEDERATION SlurmV0041GetJobParamsFlags = "FEDERATION"
	SlurmV0041GetJobParamsFlagsFUTURE     SlurmV0041GetJobParamsFlags = "FUTURE"
	SlurmV0041GetJobParamsFlagsLOCAL      SlurmV0041GetJobParamsFlags = "LOCAL"
	SlurmV0041GetJobParamsFlagsMIXED      SlurmV0041GetJobParamsFlags = "MIXED"
	SlurmV0041GetJobParamsFlagsSIBLING    SlurmV0041GetJobParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetJobsParamsFlags.
const (
	SlurmV0041GetJobsParamsFlagsALL        SlurmV0041GetJobsParamsFlags = "ALL"
	SlurmV0041GetJobsParamsFlagsDETAIL     SlurmV0041GetJobsParamsFlags = "DETAIL"
	SlurmV0041GetJobsParamsFlagsFEDERATION SlurmV0041GetJobsParamsFlags = "FEDERATION"
	SlurmV0041GetJobsParamsFlagsFUTURE     SlurmV0041GetJobsParamsFlags = "FUTURE"
	SlurmV0041GetJobsParamsFlagsLOCAL      SlurmV0041GetJobsParamsFlags = "LOCAL"
	SlurmV0041GetJobsParamsFlagsMIXED      SlurmV0041GetJobsParamsFlags = "MIXED"
	SlurmV0041GetJobsParamsFlagsSIBLING    SlurmV0041GetJobsParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetJobsStateParamsFlags.
const (
	SlurmV0041GetJobsStateParamsFlagsALL        SlurmV0041GetJobsStateParamsFlags = "ALL"
	SlurmV0041GetJobsStateParamsFlagsDETAIL     SlurmV0041GetJobsStateParamsFlags = "DETAIL"
	SlurmV0041GetJobsStateParamsFlagsFEDERATION SlurmV0041GetJobsStateParamsFlags = "FEDERATION"
	SlurmV0041GetJobsStateParamsFlagsFUTURE     SlurmV0041GetJobsStateParamsFlags = "FUTURE"
	SlurmV0041GetJobsStateParamsFlagsLOCAL      SlurmV0041GetJobsStateParamsFlags = "LOCAL"
	SlurmV0041GetJobsStateParamsFlagsMIXED      SlurmV0041GetJobsStateParamsFlags = "MIXED"
	SlurmV0041GetJobsStateParamsFlagsSIBLING    SlurmV0041GetJobsStateParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodeParamsFlags.
const (
	SlurmV0041GetNodeParamsFlagsALL        SlurmV0041GetNodeParamsFlags = "ALL"
	SlurmV0041GetNodeParamsFlagsDETAIL     SlurmV0041GetNodeParamsFlags = "DETAIL"
	SlurmV0041GetNodeParamsFlagsFEDERATION SlurmV0041GetNodeParamsFlags = "FEDERATION"
	SlurmV0041GetNodeParamsFlagsFUTURE     SlurmV0041GetNodeParamsFlags = "FUTURE"
	SlurmV0041GetNodeParamsFlagsLOCAL      SlurmV0041GetNodeParamsFlags = "LOCAL"
	SlurmV0041GetNodeParamsFlagsMIXED      SlurmV0041GetNodeParamsFlags = "MIXED"
	SlurmV0041GetNodeParamsFlagsSIBLING    SlurmV0041GetNodeParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetNodesParamsFlags.
const (
	SlurmV0041GetNodesParamsFlagsALL        SlurmV0041GetNodesParamsFlags = "ALL"
	SlurmV0041GetNodesParamsFlagsDETAIL     SlurmV0041GetNodesParamsFlags = "DETAIL"
	SlurmV0041GetNodesParamsFlagsFEDERATION SlurmV0041GetNodesParamsFlags = "FEDERATION"
	SlurmV0041GetNodesParamsFlagsFUTURE     SlurmV0041GetNodesParamsFlags = "FUTURE"
	SlurmV0041GetNodesParamsFlagsLOCAL      SlurmV0041GetNodesParamsFlags = "LOCAL"
	SlurmV0041GetNodesParamsFlagsMIXED      SlurmV0041GetNodesParamsFlags = "MIXED"
	SlurmV0041GetNodesParamsFlagsSIBLING    SlurmV0041GetNodesParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionParamsFlags.
const (
	SlurmV0041GetPartitionParamsFlagsALL        SlurmV0041GetPartitionParamsFlags = "ALL"
	SlurmV0041GetPartitionParamsFlagsDETAIL     SlurmV0041GetPartitionParamsFlags = "DETAIL"
	SlurmV0041GetPartitionParamsFlagsFEDERATION SlurmV0041GetPartitionParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionParamsFlagsFUTURE     SlurmV0041GetPartitionParamsFlags = "FUTURE"
	SlurmV0041GetPartitionParamsFlagsLOCAL      SlurmV0041GetPartitionParamsFlags = "LOCAL"
	SlurmV0041GetPartitionParamsFlagsMIXED      SlurmV0041GetPartitionParamsFlags = "MIXED"
	SlurmV0041GetPartitionParamsFlagsSIBLING    SlurmV0041GetPartitionParamsFlags = "SIBLING"
)

// Defines values for SlurmV0041GetPartitionsParamsFlags.
const (
	SlurmV0041GetPartitionsParamsFlagsALL        SlurmV0041GetPartitionsParamsFlags = "ALL"
	SlurmV0041GetPartitionsParamsFlagsDETAIL     SlurmV0041GetPartitionsParamsFlags = "DETAIL"
	SlurmV0041GetPartitionsParamsFlagsFEDERATION SlurmV0041GetPartitionsParamsFlags = "FEDERATION"
	SlurmV0041GetPartitionsParamsFlagsFUTURE     SlurmV0041GetPartitionsParamsFlags = "FUTURE"
	SlurmV0041GetPartitionsParamsFlagsLOCAL      SlurmV0041GetPartitionsParamsFlags = "LOCAL"
	SlurmV0041GetPartitionsParamsFlagsMIXED      SlurmV0041GetPartitionsParamsFlags = "MIXED"
	SlurmV0041GetPartitionsParamsFlagsSIBLING    SlurmV0041GetPartitionsParamsFlags = "SIBLING"
)

// Defines values for SlurmdbV0041DeleteClusterParamsClassification.
const (
	SlurmdbV0041DeleteClusterParamsClassificationCAPABILITY                          SlurmdbV0041DeleteClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPACITY                            SlurmdbV0041DeleteClusterParamsClassification = "CAPACITY"
	SlurmdbV0041DeleteClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041DeleteClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041DeleteClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041DeleteClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041DeleteClusterParamsFlags.
const (
	SlurmdbV0041DeleteClusterParamsFlagsEXTERNAL       SlurmdbV0041DeleteClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041DeleteClusterParamsFlagsFEDERATION     SlurmdbV0041DeleteClusterParamsFlags = "FEDERATION"
	SlurmdbV0041DeleteClusterParamsFlagsFRONTEND       SlurmdbV0041DeleteClusterParamsFlags = "FRONT_END"
	SlurmdbV0041DeleteClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041DeleteClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041DeleteClusterParamsFlagsREGISTERING    SlurmdbV0041DeleteClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetClusterParamsClassification.
const (
	SlurmdbV0041GetClusterParamsClassificationCAPABILITY                          SlurmdbV0041GetClusterParamsClassification = "CAPABILITY"
	SlurmdbV0041GetClusterParamsClassificationCAPACITY                            SlurmdbV0041GetClusterParamsClassification = "CAPACITY"
	SlurmdbV0041GetClusterParamsClassificationCAPAPACITYBothCAPABILITYAndCAPACITY SlurmdbV0041GetClusterParamsClassification = "CAPAPACITY (both CAPABILITY and CAPACITY)"
	SlurmdbV0041GetClusterParamsClassificationUNCLASSIFIED                        SlurmdbV0041GetClusterParamsClassification = "UNCLASSIFIED"
)

// Defines values for SlurmdbV0041GetClusterParamsFlags.
const (
	SlurmdbV0041GetClusterParamsFlagsEXTERNAL       SlurmdbV0041GetClusterParamsFlags = "EXTERNAL"
	SlurmdbV0041GetClusterParamsFlagsFEDERATION     SlurmdbV0041GetClusterParamsFlags = "FEDERATION"
	SlurmdbV0041GetClusterParamsFlagsFRONTEND       SlurmdbV0041GetClusterParamsFlags = "FRONT_END"
	SlurmdbV0041GetClusterParamsFlagsMULTIPLESLURMD SlurmdbV0041GetClusterParamsFlags = "MULTIPLE_SLURMD"
	SlurmdbV0041GetClusterParamsFlagsREGISTERING    SlurmdbV0041GetClusterParamsFlags = "REGISTERING"
)

// Defines values for SlurmdbV0041GetQosParamsPreemptMode.
const (
	SlurmdbV0041GetQosParamsPreemptModeCANCEL   SlurmdbV0041GetQosParamsPreemptMode = "CANCEL"
	SlurmdbV0041GetQosParamsPreemptModeDISABLED SlurmdbV0041GetQosParamsPreemptMode = "DISABLED"
	SlurmdbV0041GetQosParamsPreemptModeGANG     SlurmdbV0041GetQosParamsPreemptMode = "GANG"
	SlurmdbV0041GetQosParamsPreemptModeREQUEUE  SlurmdbV0041GetQosParamsPreemptMode = "REQUEUE"
	SlurmdbV0041GetQosParamsPreemptModeSUSPEND  SlurmdbV0041GetQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041PostQosParamsPreemptMode.
const (
	CANCEL   SlurmdbV0041PostQosParamsPreemptMode = "CANCEL"
	DISABLED SlurmdbV0041PostQosParamsPreemptMode = "DISABLED"
	GANG     SlurmdbV0041PostQosParamsPreemptMode = "GANG"
	REQUEUE  SlurmdbV0041PostQosParamsPreemptMode = "REQUEUE"
	SUSPEND  SlurmdbV0041PostQosParamsPreemptMode = "SUSPEND"
)

// Defines values for SlurmdbV0041GetUsersParamsAdminLevel.
const (
	Administrator SlurmdbV0041GetUsersParamsAdminLevel = "Administrator"
	None          SlurmdbV0041GetUsersParamsAdminLevel = "None"
	NotSet        SlurmdbV0041GetUsersParamsAdminLevel = "Not Set"
	Operator      SlurmdbV0041GetUsersParamsAdminLevel = "Operator"
)

// Defines values for SlurmdbV0041PostUsersAssociationParamsFlags.
const (
	SlurmdbV0041PostUsersAssociationParamsFlagsALL        SlurmdbV0041PostUsersAssociationParamsFlags = "ALL"
	SlurmdbV0041PostUsersAssociationParamsFlagsDETAIL     SlurmdbV0041PostUsersAssociationParamsFlags = "DETAIL"
	SlurmdbV0041PostUsersAssociationParamsFlagsFEDERATION SlurmdbV0041PostUsersAssociationParamsFlags = "FEDERATION"
	SlurmdbV0041PostUsersAssociationParamsFlagsFUTURE     SlurmdbV0041PostUsersAssociationParamsFlags = "FUTURE"
	SlurmdbV0041PostUsersAssociationParamsFlagsLOCAL      SlurmdbV0041PostUsersAssociationParamsFlags = "LOCAL"
	SlurmdbV0041PostUsersAssociationParamsFlagsMIXED      SlurmdbV0041PostUsersAssociationParamsFlags = "MIXED"
	SlurmdbV0041PostUsersAssociationParamsFlagsSIBLING    SlurmdbV0041PostUsersAssociationParamsFlags = "SIBLING"
)

// V0041Account defines model for v0.0.41_account.
type V0041Account struct {
	Associations *V0041AssocShortList `json:"associations,omitempty"`
	Coordinators *V0041CoordList      `json:"coordinators,omitempty"`

	// Description Arbitrary string describing the account
	Description string `json:"description"`

	// Flags Flags associated with the account
	Flags *[]V0041AccountFlags `json:"flags,omitempty"`

	// Name Account name
	Name string `json:"name"`

	// Organization Organization to which the account belongs
	Organization string `json:"organization"`
}

// V0041AccountFlags defines model for V0041Account.Flags.
type V0041AccountFlags string

// V0041AccountList defines model for v0.0.41_account_list.
type V0041AccountList = []V0041Account

// V0041AccountShort defines model for v0.0.41_account_short.
type V0041AccountShort struct {
	// Description Arbitrary string describing the account
	Description *string `json:"description,omitempty"`

	// Organization Organization to which the account belongs
	Organization *string `json:"organization,omitempty"`
}

// V0041Accounting defines model for v0.0.41_accounting.
type V0041Accounting struct {
	TRES      *V0041Tres `json:"TRES,omitempty"`
	Allocated *struct {
		// Seconds Number of cpu seconds allocated
		Seconds *int64 `json:"seconds,omitempty"`
	} `json:"allocated,omitempty"`

	// Id Association ID or Workload characterization key ID
	Id *int32 `json:"id,omitempty"`

	// Start When the record was started
	Start *int64 `json:"start,omitempty"`
}

// V0041AccountingList defines model for v0.0.41_accounting_list.
type V0041AccountingList = []V0041Accounting

// V0041AccountsAddCond defines model for v0.0.41_accounts_add_cond.
type V0041AccountsAddCond struct {
	Accounts    V0041StringList   `json:"accounts"`
	Association *V0041AssocRecSet `json:"association,omitempty"`
	Clusters    *V0041StringList  `json:"clusters,omitempty"`
}

// V0041AcctGatherEnergy defines model for v0.0.41_acct_gather_energy.
type V0041AcctGatherEnergy struct {
	// AverageWatts Average power consumption, in watts
	AverageWatts *int32 `json:"average_watts,omitempty"`

	// BaseConsumedEnergy The energy consumed between when the node was powered on and the last time it was registered by slurmd, in joules
	BaseConsumedEnergy *int64 `json:"base_consumed_energy,omitempty"`

	// ConsumedEnergy The energy consumed between the last time the node was registered by the slurmd daemon and the last node energy accounting sample, in joules
	ConsumedEnergy *int64                  `json:"consumed_energy,omitempty"`
	CurrentWatts   *V0041Uint32NoValStruct `json:"current_watts,omitempty"`

	// LastCollected Time when energy data was last retrieved (UNIX timestamp)
	LastCollected *int64 `json:"last_collected,omitempty"`

	// PreviousConsumedEnergy Previous value of consumed_energy
	PreviousConsumedEnergy *int64 `json:"previous_consumed_energy,omitempty"`
}

// V0041Assoc defines model for v0.0.41_assoc.
type V0041Assoc struct {
	// Account Account
	Account    *string              `json:"account,omitempty"`
	Accounting *V0041AccountingList `json:"accounting,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`
	Default *struct {
		// Qos Default QOS
		Qos *string `json:"qos,omitempty"`
	} `json:"default,omitempty"`

	// Flags Flags on the association
	Flags *[]V0041AssocFlags `json:"flags,omitempty"`

	// Id Unique ID
	Id *int32 `json:"id,omitempty"`

	// IsDefault Is default association for user
	IsDefault *bool `json:"is_default,omitempty"`

	// Lineage Complete path up the hierarchy to the root association
	Lineage *string `json:"lineage,omitempty"`
	Max     *struct {
		Jobs *struct {
			Accruing *V0041Uint32NoValStruct `json:"accruing,omitempty"`
			Active   *V0041Uint32NoValStruct `json:"active,omitempty"`
			Per      *struct {
				Accruing  *V0041Uint32NoValStruct `json:"accruing,omitempty"`
				Count     *V0041Uint32NoValStruct `json:"count,omitempty"`
				Submitted *V0041Uint32NoValStruct `json:"submitted,omitempty"`
				WallClock *V0041Uint32NoValStruct `json:"wall_clock,omitempty"`
			} `json:"per,omitempty"`
			Total *V0041Uint32NoValStruct `json:"total,omitempty"`
		} `json:"jobs,omitempty"`
		Per *struct {
			Account *struct {
				WallClock *V0041Uint32NoValStruct `json:"wall_clock,omitempty"`
			} `json:"account,omitempty"`
		} `json:"per,omitempty"`
		Tres *struct {
			Group *struct {
				Active  *V0041TresList `json:"active,omitempty"`
				Minutes *V0041TresList `json:"minutes,omitempty"`
			} `json:"group,omitempty"`
			Minutes *struct {
				Per *struct {
					Job *V0041TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
				Total *V0041TresList `json:"total,omitempty"`
			} `json:"minutes,omitempty"`
			Per *struct {
				Job  *V0041TresList `json:"job,omitempty"`
				Node *V0041TresList `json:"node,omitempty"`
			} `json:"per,omitempty"`
			Total *V0041TresList `json:"total,omitempty"`
		} `json:"tres,omitempty"`
	} `json:"max,omitempty"`
	Min *struct {
		PriorityThreshold *V0041Uint32NoValStruct `json:"priority_threshold,omitempty"`
	} `json:"min,omitempty"`

	// ParentAccount Name of parent account
	ParentAccount *string `json:"parent_account,omitempty"`

	// Partition Partition name
	Partition *string                 `json:"partition,omitempty"`
	Priority  *V0041Uint32NoValStruct `json:"priority,omitempty"`

	// Qos List of QOS names
	Qos *V0041QosStringIdList `json:"qos,omitempty"`

	// SharesRaw Allocated shares used for fairshare calculation
	SharesRaw *int32 `json:"shares_raw,omitempty"`

	// User User name
	User string `json:"user"`
}

// V0041AssocFlags defines model for V0041Assoc.Flags.
type V0041AssocFlags string

// V0041AssocList defines model for v0.0.41_assoc_list.
type V0041AssocList = []V0041Assoc

// V0041AssocRecSet defines model for v0.0.41_assoc_rec_set.
type V0041AssocRecSet struct {
	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Defaultqos Default QOS
	Defaultqos *string `json:"defaultqos,omitempty"`

	// Fairshare Allocated shares used for fairshare calculation
	Fairshare             *int32                  `json:"fairshare,omitempty"`
	Grpjobs               *V0041Uint32NoValStruct `json:"grpjobs,omitempty"`
	Grpjobsaccrue         *V0041Uint32NoValStruct `json:"grpjobsaccrue,omitempty"`
	Grpsubmitjobs         *V0041Uint32NoValStruct `json:"grpsubmitjobs,omitempty"`
	Grptres               *V0041TresList          `json:"grptres,omitempty"`
	Grptresmins           *V0041TresList          `json:"grptresmins,omitempty"`
	Grptresrunmins        *V0041TresList          `json:"grptresrunmins,omitempty"`
	Grpwall               *V0041Uint32NoValStruct `json:"grpwall,omitempty"`
	Maxjobs               *V0041Uint32NoValStruct `json:"maxjobs,omitempty"`
	Maxjobsaccrue         *V0041Uint32NoValStruct `json:"maxjobsaccrue,omitempty"`
	Maxsubmitjobs         *V0041Uint32NoValStruct `json:"maxsubmitjobs,omitempty"`
	Maxtresminsperjob     *V0041TresList          `json:"maxtresminsperjob,omitempty"`
	Maxtresperjob         *V0041TresList          `json:"maxtresperjob,omitempty"`
	Maxtrespernode        *V0041TresList          `json:"maxtrespernode,omitempty"`
	Maxtresrunmins        *V0041TresList          `json:"maxtresrunmins,omitempty"`
	Maxwalldurationperjob *V0041Uint32NoValStruct `json:"maxwalldurationperjob,omitempty"`
	Minpriothresh         *V0041Uint32NoValStruct `json:"minpriothresh,omitempty"`

	// Parent Name of parent account
	Parent   *string                 `json:"parent,omitempty"`
	Priority *V0041Uint32NoValStruct `json:"priority,omitempty"`

	// Qoslevel List of QOS names
	Qoslevel *V0041QosStringIdList `json:"qoslevel,omitempty"`
}

// V0041AssocSharesObjList defines model for v0.0.41_assoc_shares_obj_list.
type V0041AssocSharesObjList = []V0041AssocSharesObjWrap

// V0041AssocSharesObjWrap defines model for v0.0.41_assoc_shares_obj_wrap.
type V0041AssocSharesObjWrap struct {
	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// EffectiveUsage Effective, normalized usage
	EffectiveUsage *float64 `json:"effective_usage,omitempty"`
	Fairshare      *struct {
		// Factor Fairshare factor
		Factor *float64 `json:"factor,omitempty"`

		// Level Fairshare factor at this level; stored on an assoc as a long double, but that is not needed for display in sshare
		Level *float64 `json:"level,omitempty"`
	} `json:"fairshare,omitempty"`

	// Id Association ID
	Id *int32 `json:"id,omitempty"`

	// Name Share name
	Name *string `json:"name,omitempty"`

	// Parent Parent name
	Parent *string `json:"parent,omitempty"`

	// Partition Partition name
	Partition        *string                  `json:"partition,omitempty"`
	Shares           *V0041Uint32NoValStruct  `json:"shares,omitempty"`
	SharesNormalized *V0041Float64NoValStruct `json:"shares_normalized,omitempty"`
	Tres             *struct {
		GroupMinutes *V0041SharesUint64TresList   `json:"group_minutes,omitempty"`
		RunSeconds   *V0041SharesUint64TresList   `json:"run_seconds,omitempty"`
		Usage        *V0041SharesFloat128TresList `json:"usage,omitempty"`
	} `json:"tres,omitempty"`

	// Type User or account association
	Type *[]V0041AssocSharesObjWrapType `json:"type,omitempty"`

	// Usage Measure of tresbillableunits usage
	Usage           *int64                   `json:"usage,omitempty"`
	UsageNormalized *V0041Float64NoValStruct `json:"usage_normalized,omitempty"`
}

// V0041AssocSharesObjWrapType defines model for V0041AssocSharesObjWrap.Type.
type V0041AssocSharesObjWrapType string

// V0041AssocShort defines model for v0.0.41_assoc_short.
type V0041AssocShort struct {
	// Account Account
	Account *string `json:"account,omitempty"`

	// Cluster Cluster
	Cluster *string `json:"cluster,omitempty"`

	// Id Numeric association ID
	Id *int32 `json:"id,omitempty"`

	// Partition Partition
	Partition *string `json:"partition,omitempty"`

	// User User name
	User string `json:"user"`
}

// V0041AssocShortList defines model for v0.0.41_assoc_short_list.
type V0041AssocShortList = []V0041AssocShort

// V0041BfExitFields defines model for v0.0.41_bf_exit_fields.
type V0041BfExitFields struct {
	// BfMaxJobStart Reached number of jobs allowed to start
	BfMaxJobStart *int32 `json:"bf_max_job_start,omitempty"`

	// BfMaxJobTest Reached number of jobs allowed to be tested
	BfMaxJobTest *int32 `json:"bf_max_job_test,omitempty"`

	// BfMaxTime Reached maximum allowed scheduler time
	BfMaxTime *int32 `json:"bf_max_time,omitempty"`

	// BfNodeSpaceSize Reached table size limit
	BfNodeSpaceSize *int32 `json:"bf_node_space_size,omitempty"`

	// EndJobQueue Reached end of queue
	EndJobQueue *int32 `json:"end_job_queue,omitempty"`

	// StateChanged System state changed
	StateChanged *int32 `json:"state_changed,omitempty"`
}

// V0041ClusterRec defines model for v0.0.41_cluster_rec.
type V0041ClusterRec struct {
	Associations *struct {
		Root *V0041AssocShort `json:"root,omitempty"`
	} `json:"associations,omitempty"`
	Controller *struct {
		// Host ControlHost
		Host *string `json:"host,omitempty"`

		// Port ControlPort
		Port *int32 `json:"port,omitempty"`
	} `json:"controller,omitempty"`

	// Flags Flags
	Flags *[]V0041ClusterRecFlags `json:"flags,omitempty"`

	// Name ClusterName
	Name *string `json:"name,omitempty"`

	// Nodes Node names
	Nodes *string `json:"nodes,omitempty"`

	// RpcVersion RPC version used in the cluster
	RpcVersion *int32 `json:"rpc_version,omitempty"`
	// Deprecated:
	SelectPlugin *string        `json:"select_plugin,omitempty"`
	Tres         *V0041TresList `json:"tres,omitempty"`
}

// V0041ClusterRecFlags defines model for V0041ClusterRec.Flags.
type V0041ClusterRecFlags string

// V0041ClusterRecList defines model for v0.0.41_cluster_rec_list.
type V0041ClusterRecList = []V0041ClusterRec

// V0041ControllerPing defines model for v0.0.41_controller_ping.
type V0041ControllerPing struct {
	// Hostname Target for ping
	Hostname *string `json:"hostname,omitempty"`

	// Latency Number of microseconds it took to successfully ping or timeout
	Latency *int64 `json:"latency,omitempty"`

	// Mode The operating mode of the responding slurmctld
	Mode *string `json:"mode,omitempty"`

	// Pinged Ping result
	Pinged *string `json:"pinged,omitempty"`
}

// V0041ControllerPingArray defines model for v0.0.41_controller_ping_array.
type V0041ControllerPingArray = []V0041ControllerPing

// V0041Coord defines model for v0.0.41_coord.
type V0041Coord struct {
	// Direct Indicates whether the coordinator was directly assigned to this account
	Direct *bool `json:"direct,omitempty"`

	// Name User name
	Name string `json:"name"`
}

// V0041CoordList defines model for v0.0.41_coord_list.
type V0041CoordList = []V0041Coord

// V0041CronEntry defines model for v0.0.41_cron_entry.
type V0041CronEntry struct {
	// Command Command to run
	Command *string `json:"command,omitempty"`

	// DayOfMonth Ranged string specifying eligible day of month values (e.g. 0-10,29)
	DayOfMonth *string `json:"day_of_month,omitempty"`

	// DayOfWeek Ranged string specifying eligible day of week values (e.g.0-3,7)
	DayOfWeek *string `json:"day_of_week,omitempty"`

	// Flags Flags
	Flags *[]V0041CronEntryFlags `json:"flags,omitempty"`

	// Hour Ranged string specifying eligible hour values (e.g. 0-5,23)
	Hour *string `json:"hour,omitempty"`
	Line *struct {
		// End End of this entry in file
		End *int32 `json:"end,omitempty"`

		// Start Start of this entry in file
		Start *int32 `json:"start,omitempty"`
	} `json:"line,omitempty"`

	// Minute Ranged string specifying eligible minute values (e.g. 0-10,50)
	Minute *string `json:"minute,omitempty"`

	// Month Ranged string specifying eligible month values (e.g. 0-5,12)
	Month *string `json:"month,omitempty"`

	// Specification Time specification (* means valid for all allowed values) - minute hour day_of_month month day_of_week
	Specification *string `json:"specification,omitempty"`
}

// V0041CronEntryFlags defines model for V0041CronEntry.Flags.
type V0041CronEntryFlags string

// V0041CsvString defines model for v0.0.41_csv_string.
type V0041CsvString = []string

// V0041Float64NoValStruct defines model for v0.0.41_float64_no_val_struct.
type V0041Float64NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *float64 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0041Hostlist defines model for v0.0.41_hostlist.
type V0041Hostlist = []string

// V0041HostlistString defines model for v0.0.41_hostlist_string.
type V0041HostlistString = []string

// V0041Instance defines model for v0.0.41_instance.
type V0041Instance struct {
	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// InstanceId Cloud instance ID
	InstanceId *string `json:"instance_id,omitempty"`

	// InstanceType Cloud instance type
	InstanceType *string `json:"instance_type,omitempty"`

	// NodeName NodeName
	NodeName *string `json:"node_name,omitempty"`
	Time     *struct {
		// TimeEnd When the instance will end (UNIX timestamp)
		TimeEnd *int64 `json:"time_end,omitempty"`

		// TimeStart When the instance will start (UNIX timestamp)
		TimeStart *int64 `json:"time_start,omitempty"`
	} `json:"time,omitempty"`
}

// V0041InstanceList defines model for v0.0.41_instance_list.
type V0041InstanceList = []V0041Instance

// V0041Job defines model for v0.0.41_job.
type V0041Job struct {
	// Account Account the job ran under
	Account *string `json:"account,omitempty"`

	// AllocationNodes List of nodes allocated to the job
	AllocationNodes *int32 `json:"allocation_nodes,omitempty"`
	Array           *struct {
		// JobId Job ID of job array, or 0 if N/A
		JobId  *int32 `json:"job_id,omitempty"`
		Limits *struct {
			Max *struct {
				Running *struct {
					// Tasks Maximum number of simultaneously running tasks, 0 if no limit
					Tasks *int32 `json:"tasks,omitempty"`
				} `json:"running,omitempty"`
			} `json:"max,omitempty"`
		} `json:"limits,omitempty"`

		// Task String expression of task IDs in this record
		Task   *string                 `json:"task,omitempty"`
		TaskId *V0041Uint32NoValStruct `json:"task_id,omitempty"`
	} `json:"array,omitempty"`
	Association *V0041AssocShort `json:"association,omitempty"`

	// Block The name of the block to be used (used with Blue Gene systems)
	Block *string `json:"block,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`
	Comment *struct {
		// Administrator Arbitrary comment made by administrator
		Administrator *string `json:"administrator,omitempty"`

		// Job Arbitrary comment made by user
		Job *string `json:"job,omitempty"`

		// System Arbitrary comment from slurmctld
		System *string `json:"system,omitempty"`
	} `json:"comment,omitempty"`

	// Constraints Feature(s) the job requested as a constraint
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container       *string                      `json:"container,omitempty"`
	DerivedExitCode *V0041ProcessExitCodeVerbose `json:"derived_exit_code,omitempty"`
	ExitCode        *V0041ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// FailedNode Name of node that caused job failure
	FailedNode *string `json:"failed_node,omitempty"`

	// Flags Flags associated with the job
	Flags *[]V0041JobFlags `json:"flags,omitempty"`

	// Group Group ID of the user that owns the job
	Group *string `json:"group,omitempty"`
	Het   *struct {
		// JobId Heterogeneous job ID, if applicable
		JobId     *int32                  `json:"job_id,omitempty"`
		JobOffset *V0041Uint32NoValStruct `json:"job_offset,omitempty"`
	} `json:"het,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillRequestUser User ID that requested termination of the job
	KillRequestUser *string `json:"kill_request_user,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`
	Mcs      *struct {
		// Label Multi-Category Security label on the job
		Label *string `json:"label,omitempty"`
	} `json:"mcs,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Nodes Node(s) allocated to the job
	Nodes *string `json:"nodes,omitempty"`

	// Partition Partition assigned to the job
	Partition *string                 `json:"partition,omitempty"`
	Priority  *V0041Uint32NoValStruct `json:"priority,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos      *string `json:"qos,omitempty"`
	Required *struct {
		// CPUs Minimum number of CPUs required
		CPUs          *int32                  `json:"CPUs,omitempty"`
		MemoryPerCpu  *V0041Uint64NoValStruct `json:"memory_per_cpu,omitempty"`
		MemoryPerNode *V0041Uint64NoValStruct `json:"memory_per_node,omitempty"`
	} `json:"required,omitempty"`
	Reservation *struct {
		// Id Unique identifier of requested reservation
		Id *int32 `json:"id,omitempty"`

		// Name Name of reservation to use
		Name *string `json:"name,omitempty"`
	} `json:"reservation,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script *string `json:"script,omitempty"`
	State  *struct {
		// Current Current state
		Current *[]V0041JobStateCurrent `json:"current,omitempty"`

		// Reason Reason for previous Pending or Failed state
		Reason *string `json:"reason,omitempty"`
	} `json:"state,omitempty"`

	// Stderr Path to stderr file
	Stderr *string `json:"stderr,omitempty"`

	// StderrExpanded Job stderr with expanded fields
	StderrExpanded *string `json:"stderr_expanded,omitempty"`

	// Stdin Path to stdin file
	Stdin *string `json:"stdin,omitempty"`

	// StdinExpanded Job stdin with expanded fields
	StdinExpanded *string `json:"stdin_expanded,omitempty"`

	// Stdout Path to stdout file
	Stdout *string `json:"stdout,omitempty"`

	// StdoutExpanded Job stdout with expanded fields
	StdoutExpanded *string        `json:"stdout_expanded,omitempty"`
	Steps          *V0041StepList `json:"steps,omitempty"`

	// SubmitLine Command used to submit the job
	SubmitLine *string `json:"submit_line,omitempty"`
	Time       *struct {
		// Elapsed Elapsed time in seconds
		Elapsed *int32 `json:"elapsed,omitempty"`

		// Eligible Time when the job became eligible to run (UNIX timestamp)
		Eligible *int64 `json:"eligible,omitempty"`

		// End End time (UNIX timestamp)
		End     *int64                  `json:"end,omitempty"`
		Limit   *V0041Uint32NoValStruct `json:"limit,omitempty"`
		Planned *V0041Uint64NoValStruct `json:"planned,omitempty"`

		// Start Time execution began (UNIX timestamp)
		Start *int64 `json:"start,omitempty"`

		// Submission Time when the job was submitted (UNIX timestamp)
		Submission *int64 `json:"submission,omitempty"`

		// Suspended Total time in suspended state in seconds
		Suspended *int32 `json:"suspended,omitempty"`
		System    *struct {
			// Microseconds System CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds System CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"system,omitempty"`
		Total *struct {
			// Microseconds Sum of System and User CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds Sum of System and User CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"total,omitempty"`
		User *struct {
			// Microseconds User CPU time used by the job in microseconds
			Microseconds *int64 `json:"microseconds,omitempty"`

			// Seconds User CPU time used by the job in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`
	Tres *struct {
		Allocated *V0041TresList `json:"allocated,omitempty"`
		Requested *V0041TresList `json:"requested,omitempty"`
	} `json:"tres,omitempty"`

	// UsedGres Generic resources used by job
	UsedGres *string `json:"used_gres,omitempty"`

	// User User that owns the job
	User  *string              `json:"user,omitempty"`
	Wckey *V0041WckeyTagStruct `json:"wckey,omitempty"`

	// WorkingDirectory Path to current working directory
	WorkingDirectory *string `json:"working_directory,omitempty"`
}

// V0041JobFlags defines model for V0041Job.Flags.
type V0041JobFlags string

// V0041JobStateCurrent defines model for V0041Job.State.Current.
type V0041JobStateCurrent string

// V0041JobAllocReq defines model for v0.0.41_job_alloc_req.
type V0041JobAllocReq struct {
	Hetjob *V0041JobDescMsgList `json:"hetjob,omitempty"`
	Job    *V0041JobDescMsg     `json:"job,omitempty"`
}

// V0041JobArrayResponseArray defines model for v0.0.41_job_array_response_array.
type V0041JobArrayResponseArray = []V0041JobArrayResponseMsgEntry

// V0041JobArrayResponseMsgEntry defines model for v0.0.41_job_array_response_msg_entry.
type V0041JobArrayResponseMsgEntry struct {
	// Error Verbose update status or error
	Error *string `json:"error,omitempty"`

	// ErrorCode Verbose update status or error
	ErrorCode *int32 `json:"error_code,omitempty"`

	// JobId Job ID for updated job
	JobId *int32 `json:"job_id,omitempty"`

	// StepId Step ID for updated job
	StepId *string `json:"step_id,omitempty"`

	// Why Update response message
	Why *string `json:"why,omitempty"`
}

// V0041JobDescMsg defines model for v0.0.41_job_desc_msg.
type V0041JobDescMsg struct {
	// Account Account associated with the job
	Account *string `json:"account,omitempty"`

	// AccountGatherFrequency Job accounting and profiling sampling intervals in seconds
	AccountGatherFrequency *string `json:"account_gather_frequency,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocationNodeList Local node making the resource allocation
	AllocationNodeList *string `json:"allocation_node_list,omitempty"`

	// AllocationNodePort Port to send allocation confirmation to
	AllocationNodePort *int32            `json:"allocation_node_port,omitempty"`
	Argv               *V0041StringArray `json:"argv,omitempty"`

	// Array Job array index value specification
	Array *string `json:"array,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string                 `json:"batch_features,omitempty"`
	BeginTime     *V0041Uint64NoValStruct `json:"begin_time,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// ClusterConstraint Required features that a federated cluster must have to have a sibling job submitted to it
	ClusterConstraint *string `json:"cluster_constraint,omitempty"`

	// Clusters Clusters that a federated job can run on
	Clusters *string `json:"clusters,omitempty"`

	// Comment Arbitrary comment made by user
	Comment *string `json:"comment,omitempty"`

	// Constraints Comma separated list of features that are required
	Constraints *string `json:"constraints,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpecification Specialized core count
	CoreSpecification *int32 `json:"core_specification,omitempty"`

	// CpuBinding Method for binding tasks to allocated CPUs
	CpuBinding *string `json:"cpu_binding,omitempty"`

	// CpuBindingFlags Flags for CPU binding
	CpuBindingFlags *[]V0041JobDescMsgCpuBindingFlags `json:"cpu_binding_flags,omitempty"`

	// CpuFrequency Requested CPU frequency range <p1>[-p2][:p3]
	CpuFrequency *string `json:"cpu_frequency,omitempty"`

	// CpusPerTask Number of CPUs required by each task
	CpusPerTask *int32 `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string         `json:"cpus_per_tres,omitempty"`
	Crontab     *V0041CronEntry `json:"crontab,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string `json:"current_working_directory,omitempty"`

	// Deadline Latest time that the job may start (UNIX timestamp)
	Deadline *int64 `json:"deadline,omitempty"`

	// DelayBoot Number of seconds after job eligible start that nodes will be rebooted to satisfy feature specification
	DelayBoot *int32 `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency *string `json:"dependency,omitempty"`

	// Distribution Layout
	Distribution          *string                 `json:"distribution,omitempty"`
	DistributionPlaneSize *V0041Uint16NoValStruct `json:"distribution_plane_size,omitempty"`

	// EndTime Expected end time (UNIX timestamp)
	EndTime       *int64            `json:"end_time,omitempty"`
	Environment   *V0041StringArray `json:"environment,omitempty"`
	ExcludedNodes *V0041CsvString   `json:"excluded_nodes,omitempty"`
	// Deprecated:
	Exclusive *[]V0041JobDescMsgExclusive `json:"exclusive,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// Flags Job flags
	Flags *[]V0041JobDescMsgFlags `json:"flags,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *string `json:"group_id,omitempty"`

	// HetjobGroup Unique sequence number applied to this component of the heterogeneous job
	HetjobGroup *int32 `json:"hetjob_group,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// Immediate If true, exit if resources are not available within the time period specified
	Immediate *bool `json:"immediate,omitempty"`

	// JobId Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// KillOnNodeFail If true, kill job on node failure
	KillOnNodeFail   *bool                   `json:"kill_on_node_fail,omitempty"`
	KillWarningDelay *V0041Uint16NoValStruct `json:"kill_warning_delay,omitempty"`

	// KillWarningFlags Flags related to job signals
	KillWarningFlags *[]V0041JobDescMsgKillWarningFlags `json:"kill_warning_flags,omitempty"`

	// KillWarningSignal Signal to send when approaching end time (e.g. "10" or "USR1")
	KillWarningSignal *string `json:"kill_warning_signal,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]V0041JobDescMsgMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string `json:"mail_user,omitempty"`

	// MaximumCpus Maximum number of CPUs required
	MaximumCpus *int32 `json:"maximum_cpus,omitempty"`

	// MaximumNodes Maximum node count
	MaximumNodes *int32 `json:"maximum_nodes,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel *string `json:"mcs_label,omitempty"`

	// MemoryBinding Binding map for map/mask_cpu
	MemoryBinding *string `json:"memory_binding,omitempty"`

	// MemoryBindingType Method for binding tasks to memory
	MemoryBindingType *[]V0041JobDescMsgMemoryBindingType `json:"memory_binding_type,omitempty"`
	MemoryPerCpu      *V0041Uint64NoValStruct             `json:"memory_per_cpu,omitempty"`
	MemoryPerNode     *V0041Uint64NoValStruct             `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres *string `json:"memory_per_tres,omitempty"`

	// MinimumBoardsPerNode Boards per node required
	MinimumBoardsPerNode *int32 `json:"minimum_boards_per_node,omitempty"`

	// MinimumCpus Minimum number of CPUs required
	MinimumCpus *int32 `json:"minimum_cpus,omitempty"`

	// MinimumCpusPerNode Minimum number of CPUs per node
	MinimumCpusPerNode *int32 `json:"minimum_cpus_per_node,omitempty"`

	// MinimumNodes Minimum node count
	MinimumNodes *int32 `json:"minimum_nodes,omitempty"`

	// MinimumSocketsPerBoard Sockets per board required
	MinimumSocketsPerBoard *int32 `json:"minimum_sockets_per_board,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for job step
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice *int32 `json:"nice,omitempty"`

	// Nodes Node count range specification (e.g. 1-15:4)
	Nodes *string `json:"nodes,omitempty"`

	// NtasksPerTres Number of tasks that can access each GPU
	NtasksPerTres *int32 `json:"ntasks_per_tres,omitempty"`

	// OpenMode Open mode used for stdout and stderr files
	OpenMode *[]V0041JobDescMsgOpenMode `json:"open_mode,omitempty"`

	// Overcommit Overcommit resources
	Overcommit *bool `json:"overcommit,omitempty"`
	// Deprecated:
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	// Deprecated:
	PowerFlags *[]interface{} `json:"power_flags,omitempty"`

	// Prefer Comma separated list of features that are preferred but not required
	Prefer   *string                 `json:"prefer,omitempty"`
	Priority *V0041Uint32NoValStruct `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]V0041JobDescMsgProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue          *bool                   `json:"requeue,omitempty"`
	RequiredNodes    *V0041CsvString         `json:"required_nodes,omitempty"`
	RequiredSwitches *V0041Uint32NoValStruct `json:"required_switches,omitempty"`

	// Reservation Name of reservation to use
	Reservation *string `json:"reservation,omitempty"`

	// ReservePorts Port to send various notification msg to
	ReservePorts *int32 `json:"reserve_ports,omitempty"`

	// ResvMpiPorts Number of reserved communication ports; can only be used if slurmstepd step manager is enabled
	ResvMpiPorts *int32 `json:"resv_mpi_ports,omitempty"`
	Rlimits      *struct {
		As      *V0041Uint64NoValStruct `json:"as,omitempty"`
		Core    *V0041Uint64NoValStruct `json:"core,omitempty"`
		Cpu     *V0041Uint64NoValStruct `json:"cpu,omitempty"`
		Data    *V0041Uint64NoValStruct `json:"data,omitempty"`
		Fsize   *V0041Uint64NoValStruct `json:"fsize,omitempty"`
		Memlock *V0041Uint64NoValStruct `json:"memlock,omitempty"`
		Nofile  *V0041Uint64NoValStruct `json:"nofile,omitempty"`
		Nproc   *V0041Uint64NoValStruct `json:"nproc,omitempty"`
		Rss     *V0041Uint64NoValStruct `json:"rss,omitempty"`
		Stack   *V0041Uint64NoValStruct `json:"stack,omitempty"`
	} `json:"rlimits,omitempty"`

	// Script Job batch script; only the first component in a HetJob is populated or honored
	Script      *string                 `json:"script,omitempty"`
	SegmentSize *V0041Uint16NoValStruct `json:"segment_size,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]V0041JobDescMsgShared `json:"shared,omitempty"`

	// SiteFactor Site-specific priority factor
	SiteFactor *int32 `json:"site_factor,omitempty"`

	// SocketsPerNode Sockets per node required
	SocketsPerNode   *int32            `json:"sockets_per_node,omitempty"`
	SpankEnvironment *V0041StringArray `json:"spank_environment,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string `json:"standard_output,omitempty"`

	// Tasks Number of tasks
	Tasks *int32 `json:"tasks,omitempty"`

	// TasksPerBoard Number of tasks to invoke on each board
	TasksPerBoard *int32 `json:"tasks_per_board,omitempty"`

	// TasksPerCore Number of tasks to invoke on each core
	TasksPerCore *int32 `json:"tasks_per_core,omitempty"`

	// TasksPerNode Number of tasks to invoke on each node
	TasksPerNode *int32 `json:"tasks_per_node,omitempty"`

	// TasksPerSocket Number of tasks to invoke on each socket
	TasksPerSocket *int32 `json:"tasks_per_socket,omitempty"`

	// TemporaryDiskPerNode Minimum tmp disk space required per node
	TemporaryDiskPerNode *int32 `json:"temporary_disk_per_node,omitempty"`

	// ThreadSpecification Specialized thread count
	ThreadSpecification *int32 `json:"thread_specification,omitempty"`

	// ThreadsPerCore Threads per core required
	ThreadsPerCore *int32                  `json:"threads_per_core,omitempty"`
	TimeLimit      *V0041Uint32NoValStruct `json:"time_limit,omitempty"`
	TimeMinimum    *V0041Uint32NoValStruct `json:"time_minimum,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma separated list of TRES=# values to be allocated for every job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma separated list of TRES=# values to be allocated for every node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma separated list of TRES=# values to be allocated for every socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma separated list of TRES=# values to be allocated for every task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// UserId User ID that owns the job
	UserId *string `json:"user_id,omitempty"`

	// WaitAllNodes If true, wait to start until after all nodes have booted
	WaitAllNodes *bool `json:"wait_all_nodes,omitempty"`

	// WaitForSwitch Maximum time to wait for switches in seconds
	WaitForSwitch *int32 `json:"wait_for_switch,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`

	// X11 X11 forwarding options
	X11 *[]V0041JobDescMsgX11 `json:"x11,omitempty"`

	// X11MagicCookie Magic cookie for X11 forwarding
	X11MagicCookie *string `json:"x11_magic_cookie,omitempty"`

	// X11TargetHost Hostname or UNIX socket if x11_target_port=0
	X11TargetHost *string `json:"x11_target_host,omitempty"`

	// X11TargetPort TCP port
	X11TargetPort *int32 `json:"x11_target_port,omitempty"`
}

// V0041JobDescMsgCpuBindingFlags defines model for V0041JobDescMsg.CpuBindingFlags.
type V0041JobDescMsgCpuBindingFlags string

// V0041JobDescMsgExclusive defines model for V0041JobDescMsg.Exclusive.
type V0041JobDescMsgExclusive string

// V0041JobDescMsgFlags defines model for V0041JobDescMsg.Flags.
type V0041JobDescMsgFlags string

// V0041JobDescMsgKillWarningFlags defines model for V0041JobDescMsg.KillWarningFlags.
type V0041JobDescMsgKillWarningFlags string

// V0041JobDescMsgMailType defines model for V0041JobDescMsg.MailType.
type V0041JobDescMsgMailType string

// V0041JobDescMsgMemoryBindingType defines model for V0041JobDescMsg.MemoryBindingType.
type V0041JobDescMsgMemoryBindingType string

// V0041JobDescMsgOpenMode defines model for V0041JobDescMsg.OpenMode.
type V0041JobDescMsgOpenMode string

// V0041JobDescMsgProfile defines model for V0041JobDescMsg.Profile.
type V0041JobDescMsgProfile string

// V0041JobDescMsgShared defines model for V0041JobDescMsg.Shared.
type V0041JobDescMsgShared string

// V0041JobDescMsgX11 defines model for V0041JobDescMsg.X11.
type V0041JobDescMsgX11 string

// V0041JobDescMsgList defines model for v0.0.41_job_desc_msg_list.
type V0041JobDescMsgList = []V0041JobDescMsg

// V0041JobInfo defines model for v0.0.41_job_info.
type V0041JobInfo struct {
	// Account Account associated with the job
	Account    *string                 `json:"account,omitempty"`
	AccrueTime *V0041Uint64NoValStruct `json:"accrue_time,omitempty"`

	// AdminComment Arbitrary comment made by administrator
	AdminComment *string `json:"admin_comment,omitempty"`

	// AllocatingNode Local node making the resource allocation
	AllocatingNode *string                 `json:"allocating_node,omitempty"`
	ArrayJobId     *V0041Uint32NoValStruct `json:"array_job_id,omitempty"`
	ArrayMaxTasks  *V0041Uint32NoValStruct `json:"array_max_tasks,omitempty"`
	ArrayTaskId    *V0041Uint32NoValStruct `json:"array_task_id,omitempty"`

	// ArrayTaskString String expression of task IDs in this record
	ArrayTaskString *string `json:"array_task_string,omitempty"`

	// AssociationId Unique identifier for the association
	AssociationId *int32 `json:"association_id,omitempty"`

	// BatchFeatures Features required for batch script's node
	BatchFeatures *string `json:"batch_features,omitempty"`

	// BatchFlag True if batch job
	BatchFlag *bool `json:"batch_flag,omitempty"`

	// BatchHost Name of host running batch script
	BatchHost    *string                  `json:"batch_host,omitempty"`
	BillableTres *V0041Float64NoValStruct `json:"billable_tres,omitempty"`

	// BurstBuffer Burst buffer specifications
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// BurstBufferState Burst buffer state details
	BurstBufferState *string `json:"burst_buffer_state,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`

	// ClusterFeatures List of required cluster features
	ClusterFeatures *string `json:"cluster_features,omitempty"`

	// Command Executed command
	Command *string `json:"command,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Container Absolute path to OCI container bundle
	Container *string `json:"container,omitempty"`

	// ContainerId OCI container ID
	ContainerId *string `json:"container_id,omitempty"`

	// Contiguous True if job requires contiguous nodes
	Contiguous *bool `json:"contiguous,omitempty"`

	// CoreSpec Specialized core count
	CoreSpec             *int32                  `json:"core_spec,omitempty"`
	CoresPerSocket       *V0041Uint16NoValStruct `json:"cores_per_socket,omitempty"`
	CpuFrequencyGovernor *V0041Uint32NoValStruct `json:"cpu_frequency_governor,omitempty"`
	CpuFrequencyMaximum  *V0041Uint32NoValStruct `json:"cpu_frequency_maximum,omitempty"`
	CpuFrequencyMinimum  *V0041Uint32NoValStruct `json:"cpu_frequency_minimum,omitempty"`
	Cpus                 *V0041Uint32NoValStruct `json:"cpus,omitempty"`
	CpusPerTask          *V0041Uint16NoValStruct `json:"cpus_per_task,omitempty"`

	// CpusPerTres Semicolon delimited list of TRES=# values indicating how many CPUs should be allocated for each specified TRES (currently only used for gres/gpu)
	CpusPerTres *string `json:"cpus_per_tres,omitempty"`

	// Cron Time specification for scrontab job
	Cron *string `json:"cron,omitempty"`

	// CurrentWorkingDirectory Working directory to use for the job
	CurrentWorkingDirectory *string                 `json:"current_working_directory,omitempty"`
	Deadline                *V0041Uint64NoValStruct `json:"deadline,omitempty"`
	DelayBoot               *V0041Uint32NoValStruct `json:"delay_boot,omitempty"`

	// Dependency Other jobs that must meet certain criteria before this job can start
	Dependency      *string                      `json:"dependency,omitempty"`
	DerivedExitCode *V0041ProcessExitCodeVerbose `json:"derived_exit_code,omitempty"`
	EligibleTime    *V0041Uint64NoValStruct      `json:"eligible_time,omitempty"`
	EndTime         *V0041Uint64NoValStruct      `json:"end_time,omitempty"`

	// ExcludedNodes Comma separated list of nodes that may not be used
	ExcludedNodes *string `json:"excluded_nodes,omitempty"`
	// Deprecated:
	Exclusive *[]V0041JobInfoExclusive     `json:"exclusive,omitempty"`
	ExitCode  *V0041ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra *string `json:"extra,omitempty"`

	// FailedNode Name of node that caused job failure
	FailedNode *string `json:"failed_node,omitempty"`

	// Features Comma separated list of features that are required
	Features *string `json:"features,omitempty"`

	// FederationOrigin Origin cluster's name (when using federation)
	FederationOrigin *string `json:"federation_origin,omitempty"`

	// FederationSiblingsActive Active sibling job names
	FederationSiblingsActive *string `json:"federation_siblings_active,omitempty"`

	// FederationSiblingsViable Viable sibling job names
	FederationSiblingsViable *string `json:"federation_siblings_viable,omitempty"`

	// Flags Job flags
	Flags      *[]V0041JobInfoFlags    `json:"flags,omitempty"`
	GresDetail *V0041JobInfoGresDetail `json:"gres_detail,omitempty"`

	// GroupId Group ID of the user that owns the job
	GroupId *int32 `json:"group_id,omitempty"`

	// GroupName Group name of the user that owns the job
	GroupName *string                 `json:"group_name,omitempty"`
	HetJobId  *V0041Uint32NoValStruct `json:"het_job_id,omitempty"`

	// HetJobIdSet Job ID range for all heterogeneous job components
	HetJobIdSet  *string                 `json:"het_job_id_set,omitempty"`
	HetJobOffset *V0041Uint32NoValStruct `json:"het_job_offset,omitempty"`

	// Hold Hold (true) or release (false) job
	Hold *bool `json:"hold,omitempty"`

	// JobId Job ID
	JobId        *int32          `json:"job_id,omitempty"`
	JobResources *V0041JobRes    `json:"job_resources,omitempty"`
	JobSizeStr   *V0041CsvString `json:"job_size_str,omitempty"`

	// JobState Current state
	JobState            *[]V0041JobInfoJobState `json:"job_state,omitempty"`
	LastSchedEvaluation *V0041Uint64NoValStruct `json:"last_sched_evaluation,omitempty"`

	// Licenses License(s) required by the job
	Licenses *string `json:"licenses,omitempty"`

	// MailType Mail event type(s)
	MailType *[]V0041JobInfoMailType `json:"mail_type,omitempty"`

	// MailUser User to receive email notifications
	MailUser *string                 `json:"mail_user,omitempty"`
	MaxCpus  *V0041Uint32NoValStruct `json:"max_cpus,omitempty"`
	MaxNodes *V0041Uint32NoValStruct `json:"max_nodes,omitempty"`

	// MaximumSwitchWaitTime Maximum time to wait for switches in seconds
	MaximumSwitchWaitTime *int32 `json:"maximum_switch_wait_time,omitempty"`

	// McsLabel Multi-Category Security label on the job
	McsLabel      *string                 `json:"mcs_label,omitempty"`
	MemoryPerCpu  *V0041Uint64NoValStruct `json:"memory_per_cpu,omitempty"`
	MemoryPerNode *V0041Uint64NoValStruct `json:"memory_per_node,omitempty"`

	// MemoryPerTres Semicolon delimited list of TRES=# values indicating how much memory in megabytes should be allocated for each specified TRES (currently only used for gres/gpu)
	MemoryPerTres      *string                 `json:"memory_per_tres,omitempty"`
	MinimumCpusPerNode *V0041Uint16NoValStruct `json:"minimum_cpus_per_node,omitempty"`

	// MinimumSwitches Maximum number of switches (the 'minimum' in the key is incorrect)
	MinimumSwitches       *int32                  `json:"minimum_switches,omitempty"`
	MinimumTmpDiskPerNode *V0041Uint32NoValStruct `json:"minimum_tmp_disk_per_node,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`

	// Network Network specs for the job
	Network *string `json:"network,omitempty"`

	// Nice Requested job priority change
	Nice      *int32                  `json:"nice,omitempty"`
	NodeCount *V0041Uint32NoValStruct `json:"node_count,omitempty"`

	// Nodes Node(s) allocated to the job
	Nodes *string `json:"nodes,omitempty"`
	// Deprecated:
	Oversubscribe *bool `json:"oversubscribe,omitempty"`

	// Partition Partition assigned to the job
	Partition *string `json:"partition,omitempty"`
	Power     *struct {
		// Deprecated:
		Flags *[]interface{} `json:"flags,omitempty"`
	} `json:"power,omitempty"`
	PreSusTime      *V0041Uint64NoValStruct `json:"pre_sus_time,omitempty"`
	PreemptTime     *V0041Uint64NoValStruct `json:"preempt_time,omitempty"`
	PreemptableTime *V0041Uint64NoValStruct `json:"preemptable_time,omitempty"`

	// Prefer Feature(s) the job requested but that are not required
	Prefer   *string                 `json:"prefer,omitempty"`
	Priority *V0041Uint32NoValStruct `json:"priority,omitempty"`

	// Profile Profile used by the acct_gather_profile plugin
	Profile *[]V0041JobInfoProfile `json:"profile,omitempty"`

	// Qos Quality of Service assigned to the job
	Qos *string `json:"qos,omitempty"`

	// Reboot Node reboot requested before start
	Reboot *bool `json:"reboot,omitempty"`

	// Requeue Determines whether the job may be requeued
	Requeue *bool `json:"requeue,omitempty"`

	// RequiredNodes Comma separated list of required nodes
	RequiredNodes *string                 `json:"required_nodes,omitempty"`
	ResizeTime    *V0041Uint64NoValStruct `json:"resize_time,omitempty"`

	// RestartCnt Number of job restarts
	RestartCnt *int32 `json:"restart_cnt,omitempty"`

	// ResvName Name of reservation to use
	ResvName *string `json:"resv_name,omitempty"`

	// ScheduledNodes List of nodes scheduled to be used for the job
	ScheduledNodes *string `json:"scheduled_nodes,omitempty"`

	// SelinuxContext SELinux context
	SelinuxContext *string `json:"selinux_context,omitempty"`

	// Shared How the job can share resources with other jobs, if at all
	Shared *[]V0041JobInfoShared `json:"shared,omitempty"`

	// ShowFlags Job details shown in this response
	ShowFlags *[]V0041JobInfoShowFlags `json:"show_flags,omitempty"`

	// SocketsPerBoard Number of sockets per board required
	SocketsPerBoard *int32                  `json:"sockets_per_board,omitempty"`
	SocketsPerNode  *V0041Uint16NoValStruct `json:"sockets_per_node,omitempty"`

	// StandardError Path to stderr file
	StandardError *string `json:"standard_error,omitempty"`

	// StandardInput Path to stdin file
	StandardInput *string `json:"standard_input,omitempty"`

	// StandardOutput Path to stdout file
	StandardOutput *string                 `json:"standard_output,omitempty"`
	StartTime      *V0041Uint64NoValStruct `json:"start_time,omitempty"`

	// StateDescription Optional details for state_reason
	StateDescription *string `json:"state_description,omitempty"`

	// StateReason Reason for current Pending or Failed state
	StateReason *string                 `json:"state_reason,omitempty"`
	SubmitTime  *V0041Uint64NoValStruct `json:"submit_time,omitempty"`
	SuspendTime *V0041Uint64NoValStruct `json:"suspend_time,omitempty"`

	// SystemComment Arbitrary comment from slurmctld
	SystemComment  *string                 `json:"system_comment,omitempty"`
	Tasks          *V0041Uint32NoValStruct `json:"tasks,omitempty"`
	TasksPerBoard  *V0041Uint16NoValStruct `json:"tasks_per_board,omitempty"`
	TasksPerCore   *V0041Uint16NoValStruct `json:"tasks_per_core,omitempty"`
	TasksPerNode   *V0041Uint16NoValStruct `json:"tasks_per_node,omitempty"`
	TasksPerSocket *V0041Uint16NoValStruct `json:"tasks_per_socket,omitempty"`
	TasksPerTres   *V0041Uint16NoValStruct `json:"tasks_per_tres,omitempty"`

	// ThreadSpec Specialized thread count
	ThreadSpec     *int32                  `json:"thread_spec,omitempty"`
	ThreadsPerCore *V0041Uint16NoValStruct `json:"threads_per_core,omitempty"`
	TimeLimit      *V0041Uint32NoValStruct `json:"time_limit,omitempty"`
	TimeMinimum    *V0041Uint32NoValStruct `json:"time_minimum,omitempty"`

	// TresAllocStr TRES used by the job
	TresAllocStr *string `json:"tres_alloc_str,omitempty"`

	// TresBind Task to TRES binding directives
	TresBind *string `json:"tres_bind,omitempty"`

	// TresFreq TRES frequency directives
	TresFreq *string `json:"tres_freq,omitempty"`

	// TresPerJob Comma separated list of TRES=# values to be allocated per job
	TresPerJob *string `json:"tres_per_job,omitempty"`

	// TresPerNode Comma separated list of TRES=# values to be allocated per node
	TresPerNode *string `json:"tres_per_node,omitempty"`

	// TresPerSocket Comma separated list of TRES=# values to be allocated per socket
	TresPerSocket *string `json:"tres_per_socket,omitempty"`

	// TresPerTask Comma separated list of TRES=# values to be allocated per task
	TresPerTask *string `json:"tres_per_task,omitempty"`

	// TresReqStr TRES requested by the job
	TresReqStr *string `json:"tres_req_str,omitempty"`

	// UserId User ID that owns the job
	UserId *int32 `json:"user_id,omitempty"`

	// UserName User name that owns the job
	UserName *string `json:"user_name,omitempty"`

	// Wckey Workload characterization key
	Wckey *string `json:"wckey,omitempty"`
}

// V0041JobInfoExclusive defines model for V0041JobInfo.Exclusive.
type V0041JobInfoExclusive string

// V0041JobInfoFlags defines model for V0041JobInfo.Flags.
type V0041JobInfoFlags string

// V0041JobInfoJobState defines model for V0041JobInfo.JobState.
type V0041JobInfoJobState string

// V0041JobInfoMailType defines model for V0041JobInfo.MailType.
type V0041JobInfoMailType string

// V0041JobInfoProfile defines model for V0041JobInfo.Profile.
type V0041JobInfoProfile string

// V0041JobInfoShared defines model for V0041JobInfo.Shared.
type V0041JobInfoShared string

// V0041JobInfoShowFlags defines model for V0041JobInfo.ShowFlags.
type V0041JobInfoShowFlags string

// V0041JobInfoGresDetail defines model for v0.0.41_job_info_gres_detail.
type V0041JobInfoGresDetail = []string

// V0041JobInfoMsg defines model for v0.0.41_job_info_msg.
type V0041JobInfoMsg = []V0041JobInfo

// V0041JobList defines model for v0.0.41_job_list.
type V0041JobList = []V0041Job

// V0041JobRes defines model for v0.0.41_job_res.
type V0041JobRes struct {
	// Cpus Number of allocated CPUs
	Cpus  int32 `json:"cpus"`
	Nodes *struct {
		// Allocation Job resources for a node
		Allocation *V0041JobResNodes `json:"allocation,omitempty"`

		// Count Number of allocated nodes
		Count *int32 `json:"count,omitempty"`

		// List Node(s) allocated to the job
		List *string `json:"list,omitempty"`

		// SelectType Node scheduling selection method
		SelectType *[]V0041JobResNodesSelectType `json:"select_type,omitempty"`

		// Whole Whether whole nodes were allocated
		Whole *bool `json:"whole,omitempty"`
	} `json:"nodes,omitempty"`

	// SelectType Scheduler consumable resource selection type
	SelectType     []V0041JobResSelectType `json:"select_type"`
	ThreadsPerCore V0041Uint16NoValStruct  `json:"threads_per_core"`
}

// V0041JobResNodesSelectType defines model for V0041JobRes.Nodes.SelectType.
type V0041JobResNodesSelectType string

// V0041JobResSelectType defines model for V0041JobRes.SelectType.
type V0041JobResSelectType string

// V0041JobResCore defines model for v0.0.41_job_res_core.
type V0041JobResCore struct {
	// Index Core index
	Index int32 `json:"index"`

	// Status Core status
	Status []V0041JobResCoreStatus `json:"status"`
}

// V0041JobResCoreStatus defines model for V0041JobResCore.Status.
type V0041JobResCoreStatus string

// V0041JobResCoreArray defines model for v0.0.41_job_res_core_array.
type V0041JobResCoreArray = []V0041JobResCore

// V0041JobResNode defines model for v0.0.41_job_res_node.
type V0041JobResNode struct {
	Cpus *struct {
		// Count Total number of CPUs assigned to job
		Count *int32 `json:"count,omitempty"`

		// Used Total number of CPUs used by job
		Used *int32 `json:"used,omitempty"`
	} `json:"cpus,omitempty"`

	// Index Node index
	Index  int32 `json:"index"`
	Memory *struct {
		// Allocated Total memory (MiB) allocated to job
		Allocated *int64 `json:"allocated,omitempty"`

		// Used Total memory (MiB) used by job
		Used *int64 `json:"used,omitempty"`
	} `json:"memory,omitempty"`

	// Name Node name
	Name    string                 `json:"name"`
	Sockets V0041JobResSocketArray `json:"sockets"`
}

// V0041JobResNodes Job resources for a node
type V0041JobResNodes = []V0041JobResNode

// V0041JobResSocket defines model for v0.0.41_job_res_socket.
type V0041JobResSocket struct {
	Cores V0041JobResCoreArray `json:"cores"`

	// Index Core index
	Index int32 `json:"index"`
}

// V0041JobResSocketArray defines model for v0.0.41_job_res_socket_array.
type V0041JobResSocketArray = []V0041JobResSocket

// V0041JobSubmitReq defines model for v0.0.41_job_submit_req.
type V0041JobSubmitReq struct {
	Job  *V0041JobDescMsg     `json:"job,omitempty"`
	Jobs *V0041JobDescMsgList `json:"jobs,omitempty"`

	// Script Deprecated; Populate script field in jobs[0] or job
	// Deprecated:
	Script *string `json:"script,omitempty"`
}

// V0041JobSubmitResponseMsg defines model for v0.0.41_job_submit_response_msg.
type V0041JobSubmitResponseMsg struct {
	// Error Error message
	Error *string `json:"error,omitempty"`

	// ErrorCode Error code
	ErrorCode *int32 `json:"error_code,omitempty"`

	// JobId New job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Message to user from job_submit plugin
	JobSubmitUserMsg *string `json:"job_submit_user_msg,omitempty"`

	// StepId New job step ID
	StepId *string `json:"step_id,omitempty"`
}

// V0041KillJobsMsg defines model for v0.0.41_kill_jobs_msg.
type V0041KillJobsMsg struct {
	// Account Filter jobs to a specific account
	Account *string `json:"account,omitempty"`

	// Flags Filter jobs according to flags
	Flags *[]V0041KillJobsMsgFlags `json:"flags,omitempty"`

	// JobName Filter jobs to a specific name
	JobName *string `json:"job_name,omitempty"`

	// JobState Filter jobs to a specific state
	JobState *[]V0041KillJobsMsgJobState `json:"job_state,omitempty"`
	Jobs     *V0041KillJobsMsgJobsArray  `json:"jobs,omitempty"`
	Nodes    *V0041HostlistString        `json:"nodes,omitempty"`

	// Partition Filter jobs to a specific partition
	Partition *string `json:"partition,omitempty"`

	// Qos Filter jobs to a specific QOS
	Qos *string `json:"qos,omitempty"`

	// Reservation Filter jobs to a specific reservation
	Reservation *string `json:"reservation,omitempty"`

	// Signal Signal to send to jobs
	Signal *string `json:"signal,omitempty"`

	// UserId Filter jobs to a specific numeric user id
	UserId *string `json:"user_id,omitempty"`

	// UserName Filter jobs to a specific user name
	UserName *string `json:"user_name,omitempty"`

	// Wckey Filter jobs to a specific wckey
	Wckey *string `json:"wckey,omitempty"`
}

// V0041KillJobsMsgFlags defines model for V0041KillJobsMsg.Flags.
type V0041KillJobsMsgFlags string

// V0041KillJobsMsgJobState defines model for V0041KillJobsMsg.JobState.
type V0041KillJobsMsgJobState string

// V0041KillJobsMsgJobsArray defines model for v0.0.41_kill_jobs_msg_jobs_array.
type V0041KillJobsMsgJobsArray = []string

// V0041KillJobsRespJob defines model for v0.0.41_kill_jobs_resp_job.
type V0041KillJobsRespJob struct {
	Error *struct {
		// Code Numeric error encountered signaling job
		Code *int32 `json:"code,omitempty"`

		// Message Error message why signaling job failed
		Message *string `json:"message,omitempty"`

		// String String error encountered signaling job
		String *string `json:"string,omitempty"`
	} `json:"error,omitempty"`
	Federation *struct {
		// Sibling Name of federation sibling (may be empty for non-federation)
		Sibling *string `json:"sibling,omitempty"`
	} `json:"federation,omitempty"`
	JobId V0041Uint32NoValStruct `json:"job_id"`

	// StepId Job or Step ID that signaling failed
	StepId string `json:"step_id"`
}

// V0041KillJobsRespMsg List of jobs signal responses
type V0041KillJobsRespMsg = []V0041KillJobsRespJob

// V0041License defines model for v0.0.41_license.
type V0041License struct {
	// Free Number of licenses currently available
	Free *int32 `json:"Free,omitempty"`

	// LastConsumed Last known number of licenses that were consumed in the license manager (Remote Only)
	LastConsumed *int32 `json:"LastConsumed,omitempty"`

	// LastDeficit Number of "missing licenses" from the cluster's perspective
	LastDeficit *int32 `json:"LastDeficit,omitempty"`

	// LastUpdate When the license information was last updated (UNIX Timestamp)
	LastUpdate *int64 `json:"LastUpdate,omitempty"`

	// LicenseName Name of the license
	LicenseName *string `json:"LicenseName,omitempty"`

	// Remote Indicates whether licenses are served by the database
	Remote *bool `json:"Remote,omitempty"`

	// Reserved Number of licenses reserved
	Reserved *int32 `json:"Reserved,omitempty"`

	// Total Total number of licenses present
	Total *int32 `json:"Total,omitempty"`

	// Used Number of licenses in use
	Used *int32 `json:"Used,omitempty"`
}

// V0041Licenses defines model for v0.0.41_licenses.
type V0041Licenses = []V0041License

// V0041Node defines model for v0.0.41_node.
type V0041Node struct {
	ActiveFeatures *V0041CsvString `json:"active_features,omitempty"`

	// Address NodeAddr, used to establish a communication path
	Address *string `json:"address,omitempty"`

	// AllocCpus Total number of CPUs currently allocated for jobs
	AllocCpus *int32 `json:"alloc_cpus,omitempty"`

	// AllocIdleCpus Total number of idle CPUs
	AllocIdleCpus *int32 `json:"alloc_idle_cpus,omitempty"`

	// AllocMemory Total memory in MB currently allocated for jobs
	AllocMemory *int64 `json:"alloc_memory,omitempty"`

	// Architecture Computer architecture
	Architecture *string `json:"architecture,omitempty"`

	// Boards Number of Baseboards in nodes with a baseboard controller
	Boards   *int32                  `json:"boards,omitempty"`
	BootTime *V0041Uint64NoValStruct `json:"boot_time,omitempty"`

	// BurstbufferNetworkAddress Alternate network path to be used for sbcast network traffic
	BurstbufferNetworkAddress *string `json:"burstbuffer_network_address,omitempty"`

	// ClusterName Cluster name (only set in federated environments)
	ClusterName *string `json:"cluster_name,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// Cores Number of cores in a single physical processor socket
	Cores *int32 `json:"cores,omitempty"`

	// CpuBinding Default method for binding tasks to allocated CPUs
	CpuBinding *int32 `json:"cpu_binding,omitempty"`

	// CpuLoad CPU load as reported by the OS
	CpuLoad *int32 `json:"cpu_load,omitempty"`

	// Cpus Total CPUs, including cores and threads
	Cpus *int32 `json:"cpus,omitempty"`

	// EffectiveCpus Number of effective CPUs (excluding specialized CPUs)
	EffectiveCpus *int32                 `json:"effective_cpus,omitempty"`
	Energy        *V0041AcctGatherEnergy `json:"energy,omitempty"`
	// Deprecated:
	ExternalSensors *map[string]interface{} `json:"external_sensors,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra    *string                 `json:"extra,omitempty"`
	Features *V0041CsvString         `json:"features,omitempty"`
	FreeMem  *V0041Uint64NoValStruct `json:"free_mem,omitempty"`

	// GpuSpec CPU cores reserved for jobs that also use a GPU
	GpuSpec *string `json:"gpu_spec,omitempty"`

	// Gres Generic resources
	Gres *string `json:"gres,omitempty"`

	// GresDrained Drained generic resources
	GresDrained *string `json:"gres_drained,omitempty"`

	// GresUsed Generic resources currently in use
	GresUsed *string `json:"gres_used,omitempty"`

	// Hostname NodeHostname
	Hostname *string `json:"hostname,omitempty"`

	// InstanceId Cloud instance ID
	InstanceId *string `json:"instance_id,omitempty"`

	// InstanceType Cloud instance type
	InstanceType *string                 `json:"instance_type,omitempty"`
	LastBusy     *V0041Uint64NoValStruct `json:"last_busy,omitempty"`

	// McsLabel Multi-Category Security label
	McsLabel *string `json:"mcs_label,omitempty"`

	// Name NodeName
	Name *string `json:"name,omitempty"`

	// NextStateAfterReboot The state the node will be assigned after rebooting
	NextStateAfterReboot *[]V0041NodeNextStateAfterReboot `json:"next_state_after_reboot,omitempty"`

	// OperatingSystem Operating system reported by the node
	OperatingSystem *string `json:"operating_system,omitempty"`

	// Owner User allowed to run jobs on this node (unset if no restriction)
	Owner      *string         `json:"owner,omitempty"`
	Partitions *V0041CsvString `json:"partitions,omitempty"`

	// Port TCP port number of the slurmd
	Port *int32 `json:"port,omitempty"`
	// Deprecated:
	Power *map[string]interface{} `json:"power,omitempty"`

	// RealMemory Total memory in MB on the node
	RealMemory *int64 `json:"real_memory,omitempty"`

	// Reason Describes why the node is in a "DOWN", "DRAINED", "DRAINING", "FAILING" or "FAIL" state
	Reason          *string                 `json:"reason,omitempty"`
	ReasonChangedAt *V0041Uint64NoValStruct `json:"reason_changed_at,omitempty"`

	// ReasonSetByUser User who set the reason
	ReasonSetByUser *string `json:"reason_set_by_user,omitempty"`

	// ResCoresPerGpu Number of CPU cores per GPU restricted to GPU jobs
	ResCoresPerGpu *int32 `json:"res_cores_per_gpu,omitempty"`

	// Reservation Name of reservation containing this node
	Reservation     *string                 `json:"reservation,omitempty"`
	ResumeAfter     *V0041Uint64NoValStruct `json:"resume_after,omitempty"`
	SlurmdStartTime *V0041Uint64NoValStruct `json:"slurmd_start_time,omitempty"`

	// Sockets Number of physical processor sockets/chips on the node
	Sockets *int32 `json:"sockets,omitempty"`

	// SpecializedCores Number of cores reserved for system use
	SpecializedCores *int32 `json:"specialized_cores,omitempty"`

	// SpecializedCpus Abstract CPU IDs on this node reserved for exclusive use by slurmd and slurmstepd
	SpecializedCpus *string `json:"specialized_cpus,omitempty"`

	// SpecializedMemory Combined memory limit, in MB, for Slurm compute node daemons
	SpecializedMemory *int64 `json:"specialized_memory,omitempty"`

	// State Node state(s) applicable to this node
	State *[]V0041NodeState `json:"state,omitempty"`

	// TemporaryDisk Total size in MB of temporary disk storage in TmpFS
	TemporaryDisk *int32 `json:"temporary_disk,omitempty"`

	// Threads Number of logical threads in a single physical core
	Threads *int32 `json:"threads,omitempty"`

	// Tres Configured trackable resources
	Tres *string `json:"tres,omitempty"`

	// TresUsed Trackable resources currently allocated for jobs
	TresUsed *string `json:"tres_used,omitempty"`

	// TresWeighted Weighted number of billable trackable resources allocated
	TresWeighted *float64 `json:"tres_weighted,omitempty"`

	// Version Slurmd version
	Version *string `json:"version,omitempty"`

	// Weight Weight of the node for scheduling purposes
	Weight *int32 `json:"weight,omitempty"`
}

// V0041NodeNextStateAfterReboot defines model for V0041Node.NextStateAfterReboot.
type V0041NodeNextStateAfterReboot string

// V0041NodeState defines model for V0041Node.State.
type V0041NodeState string

// V0041Nodes defines model for v0.0.41_nodes.
type V0041Nodes = []V0041Node

// V0041OpenapiAccountsAddCondResp defines model for v0.0.41_openapi_accounts_add_cond_resp.
type V0041OpenapiAccountsAddCondResp struct {
	Account              *V0041AccountShort    `json:"account,omitempty"`
	AssociationCondition *V0041AccountsAddCond `json:"association_condition,omitempty"`
	Errors               *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta                 *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings             *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsAddCondRespStr defines model for v0.0.41_openapi_accounts_add_cond_resp_str.
type V0041OpenapiAccountsAddCondRespStr struct {
	// AddedAccounts added_accounts
	AddedAccounts string                `json:"added_accounts"`
	Errors        *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta          *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings      *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsRemovedResp defines model for v0.0.41_openapi_accounts_removed_resp.
type V0041OpenapiAccountsRemovedResp struct {
	Errors          *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta            *V0041OpenapiMeta     `json:"meta,omitempty"`
	RemovedAccounts V0041StringList       `json:"removed_accounts"`
	Warnings        *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiAccountsResp defines model for v0.0.41_openapi_accounts_resp.
type V0041OpenapiAccountsResp struct {
	Accounts V0041AccountList      `json:"accounts"`
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsRemovedResp defines model for v0.0.41_openapi_assocs_removed_resp.
type V0041OpenapiAssocsRemovedResp struct {
	Errors              *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta                *V0041OpenapiMeta     `json:"meta,omitempty"`
	RemovedAssociations V0041StringList       `json:"removed_associations"`
	Warnings            *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiAssocsResp defines model for v0.0.41_openapi_assocs_resp.
type V0041OpenapiAssocsResp struct {
	Associations V0041AssocList        `json:"associations"`
	Errors       *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta         *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings     *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiClustersRemovedResp defines model for v0.0.41_openapi_clusters_removed_resp.
type V0041OpenapiClustersRemovedResp struct {
	DeletedClusters V0041StringList       `json:"deleted_clusters"`
	Errors          *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta            *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings        *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiClustersResp defines model for v0.0.41_openapi_clusters_resp.
type V0041OpenapiClustersResp struct {
	Clusters V0041ClusterRecList   `json:"clusters"`
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiDiagResp defines model for v0.0.41_openapi_diag_resp.
type V0041OpenapiDiagResp struct {
	Errors     *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0041OpenapiMeta     `json:"meta,omitempty"`
	Statistics V0041StatsMsg         `json:"statistics"`
	Warnings   *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiError defines model for v0.0.41_openapi_error.
type V0041OpenapiError struct {
	// Description Long form error description
	Description *string `json:"description,omitempty"`

	// Error Short form error description
	Error *string `json:"error,omitempty"`

	// ErrorNumber Slurm numeric error identifier
	ErrorNumber *int32 `json:"error_number,omitempty"`

	// Source Source of error or where error was first detected
	Source *string `json:"source,omitempty"`
}

// V0041OpenapiErrors defines model for v0.0.41_openapi_errors.
type V0041OpenapiErrors = []V0041OpenapiError

// V0041OpenapiInstancesResp defines model for v0.0.41_openapi_instances_resp.
type V0041OpenapiInstancesResp struct {
	Errors    *V0041OpenapiErrors   `json:"errors,omitempty"`
	Instances V0041InstanceList     `json:"instances"`
	Meta      *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings  *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiJobAllocResp defines model for v0.0.41_openapi_job_alloc_resp.
type V0041OpenapiJobAllocResp struct {
	Errors *V0041OpenapiErrors `json:"errors,omitempty"`

	// JobId Submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string               `json:"job_submit_user_msg,omitempty"`
	Meta             *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings         *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiJobInfoResp defines model for v0.0.41_openapi_job_info_resp.
type V0041OpenapiJobInfoResp struct {
	Errors       *V0041OpenapiErrors    `json:"errors,omitempty"`
	Jobs         V0041JobInfoMsg        `json:"jobs"`
	LastBackfill V0041Uint64NoValStruct `json:"last_backfill"`
	LastUpdate   V0041Uint64NoValStruct `json:"last_update"`
	Meta         *V0041OpenapiMeta      `json:"meta,omitempty"`
	Warnings     *V0041OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0041OpenapiJobPostResponse defines model for v0.0.41_openapi_job_post_response.
type V0041OpenapiJobPostResponse struct {
	Errors *V0041OpenapiErrors `json:"errors,omitempty"`

	// JobId First updated Job ID - Use results instead
	// Deprecated:
	JobId *string `json:"job_id,omitempty"`

	// JobSubmitUserMsg First updated Job submission user message - Use results instead
	// Deprecated:
	JobSubmitUserMsg *string                     `json:"job_submit_user_msg,omitempty"`
	Meta             *V0041OpenapiMeta           `json:"meta,omitempty"`
	Results          *V0041JobArrayResponseArray `json:"results,omitempty"`

	// StepId First updated Step ID - Use results instead
	// Deprecated:
	StepId   *string               `json:"step_id,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiJobSubmitResponse defines model for v0.0.41_openapi_job_submit_response.
type V0041OpenapiJobSubmitResponse struct {
	Errors *V0041OpenapiErrors `json:"errors,omitempty"`

	// JobId Submitted Job ID
	JobId *int32 `json:"job_id,omitempty"`

	// JobSubmitUserMsg Job submission user message
	JobSubmitUserMsg *string                    `json:"job_submit_user_msg,omitempty"`
	Meta             *V0041OpenapiMeta          `json:"meta,omitempty"`
	Result           *V0041JobSubmitResponseMsg `json:"result,omitempty"`

	// StepId Submitted Step ID
	StepId   *string               `json:"step_id,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiKillJobsResp defines model for v0.0.41_openapi_kill_jobs_resp.
type V0041OpenapiKillJobsResp struct {
	Errors *V0041OpenapiErrors `json:"errors,omitempty"`
	Meta   *V0041OpenapiMeta   `json:"meta,omitempty"`

	// Status List of jobs signal responses
	Status   V0041KillJobsRespMsg  `json:"status"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiLicensesResp defines model for v0.0.41_openapi_licenses_resp.
type V0041OpenapiLicensesResp struct {
	Errors     *V0041OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0041Uint64NoValStruct `json:"last_update"`
	Licenses   V0041Licenses          `json:"licenses"`
	Meta       *V0041OpenapiMeta      `json:"meta,omitempty"`
	Warnings   *V0041OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0041OpenapiMeta defines model for v0.0.41_openapi_meta.
type V0041OpenapiMeta struct {
	Client *struct {
		// Group Client group (if known)
		Group *string `json:"group,omitempty"`

		// Source Client source description
		Source *string `json:"source,omitempty"`

		// User Client user (if known)
		User *string `json:"user,omitempty"`
	} `json:"client,omitempty"`
	Command *V0041StringArray `json:"command,omitempty"`
	Plugin  *struct {
		// AccountingStorage Slurm accounting plugin
		AccountingStorage *string `json:"accounting_storage,omitempty"`

		// DataParser Slurm data_parser plugin
		DataParser *string `json:"data_parser,omitempty"`

		// Name Slurm plugin name (if applicable)
		Name *string `json:"name,omitempty"`

		// Type Slurm plugin type (if applicable)
		Type *string `json:"type,omitempty"`
	} `json:"plugin,omitempty"`
	Slurm *struct {
		// Cluster Slurm cluster name
		Cluster *string `json:"cluster,omitempty"`

		// Release Slurm release string
		Release *string `json:"release,omitempty"`
		Version *struct {
			// Major Slurm release major version
			Major *string `json:"major,omitempty"`

			// Micro Slurm release micro version
			Micro *string `json:"micro,omitempty"`

			// Minor Slurm release minor version
			Minor *string `json:"minor,omitempty"`
		} `json:"version,omitempty"`
	} `json:"slurm,omitempty"`
}

// V0041OpenapiNodesResp defines model for v0.0.41_openapi_nodes_resp.
type V0041OpenapiNodesResp struct {
	Errors     *V0041OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0041Uint64NoValStruct `json:"last_update"`
	Meta       *V0041OpenapiMeta      `json:"meta,omitempty"`
	Nodes      V0041Nodes             `json:"nodes"`
	Warnings   *V0041OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0041OpenapiPartitionResp defines model for v0.0.41_openapi_partition_resp.
type V0041OpenapiPartitionResp struct {
	Errors     *V0041OpenapiErrors    `json:"errors,omitempty"`
	LastUpdate V0041Uint64NoValStruct `json:"last_update"`
	Meta       *V0041OpenapiMeta      `json:"meta,omitempty"`
	Partitions V0041PartitionInfoMsg  `json:"partitions"`
	Warnings   *V0041OpenapiWarnings  `json:"warnings,omitempty"`
}

// V0041OpenapiPingArrayResp defines model for v0.0.41_openapi_ping_array_resp.
type V0041OpenapiPingArrayResp struct {
	Errors   *V0041OpenapiErrors      `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta        `json:"meta,omitempty"`
	Pings    V0041ControllerPingArray `json:"pings"`
	Warnings *V0041OpenapiWarnings    `json:"warnings,omitempty"`
}

// V0041OpenapiReservationResp defines model for v0.0.41_openapi_reservation_resp.
type V0041OpenapiReservationResp struct {
	Errors       *V0041OpenapiErrors     `json:"errors,omitempty"`
	LastUpdate   V0041Uint64NoValStruct  `json:"last_update"`
	Meta         *V0041OpenapiMeta       `json:"meta,omitempty"`
	Reservations V0041ReservationInfoMsg `json:"reservations"`
	Warnings     *V0041OpenapiWarnings   `json:"warnings,omitempty"`
}

// V0041OpenapiResp defines model for v0.0.41_openapi_resp.
type V0041OpenapiResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiSharesResp defines model for v0.0.41_openapi_shares_resp.
type V0041OpenapiSharesResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Shares   V0041SharesRespMsg    `json:"shares"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdConfigResp defines model for v0.0.41_openapi_slurmdbd_config_resp.
type V0041OpenapiSlurmdbdConfigResp struct {
	Accounts     *V0041AccountList     `json:"accounts,omitempty"`
	Associations *V0041AssocList       `json:"associations,omitempty"`
	Clusters     *V0041ClusterRecList  `json:"clusters,omitempty"`
	Errors       *V0041OpenapiErrors   `json:"errors,omitempty"`
	Instances    *V0041InstanceList    `json:"instances,omitempty"`
	Meta         *V0041OpenapiMeta     `json:"meta,omitempty"`
	Qos          *V0041QosList         `json:"qos,omitempty"`
	Tres         *V0041TresList        `json:"tres,omitempty"`
	Users        *V0041UserList        `json:"users,omitempty"`
	Warnings     *V0041OpenapiWarnings `json:"warnings,omitempty"`
	Wckeys       *V0041WckeyList       `json:"wckeys,omitempty"`
}

// V0041OpenapiSlurmdbdJobsResp defines model for v0.0.41_openapi_slurmdbd_jobs_resp.
type V0041OpenapiSlurmdbdJobsResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Jobs     V0041JobList          `json:"jobs"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosRemovedResp defines model for v0.0.41_openapi_slurmdbd_qos_removed_resp.
type V0041OpenapiSlurmdbdQosRemovedResp struct {
	Errors     *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0041OpenapiMeta     `json:"meta,omitempty"`
	RemovedQos V0041StringList       `json:"removed_qos"`
	Warnings   *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdQosResp defines model for v0.0.41_openapi_slurmdbd_qos_resp.
type V0041OpenapiSlurmdbdQosResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Qos      V0041QosList          `json:"qos"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiSlurmdbdStatsResp defines model for v0.0.41_openapi_slurmdbd_stats_resp.
type V0041OpenapiSlurmdbdStatsResp struct {
	Errors     *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0041OpenapiMeta     `json:"meta,omitempty"`
	Statistics V0041StatsRec         `json:"statistics"`
	Warnings   *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiTresResp defines model for v0.0.41_openapi_tres_resp.
type V0041OpenapiTresResp struct {
	TRES     V0041TresList         `json:"TRES"`
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiUsersAddCondResp defines model for v0.0.41_openapi_users_add_cond_resp.
type V0041OpenapiUsersAddCondResp struct {
	AssociationCondition V0041UsersAddCond     `json:"association_condition"`
	Errors               *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta                 *V0041OpenapiMeta     `json:"meta,omitempty"`
	User                 V0041UserShort        `json:"user"`
	Warnings             *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiUsersAddCondRespStr defines model for v0.0.41_openapi_users_add_cond_resp_str.
type V0041OpenapiUsersAddCondRespStr struct {
	// AddedUsers added_users
	AddedUsers string                `json:"added_users"`
	Errors     *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta       *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings   *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiUsersResp defines model for v0.0.41_openapi_users_resp.
type V0041OpenapiUsersResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Users    V0041UserList         `json:"users"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiWarning defines model for v0.0.41_openapi_warning.
type V0041OpenapiWarning struct {
	// Description Long form warning description
	Description *string `json:"description,omitempty"`

	// Source Source of warning or where warning was first detected
	Source *string `json:"source,omitempty"`
}

// V0041OpenapiWarnings defines model for v0.0.41_openapi_warnings.
type V0041OpenapiWarnings = []V0041OpenapiWarning

// V0041OpenapiWckeyRemovedResp defines model for v0.0.41_openapi_wckey_removed_resp.
type V0041OpenapiWckeyRemovedResp struct {
	DeletedWckeys V0041StringList       `json:"deleted_wckeys"`
	Errors        *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta          *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings      *V0041OpenapiWarnings `json:"warnings,omitempty"`
}

// V0041OpenapiWckeyResp defines model for v0.0.41_openapi_wckey_resp.
type V0041OpenapiWckeyResp struct {
	Errors   *V0041OpenapiErrors   `json:"errors,omitempty"`
	Meta     *V0041OpenapiMeta     `json:"meta,omitempty"`
	Warnings *V0041OpenapiWarnings `json:"warnings,omitempty"`
	Wckeys   V0041WckeyList        `json:"wckeys"`
}

// V0041PartitionInfo defines model for v0.0.41_partition_info.
type V0041PartitionInfo struct {
	Accounts *struct {
		// Allowed AllowAccounts
		Allowed *string `json:"allowed,omitempty"`

		// Deny DenyAccounts
		Deny *string `json:"deny,omitempty"`
	} `json:"accounts,omitempty"`

	// Alternate Alternate
	Alternate *string `json:"alternate,omitempty"`

	// Cluster Cluster name
	Cluster *string `json:"cluster,omitempty"`
	Cpus    *struct {
		// TaskBinding CpuBind
		TaskBinding *int32 `json:"task_binding,omitempty"`

		// Total TotalCPUs
		Total *int32 `json:"total,omitempty"`
	} `json:"cpus,omitempty"`
	Defaults *struct {
		// Job JobDefaults
		Job *string `json:"job,omitempty"`

		// MemoryPerCpu DefMemPerCPU or DefMemPerNode
		MemoryPerCpu           *int64                  `json:"memory_per_cpu,omitempty"`
		PartitionMemoryPerCpu  *V0041Uint64NoValStruct `json:"partition_memory_per_cpu,omitempty"`
		PartitionMemoryPerNode *V0041Uint64NoValStruct `json:"partition_memory_per_node,omitempty"`
		Time                   *V0041Uint32NoValStruct `json:"time,omitempty"`
	} `json:"defaults,omitempty"`

	// GraceTime GraceTime
	GraceTime *int32 `json:"grace_time,omitempty"`
	Groups    *struct {
		// Allowed AllowGroups
		Allowed *string `json:"allowed,omitempty"`
	} `json:"groups,omitempty"`
	Maximums *struct {
		CpusPerNode   *V0041Uint32NoValStruct `json:"cpus_per_node,omitempty"`
		CpusPerSocket *V0041Uint32NoValStruct `json:"cpus_per_socket,omitempty"`

		// MemoryPerCpu MaxMemPerCPU or MaxMemPerNode
		MemoryPerCpu  *int64                  `json:"memory_per_cpu,omitempty"`
		Nodes         *V0041Uint32NoValStruct `json:"nodes,omitempty"`
		OverTimeLimit *V0041Uint16NoValStruct `json:"over_time_limit,omitempty"`
		Oversubscribe *struct {
			// Flags Flags applicable to the OverSubscribe setting
			Flags *[]V0041PartitionInfoMaximumsOversubscribeFlags `json:"flags,omitempty"`

			// Jobs Maximum number of jobs allowed to oversubscribe resources
			Jobs *int32 `json:"jobs,omitempty"`
		} `json:"oversubscribe,omitempty"`
		PartitionMemoryPerCpu  *V0041Uint64NoValStruct `json:"partition_memory_per_cpu,omitempty"`
		PartitionMemoryPerNode *V0041Uint64NoValStruct `json:"partition_memory_per_node,omitempty"`

		// Shares OverSubscribe
		Shares *int32                  `json:"shares,omitempty"`
		Time   *V0041Uint32NoValStruct `json:"time,omitempty"`
	} `json:"maximums,omitempty"`
	Minimums *struct {
		// Nodes MinNodes
		Nodes *int32 `json:"nodes,omitempty"`
	} `json:"minimums,omitempty"`

	// Name PartitionName
	Name *string `json:"name,omitempty"`

	// NodeSets NodeSets
	NodeSets *string `json:"node_sets,omitempty"`
	Nodes    *struct {
		// AllowedAllocation AllocNodes
		AllowedAllocation *string `json:"allowed_allocation,omitempty"`

		// Configured Nodes
		Configured *string `json:"configured,omitempty"`

		// Total TotalNodes
		Total *int32 `json:"total,omitempty"`
	} `json:"nodes,omitempty"`
	Partition *struct {
		// State Current state(s)
		State *[]V0041PartitionInfoPartitionState `json:"state,omitempty"`
	} `json:"partition,omitempty"`
	Priority *struct {
		// JobFactor PriorityJobFactor
		JobFactor *int32 `json:"job_factor,omitempty"`

		// Tier PriorityTier
		Tier *int32 `json:"tier,omitempty"`
	} `json:"priority,omitempty"`
	Qos *struct {
		// Allowed AllowQOS
		Allowed *string `json:"allowed,omitempty"`

		// Assigned QOS
		Assigned *string `json:"assigned,omitempty"`

		// Deny DenyQOS
		Deny *string `json:"deny,omitempty"`
	} `json:"qos,omitempty"`

	// SelectType Scheduler consumable resource selection type
	SelectType  *[]V0041PartitionInfoSelectType `json:"select_type,omitempty"`
	SuspendTime *V0041Uint32NoValStruct         `json:"suspend_time,omitempty"`
	Timeouts    *struct {
		Resume  *V0041Uint16NoValStruct `json:"resume,omitempty"`
		Suspend *V0041Uint16NoValStruct `json:"suspend,omitempty"`
	} `json:"timeouts,omitempty"`
	Tres *struct {
		// BillingWeights TRESBillingWeights
		BillingWeights *string `json:"billing_weights,omitempty"`

		// Configured TRES
		Configured *string `json:"configured,omitempty"`
	} `json:"tres,omitempty"`
}

// V0041PartitionInfoMaximumsOversubscribeFlags defines model for V0041PartitionInfo.Maximums.Oversubscribe.Flags.
type V0041PartitionInfoMaximumsOversubscribeFlags string

// V0041PartitionInfoPartitionState defines model for V0041PartitionInfo.Partition.State.
type V0041PartitionInfoPartitionState string

// V0041PartitionInfoSelectType defines model for V0041PartitionInfo.SelectType.
type V0041PartitionInfoSelectType string

// V0041PartitionInfoMsg defines model for v0.0.41_partition_info_msg.
type V0041PartitionInfoMsg = []V0041PartitionInfo

// V0041ProcessExitCodeVerbose defines model for v0.0.41_process_exit_code_verbose.
type V0041ProcessExitCodeVerbose struct {
	ReturnCode *V0041Uint32NoValStruct `json:"return_code,omitempty"`
	Signal     *struct {
		Id *V0041Uint16NoValStruct `json:"id,omitempty"`

		// Name Signal sent to process
		Name *string `json:"name,omitempty"`
	} `json:"signal,omitempty"`

	// Status Status given by return code
	Status *[]V0041ProcessExitCodeVerboseStatus `json:"status,omitempty"`
}

// V0041ProcessExitCodeVerboseStatus defines model for V0041ProcessExitCodeVerbose.Status.
type V0041ProcessExitCodeVerboseStatus string

// V0041Qos defines model for v0.0.41_qos.
type V0041Qos struct {
	// Description Arbitrary description
	Description *string `json:"description,omitempty"`

	// Flags Flags, to avoid modifying current values specify NOT_SET
	Flags *[]V0041QosFlags `json:"flags,omitempty"`

	// Id Unique ID
	Id     *int32 `json:"id,omitempty"`
	Limits *struct {
		Factor *V0041Float64NoValStruct `json:"factor,omitempty"`

		// GraceTime GraceTime
		GraceTime *int32 `json:"grace_time,omitempty"`
		Max       *struct {
			Accruing *struct {
				Per *struct {
					Account *V0041Uint32NoValStruct `json:"account,omitempty"`
					User    *V0041Uint32NoValStruct `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"accruing,omitempty"`
			ActiveJobs *struct {
				Accruing *V0041Uint32NoValStruct `json:"accruing,omitempty"`
				Count    *V0041Uint32NoValStruct `json:"count,omitempty"`
			} `json:"active_jobs,omitempty"`
			Jobs *struct {
				ActiveJobs *struct {
					Per *struct {
						Account *V0041Uint32NoValStruct `json:"account,omitempty"`
						User    *V0041Uint32NoValStruct `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"active_jobs,omitempty"`
				Per *struct {
					Account *V0041Uint32NoValStruct `json:"account,omitempty"`
					User    *V0041Uint32NoValStruct `json:"user,omitempty"`
				} `json:"per,omitempty"`
			} `json:"jobs,omitempty"`
			Tres *struct {
				Minutes *struct {
					Per *struct {
						Account *V0041TresList `json:"account,omitempty"`
						Job     *V0041TresList `json:"job,omitempty"`
						Qos     *V0041TresList `json:"qos,omitempty"`
						User    *V0041TresList `json:"user,omitempty"`
					} `json:"per,omitempty"`
				} `json:"minutes,omitempty"`
				Per *struct {
					Account *V0041TresList `json:"account,omitempty"`
					Job     *V0041TresList `json:"job,omitempty"`
					Node    *V0041TresList `json:"node,omitempty"`
					User    *V0041TresList `json:"user,omitempty"`
				} `json:"per,omitempty"`
				Total *V0041TresList `json:"total,omitempty"`
			} `json:"tres,omitempty"`
			WallClock *struct {
				Per *struct {
					Job *V0041Uint32NoValStruct `json:"job,omitempty"`
					Qos *V0041Uint32NoValStruct `json:"qos,omitempty"`
				} `json:"per,omitempty"`
			} `json:"wall_clock,omitempty"`
		} `json:"max,omitempty"`
		Min *struct {
			PriorityThreshold *V0041Uint32NoValStruct `json:"priority_threshold,omitempty"`
			Tres              *struct {
				Per *struct {
					Job *V0041TresList `json:"job,omitempty"`
				} `json:"per,omitempty"`
			} `json:"tres,omitempty"`
		} `json:"min,omitempty"`
	} `json:"limits,omitempty"`

	// Name Name
	Name    *string `json:"name,omitempty"`
	Preempt *struct {
		ExemptTime *V0041Uint32NoValStruct `json:"exempt_time,omitempty"`
		List       *V0041QosPreemptList    `json:"list,omitempty"`

		// Mode PreemptMode
		Mode *[]V0041QosPreemptMode `json:"mode,omitempty"`
	} `json:"preempt,omitempty"`
	Priority       *V0041Uint32NoValStruct  `json:"priority,omitempty"`
	UsageFactor    *V0041Float64NoValStruct `json:"usage_factor,omitempty"`
	UsageThreshold *V0041Float64NoValStruct `json:"usage_threshold,omitempty"`
}

// V0041QosFlags defines model for V0041Qos.Flags.
type V0041QosFlags string

// V0041QosPreemptMode defines model for V0041Qos.Preempt.Mode.
type V0041QosPreemptMode string

// V0041QosList defines model for v0.0.41_qos_list.
type V0041QosList = []V0041Qos

// V0041QosPreemptList defines model for v0.0.41_qos_preempt_list.
type V0041QosPreemptList = []string

// V0041QosStringIdList List of QOS names
type V0041QosStringIdList = []string

// V0041ReservationCoreSpec defines model for v0.0.41_reservation_core_spec.
type V0041ReservationCoreSpec struct {
	// Core IDs of reserved cores
	Core *string `json:"core,omitempty"`

	// Node Name of reserved node
	Node *string `json:"node,omitempty"`
}

// V0041ReservationInfo defines model for v0.0.41_reservation_info.
type V0041ReservationInfo struct {
	// Accounts Comma separated list of permitted accounts
	Accounts *string `json:"accounts,omitempty"`

	// BurstBuffer BurstBuffer
	BurstBuffer *string `json:"burst_buffer,omitempty"`

	// CoreCount CoreCnt
	CoreCount           *int32                        `json:"core_count,omitempty"`
	CoreSpecializations *V0041ReservationInfoCoreSpec `json:"core_specializations,omitempty"`
	EndTime             *V0041Uint64NoValStruct       `json:"end_time,omitempty"`

	// Features Features
	Features *string `json:"features,omitempty"`

	// Flags Flags associated with the reservation
	Flags *[]V0041ReservationInfoFlags `json:"flags,omitempty"`

	// Groups Groups
	Groups *string `json:"groups,omitempty"`

	// Licenses Licenses
	Licenses *string `json:"licenses,omitempty"`

	// MaxStartDelay MaxStartDelay in seconds
	MaxStartDelay *int32 `json:"max_start_delay,omitempty"`

	// Name ReservationName
	Name *string `json:"name,omitempty"`

	// NodeCount NodeCnt
	NodeCount *int32 `json:"node_count,omitempty"`

	// NodeList Nodes
	NodeList *string `json:"node_list,omitempty"`

	// Partition PartitionName
	Partition      *string `json:"partition,omitempty"`
	PurgeCompleted *struct {
		Time *V0041Uint32NoValStruct `json:"time,omitempty"`
	} `json:"purge_completed,omitempty"`
	StartTime *V0041Uint64NoValStruct `json:"start_time,omitempty"`

	// Tres Comma separated list of required TRES
	Tres *string `json:"tres,omitempty"`

	// Users Comma separated list of permitted users
	Users *string                 `json:"users,omitempty"`
	Watts *V0041Uint32NoValStruct `json:"watts,omitempty"`
}

// V0041ReservationInfoFlags defines model for V0041ReservationInfo.Flags.
type V0041ReservationInfoFlags string

// V0041ReservationInfoCoreSpec defines model for v0.0.41_reservation_info_core_spec.
type V0041ReservationInfoCoreSpec = []V0041ReservationCoreSpec

// V0041ReservationInfoMsg defines model for v0.0.41_reservation_info_msg.
type V0041ReservationInfoMsg = []V0041ReservationInfo

// V0041RollupStats defines model for v0.0.41_rollup_stats.
type V0041RollupStats struct {
	Daily *struct {
		// Count Number of daily rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing daily daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest daily rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing daily rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time daily rollup ran (UNIX timestamp)
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"daily,omitempty"`
	Hourly *struct {
		// Count Number of hourly rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing last daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest hourly rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing hourly rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time hourly rollup ran (UNIX timestamp)
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"hourly,omitempty"`
	Monthly *struct {
		// Count Number of monthly rollups since last_run
		Count    *int32 `json:"count,omitempty"`
		Duration *struct {
			// Last Total time spent doing monthly daily rollup (seconds)
			Last *int64 `json:"last,omitempty"`

			// Max Longest monthly rollup time (seconds)
			Max *int64 `json:"max,omitempty"`

			// Time Total time spent doing monthly rollups (seconds)
			Time *int64 `json:"time,omitempty"`
		} `json:"duration,omitempty"`

		// LastRun Last time monthly rollup ran (UNIX timestamp)
		LastRun *int64 `json:"last_run,omitempty"`
	} `json:"monthly,omitempty"`
}

// V0041ScheduleExitFields defines model for v0.0.41_schedule_exit_fields.
type V0041ScheduleExitFields struct {
	// DefaultQueueDepth Reached number of jobs allowed to be tested
	DefaultQueueDepth *int32 `json:"default_queue_depth,omitempty"`

	// EndJobQueue Reached end of queue
	EndJobQueue *int32 `json:"end_job_queue,omitempty"`

	// Licenses Blocked on licenses
	Licenses *int32 `json:"licenses,omitempty"`

	// MaxJobStart Reached number of jobs allowed to start
	MaxJobStart *int32 `json:"max_job_start,omitempty"`

	// MaxRpcCnt Reached RPC limit
	MaxRpcCnt *int32 `json:"max_rpc_cnt,omitempty"`

	// MaxSchedTime Reached maximum allowed scheduler time
	MaxSchedTime *int32 `json:"max_sched_time,omitempty"`
}

// V0041SharesFloat128Tres defines model for v0.0.41_shares_float128_tres.
type V0041SharesFloat128Tres struct {
	// Name TRES name
	Name *string `json:"name,omitempty"`

	// Value TRES value
	Value *float32 `json:"value,omitempty"`
}

// V0041SharesFloat128TresList defines model for v0.0.41_shares_float128_tres_list.
type V0041SharesFloat128TresList = []V0041SharesFloat128Tres

// V0041SharesRespMsg defines model for v0.0.41_shares_resp_msg.
type V0041SharesRespMsg struct {
	Shares *V0041AssocSharesObjList `json:"shares,omitempty"`

	// TotalShares Total number of shares
	TotalShares *int64 `json:"total_shares,omitempty"`
}

// V0041SharesUint64Tres defines model for v0.0.41_shares_uint64_tres.
type V0041SharesUint64Tres struct {
	// Name TRES name
	Name  *string                 `json:"name,omitempty"`
	Value *V0041Uint64NoValStruct `json:"value,omitempty"`
}

// V0041SharesUint64TresList defines model for v0.0.41_shares_uint64_tres_list.
type V0041SharesUint64TresList = []V0041SharesUint64Tres

// V0041StatsMsg defines model for v0.0.41_stats_msg.
type V0041StatsMsg struct {
	// AgentCount Number of agent threads
	AgentCount *int32 `json:"agent_count,omitempty"`

	// AgentQueueSize Number of enqueued outgoing RPC requests in an internal retry list
	AgentQueueSize *int32 `json:"agent_queue_size,omitempty"`

	// AgentThreadCount Total number of active threads created by all agent threads
	AgentThreadCount *int32 `json:"agent_thread_count,omitempty"`

	// BfActive Backfill scheduler currently running
	BfActive *bool `json:"bf_active,omitempty"`

	// BfBackfilledHetJobs Number of heterogeneous job components started through backfilling since last Slurm start
	BfBackfilledHetJobs *int32 `json:"bf_backfilled_het_jobs,omitempty"`

	// BfBackfilledJobs Number of jobs started through backfilling since last slurm start
	BfBackfilledJobs *int32 `json:"bf_backfilled_jobs,omitempty"`

	// BfCycleCounter Number of backfill scheduling cycles since last reset
	BfCycleCounter *int32 `json:"bf_cycle_counter,omitempty"`

	// BfCycleLast Execution time in microseconds of last backfill scheduling cycle
	BfCycleLast *int32 `json:"bf_cycle_last,omitempty"`

	// BfCycleMax Execution time in microseconds of longest backfill scheduling cycle
	BfCycleMax *int32 `json:"bf_cycle_max,omitempty"`

	// BfCycleMean Mean time in microseconds of backfilling scheduling cycles since last reset
	BfCycleMean *int64 `json:"bf_cycle_mean,omitempty"`

	// BfCycleSum Total time in microseconds of backfilling scheduling cycles since last reset
	BfCycleSum *int64 `json:"bf_cycle_sum,omitempty"`

	// BfDepthMean Mean number of eligible to run jobs processed during all backfilling scheduling cycles since last reset
	BfDepthMean *int64 `json:"bf_depth_mean,omitempty"`

	// BfDepthMeanTry The subset of Depth Mean that the backfill scheduler attempted to schedule
	BfDepthMeanTry *int64 `json:"bf_depth_mean_try,omitempty"`

	// BfDepthSum Total number of jobs processed during all backfilling scheduling cycles since last reset
	BfDepthSum *int32 `json:"bf_depth_sum,omitempty"`

	// BfDepthTrySum Subset of bf_depth_sum that the backfill scheduler attempted to schedule
	BfDepthTrySum *int32             `json:"bf_depth_try_sum,omitempty"`
	BfExit        *V0041BfExitFields `json:"bf_exit,omitempty"`

	// BfLastBackfilledJobs Number of jobs started through backfilling since last reset
	BfLastBackfilledJobs *int32 `json:"bf_last_backfilled_jobs,omitempty"`

	// BfLastDepth Number of processed jobs during last backfilling scheduling cycle
	BfLastDepth *int32 `json:"bf_last_depth,omitempty"`

	// BfLastDepthTry Number of processed jobs during last backfilling scheduling cycle that had a chance to start using available resources
	BfLastDepthTry *int32 `json:"bf_last_depth_try,omitempty"`

	// BfQueueLen Number of jobs pending to be processed by backfilling algorithm
	BfQueueLen *int32 `json:"bf_queue_len,omitempty"`

	// BfQueueLenMean Mean number of jobs pending to be processed by backfilling algorithm
	BfQueueLenMean *int64 `json:"bf_queue_len_mean,omitempty"`

	// BfQueueLenSum Total number of jobs pending to be processed by backfilling algorithm since last reset
	BfQueueLenSum *int32 `json:"bf_queue_len_sum,omitempty"`

	// BfTableSize Number of different time slots tested by the backfill scheduler in its last iteration
	BfTableSize *int32 `json:"bf_table_size,omitempty"`

	// BfTableSizeMean Mean number of different time slots tested by the backfill scheduler
	BfTableSizeMean *int64 `json:"bf_table_size_mean,omitempty"`

	// BfTableSizeSum Total number of different time slots tested by the backfill scheduler
	BfTableSizeSum  *int32                  `json:"bf_table_size_sum,omitempty"`
	BfWhenLastCycle *V0041Uint64NoValStruct `json:"bf_when_last_cycle,omitempty"`

	// DbdAgentQueueSize Number of messages for SlurmDBD that are queued
	DbdAgentQueueSize *int32 `json:"dbd_agent_queue_size,omitempty"`

	// GettimeofdayLatency Latency of 1000 calls to the gettimeofday() syscall in microseconds, as measured at controller startup
	GettimeofdayLatency *int32                  `json:"gettimeofday_latency,omitempty"`
	JobStatesTs         *V0041Uint64NoValStruct `json:"job_states_ts,omitempty"`

	// JobsCanceled Number of jobs canceled since the last reset
	JobsCanceled *int32 `json:"jobs_canceled,omitempty"`

	// JobsCompleted Number of jobs completed since last reset
	JobsCompleted *int32 `json:"jobs_completed,omitempty"`

	// JobsFailed Number of jobs failed due to slurmd or other internal issues since last reset
	JobsFailed *int32 `json:"jobs_failed,omitempty"`

	// JobsPending Number of jobs pending at the time of listed in job_state_ts
	JobsPending *int32 `json:"jobs_pending,omitempty"`

	// JobsRunning Number of jobs running at the time of listed in job_state_ts
	JobsRunning *int32 `json:"jobs_running,omitempty"`

	// JobsStarted Number of jobs started since last reset
	JobsStarted *int32 `json:"jobs_started,omitempty"`

	// JobsSubmitted Number of jobs submitted since last reset
	JobsSubmitted *int32 `json:"jobs_submitted,omitempty"`

	// PartsPacked Zero if only RPC statistic included
	PartsPacked *int32 `json:"parts_packed,omitempty"`

	// PendingRpcs Pending RPCs
	PendingRpcs *V0041StatsMsgRpcsQueue `json:"pending_rpcs,omitempty"`

	// PendingRpcsByHostlist Pending RPCs by hostlist
	PendingRpcsByHostlist *V0041StatsMsgRpcsDump  `json:"pending_rpcs_by_hostlist,omitempty"`
	ReqTime               *V0041Uint64NoValStruct `json:"req_time,omitempty"`
	ReqTimeStart          *V0041Uint64NoValStruct `json:"req_time_start,omitempty"`

	// RpcsByMessageType RPCs by type
	RpcsByMessageType *V0041StatsMsgRpcsByType `json:"rpcs_by_message_type,omitempty"`

	// RpcsByUser RPCs by user
	RpcsByUser *V0041StatsMsgRpcsByUser `json:"rpcs_by_user,omitempty"`

	// ScheduleCycleDepth Total number of jobs processed in scheduling cycles
	ScheduleCycleDepth *int32 `json:"schedule_cycle_depth,omitempty"`

	// ScheduleCycleLast Time in microseconds for last scheduling cycle
	ScheduleCycleLast *int32 `json:"schedule_cycle_last,omitempty"`

	// ScheduleCycleMax Max time of any scheduling cycle in microseconds since last reset
	ScheduleCycleMax *int32 `json:"schedule_cycle_max,omitempty"`

	// ScheduleCycleMean Mean time in microseconds for all scheduling cycles since last reset
	ScheduleCycleMean *int64 `json:"schedule_cycle_mean,omitempty"`

	// ScheduleCycleMeanDepth Mean of the number of jobs processed in a scheduling cycle
	ScheduleCycleMeanDepth *int64 `json:"schedule_cycle_mean_depth,omitempty"`

	// ScheduleCyclePerMinute Number of scheduling executions per minute
	ScheduleCyclePerMinute *int64 `json:"schedule_cycle_per_minute,omitempty"`

	// ScheduleCycleSum Total run time in microseconds for all scheduling cycles since last reset
	ScheduleCycleSum *int32 `json:"schedule_cycle_sum,omitempty"`

	// ScheduleCycleTotal Number of scheduling cycles since last reset
	ScheduleCycleTotal *int32                   `json:"schedule_cycle_total,omitempty"`
	ScheduleExit       *V0041ScheduleExitFields `json:"schedule_exit,omitempty"`

	// ScheduleQueueLength Number of jobs pending in queue
	ScheduleQueueLength *int32 `json:"schedule_queue_length,omitempty"`

	// ServerThreadCount Number of current active slurmctld threads
	ServerThreadCount *int32 `json:"server_thread_count,omitempty"`
}

// V0041StatsMsgRpcDump defines model for v0.0.41_stats_msg_rpc_dump.
type V0041StatsMsgRpcDump struct {
	Count V0041HostlistString `json:"count"`

	// MessageType Message type as string
	MessageType string `json:"message_type"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0041StatsMsgRpcQueue defines model for v0.0.41_stats_msg_rpc_queue.
type V0041StatsMsgRpcQueue struct {
	// Count Number of pending RPCs queued
	Count int32 `json:"count"`

	// MessageType Message type as string
	MessageType string `json:"message_type"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0041StatsMsgRpcType defines model for v0.0.41_stats_msg_rpc_type.
type V0041StatsMsgRpcType struct {
	AverageTime V0041Uint64NoValStruct `json:"average_time"`

	// Count Number of RPCs received
	Count int32 `json:"count"`

	// CycleLast Number of RPCs processed within the last RPC queue cycle
	CycleLast int32 `json:"cycle_last"`

	// CycleMax Maximum number of RPCs processed within a RPC queue cycle since start
	CycleMax int32 `json:"cycle_max"`

	// Dropped Number of RPCs dropped
	Dropped int64 `json:"dropped"`

	// MessageType Message type as string
	MessageType string `json:"message_type"`

	// Queued Number of RPCs queued
	Queued int32 `json:"queued"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime int64 `json:"total_time"`

	// TypeId Message type as integer
	TypeId int32 `json:"type_id"`
}

// V0041StatsMsgRpcUser defines model for v0.0.41_stats_msg_rpc_user.
type V0041StatsMsgRpcUser struct {
	AverageTime V0041Uint64NoValStruct `json:"average_time"`

	// Count Number of RPCs received
	Count int32 `json:"count"`

	// TotalTime Total time spent processing RPC in seconds
	TotalTime int64 `json:"total_time"`

	// User User name
	User string `json:"user"`

	// UserId User ID (numeric)
	UserId int32 `json:"user_id"`
}

// V0041StatsMsgRpcsByType RPCs by type
type V0041StatsMsgRpcsByType = []V0041StatsMsgRpcType

// V0041StatsMsgRpcsByUser RPCs by user
type V0041StatsMsgRpcsByUser = []V0041StatsMsgRpcUser

// V0041StatsMsgRpcsDump Pending RPCs by hostlist
type V0041StatsMsgRpcsDump = []V0041StatsMsgRpcDump

// V0041StatsMsgRpcsQueue Pending RPCs
type V0041StatsMsgRpcsQueue = []V0041StatsMsgRpcQueue

// V0041StatsRec defines model for v0.0.41_stats_rec.
type V0041StatsRec struct {
	RPCs    *V0041StatsRpcList `json:"RPCs,omitempty"`
	Rollups *V0041RollupStats  `json:"rollups,omitempty"`

	// TimeStart When data collection started (UNIX timestamp)
	TimeStart *int64              `json:"time_start,omitempty"`
	Users     *V0041StatsUserList `json:"users,omitempty"`
}

// V0041StatsRpc defines model for v0.0.41_stats_rpc.
type V0041StatsRpc struct {
	// Count Number of RPCs processed
	Count *int32 `json:"count,omitempty"`

	// Rpc RPC type
	Rpc  *string `json:"rpc,omitempty"`
	Time *struct {
		// Average Average RPC processing time in microseconds
		Average *int64 `json:"average,omitempty"`

		// Total Total RPC processing time in microseconds
		Total *int64 `json:"total,omitempty"`
	} `json:"time,omitempty"`
}

// V0041StatsRpcList defines model for v0.0.41_stats_rpc_list.
type V0041StatsRpcList = []V0041StatsRpc

// V0041StatsUser defines model for v0.0.41_stats_user.
type V0041StatsUser struct {
	// Count Number of RPCs processed
	Count *int32 `json:"count,omitempty"`
	Time  *struct {
		// Average Average RPC processing time in microseconds
		Average *int64 `json:"average,omitempty"`

		// Total Total RPC processing time in microseconds
		Total *int64 `json:"total,omitempty"`
	} `json:"time,omitempty"`

	// User User ID
	User *string `json:"user,omitempty"`
}

// V0041StatsUserList defines model for v0.0.41_stats_user_list.
type V0041StatsUserList = []V0041StatsUser

// V0041Step defines model for v0.0.41_step.
type V0041Step struct {
	CPU *struct {
		// Governor Requested CPU frequency governor in kHz
		Governor           *string `json:"governor,omitempty"`
		RequestedFrequency *struct {
			Max *V0041Uint32NoValStruct `json:"max,omitempty"`
			Min *V0041Uint32NoValStruct `json:"min,omitempty"`
		} `json:"requested_frequency,omitempty"`
	} `json:"CPU,omitempty"`
	ExitCode *V0041ProcessExitCodeVerbose `json:"exit_code,omitempty"`

	// KillRequestUser User ID that requested termination of the step
	KillRequestUser *string `json:"kill_request_user,omitempty"`
	Nodes           *struct {
		// Count Number of nodes in the job step
		Count *int32         `json:"count,omitempty"`
		List  *V0041Hostlist `json:"list,omitempty"`

		// Range Node(s) allocated to the job step
		Range *string `json:"range,omitempty"`
	} `json:"nodes,omitempty"`

	// Pid Process ID
	Pid *string `json:"pid,omitempty"`

	// State Current state
	State      *[]V0041StepState `json:"state,omitempty"`
	Statistics *struct {
		CPU *struct {
			// ActualFrequency Average weighted CPU frequency of all tasks in kHz
			ActualFrequency *int64 `json:"actual_frequency,omitempty"`
		} `json:"CPU,omitempty"`
		Energy *struct {
			Consumed *V0041Uint64NoValStruct `json:"consumed,omitempty"`
		} `json:"energy,omitempty"`
	} `json:"statistics,omitempty"`
	Step *struct {
		// Id Step ID
		Id *string `json:"id,omitempty"`

		// Name Step name
		Name *string `json:"name,omitempty"`
	} `json:"step,omitempty"`
	Task *struct {
		// Distribution The layout of the step was when it was running
		Distribution *string `json:"distribution,omitempty"`
	} `json:"task,omitempty"`
	Tasks *struct {
		// Count Total number of tasks
		Count *int32 `json:"count,omitempty"`
	} `json:"tasks,omitempty"`
	Time *struct {
		// Elapsed Elapsed time in seconds
		Elapsed *int32                  `json:"elapsed,omitempty"`
		End     *V0041Uint64NoValStruct `json:"end,omitempty"`
		Start   *V0041Uint64NoValStruct `json:"start,omitempty"`

		// Suspended Time in suspended state in seconds
		Suspended *int32 `json:"suspended,omitempty"`
		System    *struct {
			// Microseconds System CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds System CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"system,omitempty"`
		Total *struct {
			// Microseconds Total CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds Total CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"total,omitempty"`
		User *struct {
			// Microseconds User CPU time used by the step in microseconds
			Microseconds *int32 `json:"microseconds,omitempty"`

			// Seconds User CPU time used by the step in seconds
			Seconds *int64 `json:"seconds,omitempty"`
		} `json:"user,omitempty"`
	} `json:"time,omitempty"`
	Tres *struct {
		Allocated *V0041TresList `json:"allocated,omitempty"`
		Consumed  *struct {
			Average *V0041TresList         `json:"average,omitempty"`
			Max     *V0041StepTresUsageMax `json:"max,omitempty"`
			Min     *V0041StepTresUsageMin `json:"min,omitempty"`
			Total   *V0041TresList         `json:"total,omitempty"`
		} `json:"consumed,omitempty"`
		Requested *struct {
			Average *V0041TresList       `json:"average,omitempty"`
			Max     *V0041StepTresReqMax `json:"max,omitempty"`
			Min     *V0041StepTresReqMin `json:"min,omitempty"`
			Total   *V0041TresList       `json:"total,omitempty"`
		} `json:"requested,omitempty"`
	} `json:"tres,omitempty"`
}

// V0041StepState defines model for V0041Step.State.
type V0041StepState string

// V0041StepList defines model for v0.0.41_step_list.
type V0041StepList = []V0041Step

// V0041StepTresReqMax defines model for v0.0.41_step_tres_req_max.
type V0041StepTresReqMax = []V0041Tres

// V0041StepTresReqMin defines model for v0.0.41_step_tres_req_min.
type V0041StepTresReqMin = []V0041Tres

// V0041StepTresUsageMax defines model for v0.0.41_step_tres_usage_max.
type V0041StepTresUsageMax = []V0041Tres

// V0041StepTresUsageMin defines model for v0.0.41_step_tres_usage_min.
type V0041StepTresUsageMin = []V0041Tres

// V0041StringArray defines model for v0.0.41_string_array.
type V0041StringArray = []string

// V0041StringList defines model for v0.0.41_string_list.
type V0041StringList = []string

// V0041Tres defines model for v0.0.41_tres.
type V0041Tres struct {
	// Count TRES count (0 if listed generically)
	Count *int64 `json:"count,omitempty"`

	// Id ID used in database
	Id *int32 `json:"id,omitempty"`

	// Name TRES name (if applicable)
	Name *string `json:"name,omitempty"`

	// Type TRES type (CPU, MEM, etc)
	Type string `json:"type"`
}

// V0041TresList defines model for v0.0.41_tres_list.
type V0041TresList = []V0041Tres

// V0041Uint16NoValStruct defines model for v0.0.41_uint16_no_val_struct.
type V0041Uint16NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int32 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0041Uint32NoValStruct defines model for v0.0.41_uint32_no_val_struct.
type V0041Uint32NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int32 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0041Uint64NoValStruct defines model for v0.0.41_uint64_no_val_struct.
type V0041Uint64NoValStruct struct {
	// Infinite True if number has been set to infinite; "set" and "number" will be ignored
	Infinite *bool `json:"infinite,omitempty"`

	// Number If "set" is True the number will be set with value; otherwise ignore number contents
	Number *int64 `json:"number,omitempty"`

	// Set True if number has been set; False if number is unset
	Set *bool `json:"set,omitempty"`
}

// V0041UpdateNodeMsg defines model for v0.0.41_update_node_msg.
type V0041UpdateNodeMsg struct {
	Address *V0041HostlistString `json:"address,omitempty"`

	// Comment Arbitrary comment
	Comment *string `json:"comment,omitempty"`

	// CpuBind Default method for binding tasks to allocated CPUs
	CpuBind *int32 `json:"cpu_bind,omitempty"`

	// Extra Arbitrary string used for node filtering if extra constraints are enabled
	Extra       *string         `json:"extra,omitempty"`
	Features    *V0041CsvString `json:"features,omitempty"`
	FeaturesAct *V0041CsvString `json:"features_act,omitempty"`

	// Gres Generic resources
	Gres     *string              `json:"gres,omitempty"`
	Hostname *V0041HostlistString `json:"hostname,omitempty"`
	Name     *V0041HostlistString `json:"name,omitempty"`

	// Reason Reason for node being DOWN or DRAINING
	Reason *string `json:"reason,omitempty"`

	// ReasonUid User ID to associate with the reason (needed if user root is sending message)
	ReasonUid   *string                 `json:"reason_uid,omitempty"`
	ResumeAfter *V0041Uint32NoValStruct `json:"resume_after,omitempty"`

	// State New state to assign to the node
	State  *[]V0041UpdateNodeMsgState `json:"state,omitempty"`
	Weight *V0041Uint32NoValStruct    `json:"weight,omitempty"`
}

// V0041UpdateNodeMsgState defines model for V0041UpdateNodeMsg.State.
type V0041UpdateNodeMsgState string

// V0041User defines model for v0.0.41_user.
type V0041User struct {
	// AdministratorLevel AdminLevel granted to the user
	AdministratorLevel *[]V0041UserAdministratorLevel `json:"administrator_level,omitempty"`
	Associations       *V0041AssocShortList           `json:"associations,omitempty"`
	Coordinators       *V0041CoordList                `json:"coordinators,omitempty"`
	Default            *struct {
		// Account Default Account
		Account *string `json:"account,omitempty"`

		// Wckey Default WCKey
		Wckey *string `json:"wckey,omitempty"`
	} `json:"default,omitempty"`

	// Flags Flags associated with user
	Flags *[]V0041UserFlags `json:"flags,omitempty"`

	// Name User name
	Name string `json:"name"`

	// OldName Previous user name
	OldName *string         `json:"old_name,omitempty"`
	Wckeys  *V0041WckeyList `json:"wckeys,omitempty"`
}

// V0041UserAdministratorLevel defines model for V0041User.AdministratorLevel.
type V0041UserAdministratorLevel string

// V0041UserFlags defines model for V0041User.Flags.
type V0041UserFlags string

// V0041UserList defines model for v0.0.41_user_list.
type V0041UserList = []V0041User

// V0041UserShort defines model for v0.0.41_user_short.
type V0041UserShort struct {
	// Adminlevel AdminLevel granted to the user
	Adminlevel *[]V0041UserShortAdminlevel `json:"adminlevel,omitempty"`

	// Defaultaccount Default account
	Defaultaccount *string `json:"defaultaccount,omitempty"`

	// Defaultwckey Default WCKey
	Defaultwckey *string `json:"defaultwckey,omitempty"`
}

// V0041UserShortAdminlevel defines model for V0041UserShort.Adminlevel.
type V0041UserShortAdminlevel string

// V0041UsersAddCond defines model for v0.0.41_users_add_cond.
type V0041UsersAddCond struct {
	Accounts    *V0041StringList  `json:"accounts,omitempty"`
	Association *V0041AssocRecSet `json:"association,omitempty"`
	Clusters    *V0041StringList  `json:"clusters,omitempty"`
	Partitions  *V0041StringList  `json:"partitions,omitempty"`
	Users       V0041StringList   `json:"users"`
	Wckeys      *V0041StringList  `json:"wckeys,omitempty"`
}

// V0041Wckey defines model for v0.0.41_wckey.
type V0041Wckey struct {
	Accounting *V0041AccountingList `json:"accounting,omitempty"`

	// Cluster Cluster name
	Cluster string `json:"cluster"`

	// Flags Flags associated with the WCKey
	Flags *[]V0041WckeyFlags `json:"flags,omitempty"`

	// Id Unique ID for this user-cluster-wckey combination
	Id *int32 `json:"id,omitempty"`

	// Name WCKey name
	Name string `json:"name"`

	// User User name
	User string `json:"user"`
}

// V0041WckeyFlags defines model for V0041Wckey.Flags.
type V0041WckeyFlags string

// V0041WckeyList defines model for v0.0.41_wckey_list.
type V0041WckeyList = []V0041Wckey

// V0041WckeyTagStruct defines model for v0.0.41_wckey_tag_struct.
type V0041WckeyTagStruct struct {
	// Flags Active flags
	Flags []V0041WckeyTagStructFlags `json:"flags"`

	// Wckey WCKey name
	Wckey string `json:"wckey"`
}

// V0041WckeyTagStructFlags defines model for V0041WckeyTagStruct.Flags.
type V0041WckeyTagStructFlags string

// SlurmV0041DeleteJobParams defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParams struct {
	// Signal Signal to send to Job
	Signal *string `form:"signal,omitempty" json:"signal,omitempty"`

	// Flags Signalling flags
	Flags *SlurmV0041DeleteJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041DeleteJobParamsFlags defines parameters for SlurmV0041DeleteJob.
type SlurmV0041DeleteJobParamsFlags string

// SlurmV0041GetJobParams defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobParamsFlags defines parameters for SlurmV0041GetJob.
type SlurmV0041GetJobParamsFlags string

// SlurmV0041GetJobsParams defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobsParamsFlags defines parameters for SlurmV0041GetJobs.
type SlurmV0041GetJobsParamsFlags string

// SlurmV0041GetJobsStateParams defines parameters for SlurmV0041GetJobsState.
type SlurmV0041GetJobsStateParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetJobsStateParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetJobsStateParamsFlags defines parameters for SlurmV0041GetJobsState.
type SlurmV0041GetJobsStateParamsFlags string

// SlurmV0041GetNodeParams defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodeParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodeParamsFlags defines parameters for SlurmV0041GetNode.
type SlurmV0041GetNodeParamsFlags string

// SlurmV0041GetNodesParams defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParams struct {
	// UpdateTime Filter jobs since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetNodesParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetNodesParamsFlags defines parameters for SlurmV0041GetNodes.
type SlurmV0041GetNodesParamsFlags string

// SlurmV0041GetPartitionParams defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionParamsFlags defines parameters for SlurmV0041GetPartition.
type SlurmV0041GetPartitionParamsFlags string

// SlurmV0041GetPartitionsParams defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmV0041GetPartitionsParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmV0041GetPartitionsParamsFlags defines parameters for SlurmV0041GetPartitions.
type SlurmV0041GetPartitionsParamsFlags string

// SlurmV0041GetReservationParams defines parameters for SlurmV0041GetReservation.
type SlurmV0041GetReservationParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetReservationsParams defines parameters for SlurmV0041GetReservations.
type SlurmV0041GetReservationsParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmV0041GetSharesParams defines parameters for SlurmV0041GetShares.
type SlurmV0041GetSharesParams struct {
	// Accounts Accounts to query
	Accounts *string `form:"accounts,omitempty" json:"accounts,omitempty"`

	// Users Users to query
	Users *string `form:"users,omitempty" json:"users,omitempty"`
}

// SlurmdbV0041GetAccountParams defines parameters for SlurmdbV0041GetAccount.
type SlurmdbV0041GetAccountParams struct {
	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted Include deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetAccountsParams defines parameters for SlurmdbV0041GetAccounts.
type SlurmdbV0041GetAccountsParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// DELETED include deleted associations
	DELETED *string `form:"DELETED,omitempty" json:"DELETED,omitempty"`

	// WithAssociations query includes associations
	WithAssociations *string `form:"WithAssociations,omitempty" json:"WithAssociations,omitempty"`

	// WithCoordinators query includes coordinators
	WithCoordinators *string `form:"WithCoordinators,omitempty" json:"WithCoordinators,omitempty"`

	// NoUsersAreCoords remove users as coordinators
	NoUsersAreCoords *string `form:"NoUsersAreCoords,omitempty" json:"NoUsersAreCoords,omitempty"`

	// UsersAreCoords users are coordinators
	UsersAreCoords *string `form:"UsersAreCoords,omitempty" json:"UsersAreCoords,omitempty"`
}

// SlurmdbV0041DeleteAssociationParams defines parameters for SlurmdbV0041DeleteAssociation.
type SlurmdbV0041DeleteAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationParams defines parameters for SlurmdbV0041GetAssociation.
type SlurmdbV0041GetAssociationParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteAssociationsParams defines parameters for SlurmdbV0041DeleteAssociations.
type SlurmdbV0041DeleteAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041GetAssociationsParams defines parameters for SlurmdbV0041GetAssociations.
type SlurmdbV0041GetAssociationsParams struct {
	// Account CSV accounts list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// DefaultQos CSV QOS list
	DefaultQos *string `form:"default_qos,omitempty" json:"default_qos,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// OnlyDefaults Filter to only defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// ParentAccount CSV names of parent account
	ParentAccount *string `form:"parent_account,omitempty" json:"parent_account,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted associations
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithRawQos Include a raw qos or delta_qos
	WithRawQos *string `form:"with_raw_qos,omitempty" json:"with_raw_qos,omitempty"`

	// WithSubAccts Include sub acct information
	WithSubAccts *string `form:"with_sub_accts,omitempty" json:"with_sub_accts,omitempty"`

	// WithoutParentInfo Exclude parent id/name
	WithoutParentInfo *string `form:"without_parent_info,omitempty" json:"without_parent_info,omitempty"`

	// WithoutParentLimits Exclude limits from parents
	WithoutParentLimits *string `form:"without_parent_limits,omitempty" json:"without_parent_limits,omitempty"`
}

// SlurmdbV0041DeleteClusterParams defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041DeleteClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041DeleteClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041DeleteClusterParamsClassification defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsClassification string

// SlurmdbV0041DeleteClusterParamsFlags defines parameters for SlurmdbV0041DeleteCluster.
type SlurmdbV0041DeleteClusterParamsFlags string

// SlurmdbV0041GetClusterParams defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParams struct {
	// Classification Type of machine
	Classification *SlurmdbV0041GetClusterParamsClassification `form:"classification,omitempty" json:"classification,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Federation CSV federation list
	Federation *string `form:"federation,omitempty" json:"federation,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041GetClusterParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// RpcVersion CSV RPC version list
	RpcVersion *string `form:"rpc_version,omitempty" json:"rpc_version,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// WithDeleted Include deleted clusters
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`
}

// SlurmdbV0041GetClusterParamsClassification defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsClassification string

// SlurmdbV0041GetClusterParamsFlags defines parameters for SlurmdbV0041GetCluster.
type SlurmdbV0041GetClusterParamsFlags string

// SlurmdbV0041GetClustersParams defines parameters for SlurmdbV0041GetClusters.
type SlurmdbV0041GetClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041PostClustersParams defines parameters for SlurmdbV0041PostClusters.
type SlurmdbV0041PostClustersParams struct {
	// UpdateTime Filter reservations since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`
}

// SlurmdbV0041GetInstanceParams defines parameters for SlurmdbV0041GetInstance.
type SlurmdbV0041GetInstanceParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetInstancesParams defines parameters for SlurmdbV0041GetInstances.
type SlurmdbV0041GetInstancesParams struct {
	// Cluster CSV clusters list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Extra CSV extra list
	Extra *string `form:"extra,omitempty" json:"extra,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// InstanceId CSV instance_id list
	InstanceId *string `form:"instance_id,omitempty" json:"instance_id,omitempty"`

	// InstanceType CSV instance_type list
	InstanceType *string `form:"instance_type,omitempty" json:"instance_type,omitempty"`

	// NodeList Ranged node string
	NodeList *string `form:"node_list,omitempty" json:"node_list,omitempty"`

	// TimeEnd Time end (UNIX timestamp)
	TimeEnd *string `form:"time_end,omitempty" json:"time_end,omitempty"`

	// TimeStart Time start (UNIX timestamp)
	TimeStart *string `form:"time_start,omitempty" json:"time_start,omitempty"`
}

// SlurmdbV0041GetJobsParams defines parameters for SlurmdbV0041GetJobs.
type SlurmdbV0041GetJobsParams struct {
	// Account CSV account list
	Account *string `form:"account,omitempty" json:"account,omitempty"`

	// Association CSV association list
	Association *string `form:"association,omitempty" json:"association,omitempty"`

	// Cluster CSV cluster list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Constraints CSV constraint list
	Constraints *string `form:"constraints,omitempty" json:"constraints,omitempty"`

	// SchedulerUnset Schedule bits not set
	SchedulerUnset *string `form:"scheduler_unset,omitempty" json:"scheduler_unset,omitempty"`

	// ScheduledOnSubmit Job was started on submit
	ScheduledOnSubmit *string `form:"scheduled_on_submit,omitempty" json:"scheduled_on_submit,omitempty"`

	// ScheduledByMain Job was started from main scheduler
	ScheduledByMain *string `form:"scheduled_by_main,omitempty" json:"scheduled_by_main,omitempty"`

	// ScheduledByBackfill Job was started from backfill
	ScheduledByBackfill *string `form:"scheduled_by_backfill,omitempty" json:"scheduled_by_backfill,omitempty"`

	// JobStarted Job start RPC was received
	JobStarted *string `form:"job_started,omitempty" json:"job_started,omitempty"`

	// ExitCode Job exit code (numeric)
	ExitCode *string `form:"exit_code,omitempty" json:"exit_code,omitempty"`

	// ShowDuplicates Include duplicate job entries
	ShowDuplicates *string `form:"show_duplicates,omitempty" json:"show_duplicates,omitempty"`

	// SkipSteps Exclude job step details
	SkipSteps *string `form:"skip_steps,omitempty" json:"skip_steps,omitempty"`

	// DisableTruncateUsageTime Do not truncate the time to usage_start and usage_end
	DisableTruncateUsageTime *string `form:"disable_truncate_usage_time,omitempty" json:"disable_truncate_usage_time,omitempty"`

	// WholeHetjob Include details on all hetjob components
	WholeHetjob *string `form:"whole_hetjob,omitempty" json:"whole_hetjob,omitempty"`

	// DisableWholeHetjob Only show details on specified hetjob components
	DisableWholeHetjob *string `form:"disable_whole_hetjob,omitempty" json:"disable_whole_hetjob,omitempty"`

	// DisableWaitForResult Tell dbd not to wait for the result
	DisableWaitForResult *string `form:"disable_wait_for_result,omitempty" json:"disable_wait_for_result,omitempty"`

	// UsageTimeAsSubmitTime Use usage_time as the submit_time of the job
	UsageTimeAsSubmitTime *string `form:"usage_time_as_submit_time,omitempty" json:"usage_time_as_submit_time,omitempty"`

	// ShowBatchScript Include job script
	ShowBatchScript *string `form:"show_batch_script,omitempty" json:"show_batch_script,omitempty"`

	// ShowJobEnvironment Include job environment
	ShowJobEnvironment *string `form:"show_job_environment,omitempty" json:"show_job_environment,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Groups CSV group list
	Groups *string `form:"groups,omitempty" json:"groups,omitempty"`

	// JobName CSV job name list
	JobName *string `form:"job_name,omitempty" json:"job_name,omitempty"`

	// Partition CSV partition name list
	Partition *string `form:"partition,omitempty" json:"partition,omitempty"`

	// Qos CSV QOS name list
	Qos *string `form:"qos,omitempty" json:"qos,omitempty"`

	// Reason CSV reason list
	Reason *string `form:"reason,omitempty" json:"reason,omitempty"`

	// Reservation CSV reservation name list
	Reservation *string `form:"reservation,omitempty" json:"reservation,omitempty"`

	// ReservationId CSV reservation ID list
	ReservationId *string `form:"reservation_id,omitempty" json:"reservation_id,omitempty"`

	// State CSV state list
	State *string `form:"state,omitempty" json:"state,omitempty"`

	// Step CSV step id list
	Step *string `form:"step,omitempty" json:"step,omitempty"`

	// EndTime Usage end (UNIX timestamp)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty"`

	// StartTime Usage start (UNIX timestamp)
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty"`

	// Node Ranged node string where jobs ran
	Node *string `form:"node,omitempty" json:"node,omitempty"`

	// Users CSV user name list
	Users *string `form:"users,omitempty" json:"users,omitempty"`

	// Wckey CSV wckey list
	Wckey *string `form:"wckey,omitempty" json:"wckey,omitempty"`
}

// SlurmdbV0041GetQosParams defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041GetQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetQosParamsPreemptMode defines parameters for SlurmdbV0041GetQos.
type SlurmdbV0041GetQosParamsPreemptMode string

// SlurmdbV0041PostQosParams defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParams struct {
	// Description CSV description list
	Description *string `form:"description,omitempty" json:"description,omitempty"`

	// Id CSV QOS id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Format CSV format list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Name CSV QOS name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// PreemptMode PreemptMode used when jobs in this QOS are preempted
	PreemptMode *SlurmdbV0041PostQosParamsPreemptMode `form:"preempt_mode,omitempty" json:"preempt_mode,omitempty"`

	// WithDeleted Include deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostQosParamsPreemptMode defines parameters for SlurmdbV0041PostQos.
type SlurmdbV0041PostQosParamsPreemptMode string

// SlurmdbV0041GetSingleQosParams defines parameters for SlurmdbV0041GetSingleQos.
type SlurmdbV0041GetSingleQosParams struct {
	// WithDeleted Query includes deleted QOS
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041GetUserParams defines parameters for SlurmdbV0041GetUser.
type SlurmdbV0041GetUserParams struct {
	// WithDeleted Include deleted users
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithAssocs Include associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords Include coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithWckeys Include wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`
}

// SlurmdbV0041GetUsersParams defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParams struct {
	// AdminLevel Administrator level
	AdminLevel *SlurmdbV0041GetUsersParamsAdminLevel `form:"admin_level,omitempty" json:"admin_level,omitempty"`

	// DefaultAccount CSV default account list
	DefaultAccount *string `form:"default_account,omitempty" json:"default_account,omitempty"`

	// DefaultWckey CSV default wckey list
	DefaultWckey *string `form:"default_wckey,omitempty" json:"default_wckey,omitempty"`

	// WithAssocs With associations
	WithAssocs *string `form:"with_assocs,omitempty" json:"with_assocs,omitempty"`

	// WithCoords With coordinators
	WithCoords *string `form:"with_coords,omitempty" json:"with_coords,omitempty"`

	// WithDeleted With deleted
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`

	// WithWckeys With wckeys
	WithWckeys *string `form:"with_wckeys,omitempty" json:"with_wckeys,omitempty"`

	// WithoutDefaults Exclude defaults
	WithoutDefaults *string `form:"without_defaults,omitempty" json:"without_defaults,omitempty"`
}

// SlurmdbV0041GetUsersParamsAdminLevel defines parameters for SlurmdbV0041GetUsers.
type SlurmdbV0041GetUsersParamsAdminLevel string

// SlurmdbV0041PostUsersAssociationParams defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParams struct {
	// UpdateTime Filter partitions since update timestamp
	UpdateTime *string `form:"update_time,omitempty" json:"update_time,omitempty"`

	// Flags Query flags
	Flags *SlurmdbV0041PostUsersAssociationParamsFlags `form:"flags,omitempty" json:"flags,omitempty"`
}

// SlurmdbV0041PostUsersAssociationParamsFlags defines parameters for SlurmdbV0041PostUsersAssociation.
type SlurmdbV0041PostUsersAssociationParamsFlags string

// SlurmdbV0041GetWckeysParams defines parameters for SlurmdbV0041GetWckeys.
type SlurmdbV0041GetWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format CSV format name list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmdbV0041PostWckeysParams defines parameters for SlurmdbV0041PostWckeys.
type SlurmdbV0041PostWckeysParams struct {
	// Cluster CSV cluster name list
	Cluster *string `form:"cluster,omitempty" json:"cluster,omitempty"`

	// Format CSV format name list
	Format *string `form:"format,omitempty" json:"format,omitempty"`

	// Id CSV id list
	Id *string `form:"id,omitempty" json:"id,omitempty"`

	// Name CSV name list
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// OnlyDefaults Only query defaults
	OnlyDefaults *string `form:"only_defaults,omitempty" json:"only_defaults,omitempty"`

	// UsageEnd Usage end (UNIX timestamp)
	UsageEnd *string `form:"usage_end,omitempty" json:"usage_end,omitempty"`

	// UsageStart Usage start (UNIX timestamp)
	UsageStart *string `form:"usage_start,omitempty" json:"usage_start,omitempty"`

	// User CSV user list
	User *string `form:"user,omitempty" json:"user,omitempty"`

	// WithUsage Include usage
	WithUsage *string `form:"with_usage,omitempty" json:"with_usage,omitempty"`

	// WithDeleted Include deleted wckeys
	WithDeleted *string `form:"with_deleted,omitempty" json:"with_deleted,omitempty"`
}

// SlurmV0041PostJobAllocateJSONRequestBody defines body for SlurmV0041PostJobAllocate for application/json ContentType.
type SlurmV0041PostJobAllocateJSONRequestBody = V0041JobAllocReq

// SlurmV0041PostJobSubmitJSONRequestBody defines body for SlurmV0041PostJobSubmit for application/json ContentType.
type SlurmV0041PostJobSubmitJSONRequestBody = V0041JobSubmitReq

// SlurmV0041PostJobJSONRequestBody defines body for SlurmV0041PostJob for application/json ContentType.
type SlurmV0041PostJobJSONRequestBody = V0041JobDescMsg

// SlurmV0041DeleteJobsJSONRequestBody defines body for SlurmV0041DeleteJobs for application/json ContentType.
type SlurmV0041DeleteJobsJSONRequestBody = V0041KillJobsMsg

// SlurmV0041PostNodeJSONRequestBody defines body for SlurmV0041PostNode for application/json ContentType.
type SlurmV0041PostNodeJSONRequestBody = V0041UpdateNodeMsg

// SlurmdbV0041PostAccountsJSONRequestBody defines body for SlurmdbV0041PostAccounts for application/json ContentType.
type SlurmdbV0041PostAccountsJSONRequestBody = V0041OpenapiAccountsResp

// SlurmdbV0041PostAccountsAssociationJSONRequestBody defines body for SlurmdbV0041PostAccountsAssociation for application/json ContentType.
type SlurmdbV0041PostAccountsAssociationJSONRequestBody = V0041OpenapiAccountsAddCondResp

// SlurmdbV0041PostAssociationsJSONRequestBody defines body for SlurmdbV0041PostAssociations for application/json ContentType.
type SlurmdbV0041PostAssociationsJSONRequestBody = V0041OpenapiAssocsResp

// SlurmdbV0041PostClustersJSONRequestBody defines body for SlurmdbV0041PostClusters for application/json ContentType.
type SlurmdbV0041PostClustersJSONRequestBody = V0041OpenapiClustersResp

// SlurmdbV0041PostConfigJSONRequestBody defines body for SlurmdbV0041PostConfig for application/json ContentType.
type SlurmdbV0041PostConfigJSONRequestBody = V0041OpenapiSlurmdbdConfigResp

// SlurmdbV0041PostQosJSONRequestBody defines body for SlurmdbV0041PostQos for application/json ContentType.
type SlurmdbV0041PostQosJSONRequestBody = V0041OpenapiSlurmdbdQosResp

// SlurmdbV0041PostTresJSONRequestBody defines body for SlurmdbV0041PostTres for application/json ContentType.
type SlurmdbV0041PostTresJSONRequestBody = V0041OpenapiTresResp

// SlurmdbV0041PostUsersJSONRequestBody defines body for SlurmdbV0041PostUsers for application/json ContentType.
type SlurmdbV0041PostUsersJSONRequestBody = V0041OpenapiUsersResp

// SlurmdbV0041PostUsersAssociationJSONRequestBody defines body for SlurmdbV0041PostUsersAssociation for application/json ContentType.
type SlurmdbV0041PostUsersAssociationJSONRequestBody = V0041OpenapiUsersAddCondResp

// SlurmdbV0041PostWckeysJSONRequestBody defines body for SlurmdbV0041PostWckeys for application/json ContentType.
type SlurmdbV0041PostWckeysJSONRequestBody = V0041OpenapiWckeyResp

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// SlurmV0041GetDiag request
	SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobAllocateWithBody request with any body
	SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobSubmitWithBody request with any body
	SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJob request
	SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJob request
	SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostJobWithBody request with any body
	SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteJobsWithBody request with any body
	SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobs request
	SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetJobsState request
	SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetLicenses request
	SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041DeleteNode request
	SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNode request
	SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041PostNodeWithBody request with any body
	SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetNodes request
	SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartition request
	SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPartitions request
	SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetPing request
	SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReconfigure request
	SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservation request
	SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetReservations request
	SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmV0041GetShares request
	SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAccount request
	SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccount request
	SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAccounts request
	SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsWithBody request with any body
	SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAccountsAssociationWithBody request with any body
	SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociation request
	SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociation request
	SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteAssociations request
	SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetAssociations request
	SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostAssociationsWithBody request with any body
	SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteCluster request
	SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetCluster request
	SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetClusters request
	SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostClustersWithBody request with any body
	SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetConfig request
	SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostConfigWithBody request with any body
	SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetDiag request
	SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstance request
	SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetInstances request
	SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJob request
	SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetJobs request
	SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetQos request
	SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostQosWithBody request with any body
	SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteSingleQos request
	SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetSingleQos request
	SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetTres request
	SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostTresWithBody request with any body
	SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteUser request
	SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUser request
	SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetUsers request
	SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersWithBody request with any body
	SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostUsersAssociationWithBody request with any body
	SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041DeleteWckey request
	SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckey request
	SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041GetWckeys request
	SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SlurmdbV0041PostWckeysWithBody request with any body
	SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) SlurmV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobAllocate(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobAllocateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmitWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobSubmit(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobSubmitRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJob(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJob(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobRequest(c.Server, jobId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJobWithBody(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequestWithBody(c.Server, jobId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostJob(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostJobRequest(c.Server, jobId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteJobs(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteJobsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobs(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetJobsState(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetJobsStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetLicenses(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetLicensesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041DeleteNode(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041DeleteNodeRequest(c.Server, nodeName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNode(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodeRequest(c.Server, nodeName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNodeWithBody(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequestWithBody(c.Server, nodeName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041PostNode(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041PostNodeRequest(c.Server, nodeName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetNodes(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetNodesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartition(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionRequest(c.Server, partitionName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPartitions(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPartitionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReconfigure(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReconfigureRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservation(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationRequest(c.Server, reservationName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetReservations(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetReservationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmV0041GetShares(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmV0041GetSharesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAccount(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAccountRequest(c.Server, accountName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccount(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountRequest(c.Server, accountName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAccounts(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccounts(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAccountsAssociation(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAccountsAssociationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociation(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociation(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteAssociations(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetAssociations(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetAssociationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociationsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostAssociations(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostAssociationsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteCluster(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetCluster(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClusterRequest(c.Server, clusterName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetClusters(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetClustersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClustersWithBody(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostClusters(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostClustersRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostConfig(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetDiag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetDiagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstance(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstanceRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetInstances(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetInstancesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJob(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobRequest(c.Server, jobId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetJobs(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetQos(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetQosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQosWithBody(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostQos(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostQosRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteSingleQos(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteSingleQosRequest(c.Server, qos)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetSingleQos(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetSingleQosRequest(c.Server, qos, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetTres(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetTresRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTresWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostTres(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostTresRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteUser(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteUserRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUser(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUserRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetUsers(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsers(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociationWithBody(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostUsersAssociation(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostUsersAssociationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041DeleteWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041DeleteWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckey(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeyRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041GetWckeys(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041GetWckeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeysWithBody(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SlurmdbV0041PostWckeys(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSlurmdbV0041PostWckeysRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewSlurmV0041GetDiagRequest generates requests for SlurmV0041GetDiag
func NewSlurmV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobAllocateRequest calls the generic SlurmV0041PostJobAllocate builder with application/json body
func NewSlurmV0041PostJobAllocateRequest(server string, body SlurmV0041PostJobAllocateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobAllocateRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobAllocateRequestWithBody generates requests for SlurmV0041PostJobAllocate with any type of body
func NewSlurmV0041PostJobAllocateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/allocate")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041PostJobSubmitRequest calls the generic SlurmV0041PostJobSubmit builder with application/json body
func NewSlurmV0041PostJobSubmitRequest(server string, body SlurmV0041PostJobSubmitJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobSubmitRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041PostJobSubmitRequestWithBody generates requests for SlurmV0041PostJobSubmit with any type of body
func NewSlurmV0041PostJobSubmitRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/submit")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobRequest generates requests for SlurmV0041DeleteJob
func NewSlurmV0041DeleteJobRequest(server string, jobId string, params *SlurmV0041DeleteJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Signal != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "signal", runtime.ParamLocationQuery, *params.Signal); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobRequest generates requests for SlurmV0041GetJob
func NewSlurmV0041GetJobRequest(server string, jobId string, params *SlurmV0041GetJobParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostJobRequest calls the generic SlurmV0041PostJob builder with application/json body
func NewSlurmV0041PostJobRequest(server string, jobId string, body SlurmV0041PostJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostJobRequestWithBody(server, jobId, "application/json", bodyReader)
}

// NewSlurmV0041PostJobRequestWithBody generates requests for SlurmV0041PostJob with any type of body
func NewSlurmV0041PostJobRequestWithBody(server string, jobId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041DeleteJobsRequest calls the generic SlurmV0041DeleteJobs builder with application/json body
func NewSlurmV0041DeleteJobsRequest(server string, body SlurmV0041DeleteJobsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041DeleteJobsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmV0041DeleteJobsRequestWithBody generates requests for SlurmV0041DeleteJobs with any type of body
func NewSlurmV0041DeleteJobsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetJobsRequest generates requests for SlurmV0041GetJobs
func NewSlurmV0041GetJobsRequest(server string, params *SlurmV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetJobsStateRequest generates requests for SlurmV0041GetJobsState
func NewSlurmV0041GetJobsStateRequest(server string, params *SlurmV0041GetJobsStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/jobs/state/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetLicensesRequest generates requests for SlurmV0041GetLicenses
func NewSlurmV0041GetLicensesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/licenses/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041DeleteNodeRequest generates requests for SlurmV0041DeleteNode
func NewSlurmV0041DeleteNodeRequest(server string, nodeName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetNodeRequest generates requests for SlurmV0041GetNode
func NewSlurmV0041GetNodeRequest(server string, nodeName string, params *SlurmV0041GetNodeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041PostNodeRequest calls the generic SlurmV0041PostNode builder with application/json body
func NewSlurmV0041PostNodeRequest(server string, nodeName string, body SlurmV0041PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmV0041PostNodeRequestWithBody(server, nodeName, "application/json", bodyReader)
}

// NewSlurmV0041PostNodeRequestWithBody generates requests for SlurmV0041PostNode with any type of body
func NewSlurmV0041PostNodeRequestWithBody(server string, nodeName string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "node_name", runtime.ParamLocationPath, nodeName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/node/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmV0041GetNodesRequest generates requests for SlurmV0041GetNodes
func NewSlurmV0041GetNodesRequest(server string, params *SlurmV0041GetNodesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/nodes/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPartitionRequest generates requests for SlurmV0041GetPartition
func NewSlurmV0041GetPartitionRequest(server string, partitionName string, params *SlurmV0041GetPartitionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "partition_name", runtime.ParamLocationPath, partitionName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partition/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPartitionsRequest generates requests for SlurmV0041GetPartitions
func NewSlurmV0041GetPartitionsRequest(server string, params *SlurmV0041GetPartitionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/partitions/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetPingRequest generates requests for SlurmV0041GetPing
func NewSlurmV0041GetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/ping/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReconfigureRequest generates requests for SlurmV0041GetReconfigure
func NewSlurmV0041GetReconfigureRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reconfigure/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationRequest generates requests for SlurmV0041GetReservation
func NewSlurmV0041GetReservationRequest(server string, reservationName string, params *SlurmV0041GetReservationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "reservation_name", runtime.ParamLocationPath, reservationName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservation/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetReservationsRequest generates requests for SlurmV0041GetReservations
func NewSlurmV0041GetReservationsRequest(server string, params *SlurmV0041GetReservationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/reservations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmV0041GetSharesRequest generates requests for SlurmV0041GetShares
func NewSlurmV0041GetSharesRequest(server string, params *SlurmV0041GetSharesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurm/v0.0.41/shares")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Accounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "accounts", runtime.ParamLocationQuery, *params.Accounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAccountRequest generates requests for SlurmdbV0041DeleteAccount
func NewSlurmdbV0041DeleteAccountRequest(server string, accountName string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountRequest generates requests for SlurmdbV0041GetAccount
func NewSlurmdbV0041GetAccountRequest(server string, accountName string, params *SlurmdbV0041GetAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "account_name", runtime.ParamLocationPath, accountName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/account/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAccountsRequest generates requests for SlurmdbV0041GetAccounts
func NewSlurmdbV0041GetAccountsRequest(server string, params *SlurmdbV0041GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DELETED != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "DELETED", runtime.ParamLocationQuery, *params.DELETED); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssociations != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithAssociations", runtime.ParamLocationQuery, *params.WithAssociations); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoordinators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "WithCoordinators", runtime.ParamLocationQuery, *params.WithCoordinators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoUsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "NoUsersAreCoords", runtime.ParamLocationQuery, *params.NoUsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsersAreCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "UsersAreCoords", runtime.ParamLocationQuery, *params.UsersAreCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAccountsRequest calls the generic SlurmdbV0041PostAccounts builder with application/json body
func NewSlurmdbV0041PostAccountsRequest(server string, body SlurmdbV0041PostAccountsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsRequestWithBody generates requests for SlurmdbV0041PostAccounts with any type of body
func NewSlurmdbV0041PostAccountsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostAccountsAssociationRequest calls the generic SlurmdbV0041PostAccountsAssociation builder with application/json body
func NewSlurmdbV0041PostAccountsAssociationRequest(server string, body SlurmdbV0041PostAccountsAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAccountsAssociationRequestWithBody generates requests for SlurmdbV0041PostAccountsAssociation with any type of body
func NewSlurmdbV0041PostAccountsAssociationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/accounts_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationRequest generates requests for SlurmdbV0041DeleteAssociation
func NewSlurmdbV0041DeleteAssociationRequest(server string, params *SlurmdbV0041DeleteAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationRequest generates requests for SlurmdbV0041GetAssociation
func NewSlurmdbV0041GetAssociationRequest(server string, params *SlurmdbV0041GetAssociationParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041DeleteAssociationsRequest generates requests for SlurmdbV0041DeleteAssociations
func NewSlurmdbV0041DeleteAssociationsRequest(server string, params *SlurmdbV0041DeleteAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetAssociationsRequest generates requests for SlurmdbV0041GetAssociations
func NewSlurmdbV0041GetAssociationsRequest(server string, params *SlurmdbV0041GetAssociationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_qos", runtime.ParamLocationQuery, *params.DefaultQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ParentAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "parent_account", runtime.ParamLocationQuery, *params.ParentAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithRawQos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_raw_qos", runtime.ParamLocationQuery, *params.WithRawQos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithSubAccts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_sub_accts", runtime.ParamLocationQuery, *params.WithSubAccts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentInfo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_info", runtime.ParamLocationQuery, *params.WithoutParentInfo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutParentLimits != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_parent_limits", runtime.ParamLocationQuery, *params.WithoutParentLimits); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostAssociationsRequest calls the generic SlurmdbV0041PostAssociations builder with application/json body
func NewSlurmdbV0041PostAssociationsRequest(server string, body SlurmdbV0041PostAssociationsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostAssociationsRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostAssociationsRequestWithBody generates requests for SlurmdbV0041PostAssociations with any type of body
func NewSlurmdbV0041PostAssociationsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/associations/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteClusterRequest generates requests for SlurmdbV0041DeleteCluster
func NewSlurmdbV0041DeleteClusterRequest(server string, clusterName string, params *SlurmdbV0041DeleteClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClusterRequest generates requests for SlurmdbV0041GetCluster
func NewSlurmdbV0041GetClusterRequest(server string, clusterName string, params *SlurmdbV0041GetClusterParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "cluster_name", runtime.ParamLocationPath, clusterName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/cluster/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Classification != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "classification", runtime.ParamLocationQuery, *params.Classification); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Federation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "federation", runtime.ParamLocationQuery, *params.Federation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RpcVersion != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "rpc_version", runtime.ParamLocationQuery, *params.RpcVersion); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetClustersRequest generates requests for SlurmdbV0041GetClusters
func NewSlurmdbV0041GetClustersRequest(server string, params *SlurmdbV0041GetClustersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostClustersRequest calls the generic SlurmdbV0041PostClusters builder with application/json body
func NewSlurmdbV0041PostClustersRequest(server string, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostClustersRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostClustersRequestWithBody generates requests for SlurmdbV0041PostClusters with any type of body
func NewSlurmdbV0041PostClustersRequestWithBody(server string, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/clusters/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetConfigRequest generates requests for SlurmdbV0041GetConfig
func NewSlurmdbV0041GetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostConfigRequest calls the generic SlurmdbV0041PostConfig builder with application/json body
func NewSlurmdbV0041PostConfigRequest(server string, body SlurmdbV0041PostConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostConfigRequestWithBody generates requests for SlurmdbV0041PostConfig with any type of body
func NewSlurmdbV0041PostConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041GetDiagRequest generates requests for SlurmdbV0041GetDiag
func NewSlurmdbV0041GetDiagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/diag/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstanceRequest generates requests for SlurmdbV0041GetInstance
func NewSlurmdbV0041GetInstanceRequest(server string, params *SlurmdbV0041GetInstanceParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instance/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetInstancesRequest generates requests for SlurmdbV0041GetInstances
func NewSlurmdbV0041GetInstancesRequest(server string, params *SlurmdbV0041GetInstancesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/instances/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Extra != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "extra", runtime.ParamLocationQuery, *params.Extra); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_id", runtime.ParamLocationQuery, *params.InstanceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.InstanceType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "instance_type", runtime.ParamLocationQuery, *params.InstanceType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NodeList != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node_list", runtime.ParamLocationQuery, *params.NodeList); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_end", runtime.ParamLocationQuery, *params.TimeEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TimeStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "time_start", runtime.ParamLocationQuery, *params.TimeStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobRequest generates requests for SlurmdbV0041GetJob
func NewSlurmdbV0041GetJobRequest(server string, jobId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "job_id", runtime.ParamLocationPath, jobId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/job/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetJobsRequest generates requests for SlurmdbV0041GetJobs
func NewSlurmdbV0041GetJobsRequest(server string, params *SlurmdbV0041GetJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/jobs/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Account != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "account", runtime.ParamLocationQuery, *params.Account); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Association != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "association", runtime.ParamLocationQuery, *params.Association); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Constraints != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "constraints", runtime.ParamLocationQuery, *params.Constraints); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SchedulerUnset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduler_unset", runtime.ParamLocationQuery, *params.SchedulerUnset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledOnSubmit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_on_submit", runtime.ParamLocationQuery, *params.ScheduledOnSubmit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByMain != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_main", runtime.ParamLocationQuery, *params.ScheduledByMain); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledByBackfill != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "scheduled_by_backfill", runtime.ParamLocationQuery, *params.ScheduledByBackfill); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobStarted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_started", runtime.ParamLocationQuery, *params.JobStarted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExitCode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "exit_code", runtime.ParamLocationQuery, *params.ExitCode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowDuplicates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_duplicates", runtime.ParamLocationQuery, *params.ShowDuplicates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipSteps != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "skip_steps", runtime.ParamLocationQuery, *params.SkipSteps); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableTruncateUsageTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_truncate_usage_time", runtime.ParamLocationQuery, *params.DisableTruncateUsageTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "whole_hetjob", runtime.ParamLocationQuery, *params.WholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWholeHetjob != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_whole_hetjob", runtime.ParamLocationQuery, *params.DisableWholeHetjob); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DisableWaitForResult != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "disable_wait_for_result", runtime.ParamLocationQuery, *params.DisableWaitForResult); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageTimeAsSubmitTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_time_as_submit_time", runtime.ParamLocationQuery, *params.UsageTimeAsSubmitTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowBatchScript != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_batch_script", runtime.ParamLocationQuery, *params.ShowBatchScript); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowJobEnvironment != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "show_job_environment", runtime.ParamLocationQuery, *params.ShowJobEnvironment); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "groups", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "job_name", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Partition != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "partition", runtime.ParamLocationQuery, *params.Partition); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Qos != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "qos", runtime.ParamLocationQuery, *params.Qos); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reason != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reason", runtime.ParamLocationQuery, *params.Reason); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Reservation != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation", runtime.ParamLocationQuery, *params.Reservation); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReservationId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "reservation_id", runtime.ParamLocationQuery, *params.ReservationId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Step != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "step", runtime.ParamLocationQuery, *params.Step); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "end_time", runtime.ParamLocationQuery, *params.EndTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "start_time", runtime.ParamLocationQuery, *params.StartTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Node != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "node", runtime.ParamLocationQuery, *params.Node); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Users != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "users", runtime.ParamLocationQuery, *params.Users); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Wckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "wckey", runtime.ParamLocationQuery, *params.Wckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetQosRequest generates requests for SlurmdbV0041GetQos
func NewSlurmdbV0041GetQosRequest(server string, params *SlurmdbV0041GetQosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostQosRequest calls the generic SlurmdbV0041PostQos builder with application/json body
func NewSlurmdbV0041PostQosRequest(server string, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostQosRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostQosRequestWithBody generates requests for SlurmdbV0041PostQos with any type of body
func NewSlurmdbV0041PostQosRequestWithBody(server string, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Description != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "description", runtime.ParamLocationQuery, *params.Description); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PreemptMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "preempt_mode", runtime.ParamLocationQuery, *params.PreemptMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteSingleQosRequest generates requests for SlurmdbV0041DeleteSingleQos
func NewSlurmdbV0041DeleteSingleQosRequest(server string, qos string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetSingleQosRequest generates requests for SlurmdbV0041GetSingleQos
func NewSlurmdbV0041GetSingleQosRequest(server string, qos string, params *SlurmdbV0041GetSingleQosParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "qos", runtime.ParamLocationPath, qos)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/qos/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetTresRequest generates requests for SlurmdbV0041GetTres
func NewSlurmdbV0041GetTresRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostTresRequest calls the generic SlurmdbV0041PostTres builder with application/json body
func NewSlurmdbV0041PostTresRequest(server string, body SlurmdbV0041PostTresJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostTresRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostTresRequestWithBody generates requests for SlurmdbV0041PostTres with any type of body
func NewSlurmdbV0041PostTresRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/tres/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteUserRequest generates requests for SlurmdbV0041DeleteUser
func NewSlurmdbV0041DeleteUserRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUserRequest generates requests for SlurmdbV0041GetUser
func NewSlurmdbV0041GetUserRequest(server string, name string, params *SlurmdbV0041GetUserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetUsersRequest generates requests for SlurmdbV0041GetUsers
func NewSlurmdbV0041GetUsersRequest(server string, params *SlurmdbV0041GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AdminLevel != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "admin_level", runtime.ParamLocationQuery, *params.AdminLevel); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultAccount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_account", runtime.ParamLocationQuery, *params.DefaultAccount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DefaultWckey != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "default_wckey", runtime.ParamLocationQuery, *params.DefaultWckey); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAssocs != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_assocs", runtime.ParamLocationQuery, *params.WithAssocs); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithCoords != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_coords", runtime.ParamLocationQuery, *params.WithCoords); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithWckeys != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_wckeys", runtime.ParamLocationQuery, *params.WithWckeys); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithoutDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "without_defaults", runtime.ParamLocationQuery, *params.WithoutDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostUsersRequest calls the generic SlurmdbV0041PostUsers builder with application/json body
func NewSlurmdbV0041PostUsersRequest(server string, body SlurmdbV0041PostUsersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersRequestWithBody(server, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersRequestWithBody generates requests for SlurmdbV0041PostUsers with any type of body
func NewSlurmdbV0041PostUsersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041PostUsersAssociationRequest calls the generic SlurmdbV0041PostUsersAssociation builder with application/json body
func NewSlurmdbV0041PostUsersAssociationRequest(server string, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostUsersAssociationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostUsersAssociationRequestWithBody generates requests for SlurmdbV0041PostUsersAssociation with any type of body
func NewSlurmdbV0041PostUsersAssociationRequestWithBody(server string, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/users_association/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "update_time", runtime.ParamLocationQuery, *params.UpdateTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Flags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "flags", runtime.ParamLocationQuery, *params.Flags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSlurmdbV0041DeleteWckeyRequest generates requests for SlurmdbV0041DeleteWckey
func NewSlurmdbV0041DeleteWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeyRequest generates requests for SlurmdbV0041GetWckey
func NewSlurmdbV0041GetWckeyRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckey/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041GetWckeysRequest generates requests for SlurmdbV0041GetWckeys
func NewSlurmdbV0041GetWckeysRequest(server string, params *SlurmdbV0041GetWckeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSlurmdbV0041PostWckeysRequest calls the generic SlurmdbV0041PostWckeys builder with application/json body
func NewSlurmdbV0041PostWckeysRequest(server string, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSlurmdbV0041PostWckeysRequestWithBody(server, params, "application/json", bodyReader)
}

// NewSlurmdbV0041PostWckeysRequestWithBody generates requests for SlurmdbV0041PostWckeys with any type of body
func NewSlurmdbV0041PostWckeysRequestWithBody(server string, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/slurmdb/v0.0.41/wckeys/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cluster != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "cluster", runtime.ParamLocationQuery, *params.Cluster); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OnlyDefaults != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "only_defaults", runtime.ParamLocationQuery, *params.OnlyDefaults); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageEnd != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_end", runtime.ParamLocationQuery, *params.UsageEnd); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UsageStart != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "usage_start", runtime.ParamLocationQuery, *params.UsageStart); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithUsage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_usage", runtime.ParamLocationQuery, *params.WithUsage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithDeleted != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "with_deleted", runtime.ParamLocationQuery, *params.WithDeleted); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// SlurmV0041GetDiagWithResponse request
	SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error)

	// SlurmV0041PostJobAllocateWithBodyWithResponse request with any body
	SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error)

	// SlurmV0041PostJobSubmitWithBodyWithResponse request with any body
	SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error)

	// SlurmV0041DeleteJobWithResponse request
	SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error)

	// SlurmV0041GetJobWithResponse request
	SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error)

	// SlurmV0041PostJobWithBodyWithResponse request with any body
	SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error)

	// SlurmV0041DeleteJobsWithBodyWithResponse request with any body
	SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error)

	// SlurmV0041GetJobsWithResponse request
	SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error)

	// SlurmV0041GetJobsStateWithResponse request
	SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error)

	// SlurmV0041GetLicensesWithResponse request
	SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error)

	// SlurmV0041DeleteNodeWithResponse request
	SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error)

	// SlurmV0041GetNodeWithResponse request
	SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error)

	// SlurmV0041PostNodeWithBodyWithResponse request with any body
	SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error)

	// SlurmV0041GetNodesWithResponse request
	SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error)

	// SlurmV0041GetPartitionWithResponse request
	SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error)

	// SlurmV0041GetPartitionsWithResponse request
	SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error)

	// SlurmV0041GetPingWithResponse request
	SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error)

	// SlurmV0041GetReconfigureWithResponse request
	SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error)

	// SlurmV0041GetReservationWithResponse request
	SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error)

	// SlurmV0041GetReservationsWithResponse request
	SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error)

	// SlurmV0041GetSharesWithResponse request
	SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error)

	// SlurmdbV0041DeleteAccountWithResponse request
	SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error)

	// SlurmdbV0041GetAccountWithResponse request
	SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error)

	// SlurmdbV0041GetAccountsWithResponse request
	SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error)

	// SlurmdbV0041PostAccountsWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error)

	// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationWithResponse request
	SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error)

	// SlurmdbV0041GetAssociationWithResponse request
	SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error)

	// SlurmdbV0041DeleteAssociationsWithResponse request
	SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error)

	// SlurmdbV0041GetAssociationsWithResponse request
	SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error)

	// SlurmdbV0041PostAssociationsWithBodyWithResponse request with any body
	SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error)

	// SlurmdbV0041DeleteClusterWithResponse request
	SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error)

	// SlurmdbV0041GetClusterWithResponse request
	SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error)

	// SlurmdbV0041GetClustersWithResponse request
	SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error)

	// SlurmdbV0041PostClustersWithBodyWithResponse request with any body
	SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error)

	// SlurmdbV0041GetConfigWithResponse request
	SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error)

	// SlurmdbV0041PostConfigWithBodyWithResponse request with any body
	SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error)

	// SlurmdbV0041GetDiagWithResponse request
	SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error)

	// SlurmdbV0041GetInstanceWithResponse request
	SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error)

	// SlurmdbV0041GetInstancesWithResponse request
	SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error)

	// SlurmdbV0041GetJobWithResponse request
	SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error)

	// SlurmdbV0041GetJobsWithResponse request
	SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error)

	// SlurmdbV0041GetQosWithResponse request
	SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error)

	// SlurmdbV0041PostQosWithBodyWithResponse request with any body
	SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error)

	// SlurmdbV0041DeleteSingleQosWithResponse request
	SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error)

	// SlurmdbV0041GetSingleQosWithResponse request
	SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error)

	// SlurmdbV0041GetTresWithResponse request
	SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error)

	// SlurmdbV0041PostTresWithBodyWithResponse request with any body
	SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error)

	// SlurmdbV0041DeleteUserWithResponse request
	SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error)

	// SlurmdbV0041GetUserWithResponse request
	SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error)

	// SlurmdbV0041GetUsersWithResponse request
	SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error)

	// SlurmdbV0041PostUsersWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error)

	// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with any body
	SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error)

	// SlurmdbV0041DeleteWckeyWithResponse request
	SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error)

	// SlurmdbV0041GetWckeyWithResponse request
	SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error)

	// SlurmdbV0041GetWckeysWithResponse request
	SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error)

	// SlurmdbV0041PostWckeysWithBodyWithResponse request with any body
	SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)

	SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error)
}

type SlurmV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiDiagResp
	JSONDefault  *V0041OpenapiDiagResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobAllocateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobAllocResp
	JSONDefault  *V0041OpenapiJobAllocResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobAllocateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobAllocateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobSubmitResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobSubmitResponse
	JSONDefault  *V0041OpenapiJobSubmitResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobSubmitResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobSubmitResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobPostResponse
	JSONDefault  *V0041OpenapiJobPostResponse
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiKillJobsResp
	JSONDefault  *V0041OpenapiKillJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetJobsStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiJobInfoResp
	JSONDefault  *V0041OpenapiJobInfoResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetJobsStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetJobsStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetLicensesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiLicensesResp
	JSONDefault  *V0041OpenapiLicensesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetLicensesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetLicensesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041DeleteNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041DeleteNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041DeleteNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiNodesResp
	JSONDefault  *V0041OpenapiNodesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPartitionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPartitionResp
	JSONDefault  *V0041OpenapiPartitionResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPartitionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPartitionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiPingArrayResp
	JSONDefault  *V0041OpenapiPingArrayResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReconfigureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReconfigureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReconfigureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetReservationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiReservationResp
	JSONDefault  *V0041OpenapiReservationResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetReservationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetReservationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmV0041GetSharesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSharesResp
	JSONDefault  *V0041OpenapiSharesResp
}

// Status returns HTTPResponse.Status
func (r SlurmV0041GetSharesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmV0041GetSharesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsRemovedResp
	JSONDefault  *V0041OpenapiAccountsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsResp
	JSONDefault  *V0041OpenapiAccountsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAccountsAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAccountsAddCondRespStr
	JSONDefault  *V0041OpenapiAccountsAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAccountsAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAccountsAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsRemovedResp
	JSONDefault  *V0041OpenapiAssocsRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiAssocsResp
	JSONDefault  *V0041OpenapiAssocsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostAssociationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostAssociationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostAssociationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersRemovedResp
	JSONDefault  *V0041OpenapiClustersRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClusterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClusterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClusterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiClustersResp
	JSONDefault  *V0041OpenapiClustersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostClustersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostClustersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostClustersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdConfigResp
	JSONDefault  *V0041OpenapiSlurmdbdConfigResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetDiagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdStatsResp
	JSONDefault  *V0041OpenapiSlurmdbdStatsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetDiagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetDiagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetInstancesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiInstancesResp
	JSONDefault  *V0041OpenapiInstancesResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetInstancesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetInstancesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdJobsResp
	JSONDefault  *V0041OpenapiSlurmdbdJobsResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosRemovedResp
	JSONDefault  *V0041OpenapiSlurmdbdQosRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetSingleQosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiSlurmdbdQosResp
	JSONDefault  *V0041OpenapiSlurmdbdQosResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetSingleQosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetSingleQosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiTresResp
	JSONDefault  *V0041OpenapiTresResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostTresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostTresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostTresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersResp
	JSONDefault  *V0041OpenapiUsersResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostUsersAssociationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiUsersAddCondRespStr
	JSONDefault  *V0041OpenapiUsersAddCondRespStr
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostUsersAssociationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostUsersAssociationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041DeleteWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyRemovedResp
	JSONDefault  *V0041OpenapiWckeyRemovedResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041DeleteWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041DeleteWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041GetWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiWckeyResp
	JSONDefault  *V0041OpenapiWckeyResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041GetWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041GetWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SlurmdbV0041PostWckeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *V0041OpenapiResp
	JSONDefault  *V0041OpenapiResp
}

// Status returns HTTPResponse.Status
func (r SlurmdbV0041PostWckeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SlurmdbV0041PostWckeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// SlurmV0041GetDiagWithResponse request returning *SlurmV0041GetDiagResponse
func (c *ClientWithResponses) SlurmV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetDiagResponse, error) {
	rsp, err := c.SlurmV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetDiagResponse(rsp)
}

// SlurmV0041PostJobAllocateWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobAllocateResponse
func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobAllocateWithResponse(ctx context.Context, body SlurmV0041PostJobAllocateJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobAllocateResponse, error) {
	rsp, err := c.SlurmV0041PostJobAllocate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobAllocateResponse(rsp)
}

// SlurmV0041PostJobSubmitWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobSubmitResponse
func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmitWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobSubmitWithResponse(ctx context.Context, body SlurmV0041PostJobSubmitJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobSubmitResponse, error) {
	rsp, err := c.SlurmV0041PostJobSubmit(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobSubmitResponse(rsp)
}

// SlurmV0041DeleteJobWithResponse request returning *SlurmV0041DeleteJobResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041DeleteJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobResponse, error) {
	rsp, err := c.SlurmV0041DeleteJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobResponse(rsp)
}

// SlurmV0041GetJobWithResponse request returning *SlurmV0041GetJobResponse
func (c *ClientWithResponses) SlurmV0041GetJobWithResponse(ctx context.Context, jobId string, params *SlurmV0041GetJobParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobResponse, error) {
	rsp, err := c.SlurmV0041GetJob(ctx, jobId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobResponse(rsp)
}

// SlurmV0041PostJobWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostJobResponse
func (c *ClientWithResponses) SlurmV0041PostJobWithBodyWithResponse(ctx context.Context, jobId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJobWithBody(ctx, jobId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostJobWithResponse(ctx context.Context, jobId string, body SlurmV0041PostJobJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostJobResponse, error) {
	rsp, err := c.SlurmV0041PostJob(ctx, jobId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostJobResponse(rsp)
}

// SlurmV0041DeleteJobsWithBodyWithResponse request with arbitrary body returning *SlurmV0041DeleteJobsResponse
func (c *ClientWithResponses) SlurmV0041DeleteJobsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041DeleteJobsWithResponse(ctx context.Context, body SlurmV0041DeleteJobsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteJobsResponse, error) {
	rsp, err := c.SlurmV0041DeleteJobs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteJobsResponse(rsp)
}

// SlurmV0041GetJobsWithResponse request returning *SlurmV0041GetJobsResponse
func (c *ClientWithResponses) SlurmV0041GetJobsWithResponse(ctx context.Context, params *SlurmV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsResponse, error) {
	rsp, err := c.SlurmV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsResponse(rsp)
}

// SlurmV0041GetJobsStateWithResponse request returning *SlurmV0041GetJobsStateResponse
func (c *ClientWithResponses) SlurmV0041GetJobsStateWithResponse(ctx context.Context, params *SlurmV0041GetJobsStateParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetJobsStateResponse, error) {
	rsp, err := c.SlurmV0041GetJobsState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetJobsStateResponse(rsp)
}

// SlurmV0041GetLicensesWithResponse request returning *SlurmV0041GetLicensesResponse
func (c *ClientWithResponses) SlurmV0041GetLicensesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetLicensesResponse, error) {
	rsp, err := c.SlurmV0041GetLicenses(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetLicensesResponse(rsp)
}

// SlurmV0041DeleteNodeWithResponse request returning *SlurmV0041DeleteNodeResponse
func (c *ClientWithResponses) SlurmV0041DeleteNodeWithResponse(ctx context.Context, nodeName string, reqEditors ...RequestEditorFn) (*SlurmV0041DeleteNodeResponse, error) {
	rsp, err := c.SlurmV0041DeleteNode(ctx, nodeName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041DeleteNodeResponse(rsp)
}

// SlurmV0041GetNodeWithResponse request returning *SlurmV0041GetNodeResponse
func (c *ClientWithResponses) SlurmV0041GetNodeWithResponse(ctx context.Context, nodeName string, params *SlurmV0041GetNodeParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodeResponse, error) {
	rsp, err := c.SlurmV0041GetNode(ctx, nodeName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodeResponse(rsp)
}

// SlurmV0041PostNodeWithBodyWithResponse request with arbitrary body returning *SlurmV0041PostNodeResponse
func (c *ClientWithResponses) SlurmV0041PostNodeWithBodyWithResponse(ctx context.Context, nodeName string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNodeWithBody(ctx, nodeName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

func (c *ClientWithResponses) SlurmV0041PostNodeWithResponse(ctx context.Context, nodeName string, body SlurmV0041PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmV0041PostNodeResponse, error) {
	rsp, err := c.SlurmV0041PostNode(ctx, nodeName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041PostNodeResponse(rsp)
}

// SlurmV0041GetNodesWithResponse request returning *SlurmV0041GetNodesResponse
func (c *ClientWithResponses) SlurmV0041GetNodesWithResponse(ctx context.Context, params *SlurmV0041GetNodesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetNodesResponse, error) {
	rsp, err := c.SlurmV0041GetNodes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetNodesResponse(rsp)
}

// SlurmV0041GetPartitionWithResponse request returning *SlurmV0041GetPartitionResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionWithResponse(ctx context.Context, partitionName string, params *SlurmV0041GetPartitionParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionResponse, error) {
	rsp, err := c.SlurmV0041GetPartition(ctx, partitionName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionResponse(rsp)
}

// SlurmV0041GetPartitionsWithResponse request returning *SlurmV0041GetPartitionsResponse
func (c *ClientWithResponses) SlurmV0041GetPartitionsWithResponse(ctx context.Context, params *SlurmV0041GetPartitionsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetPartitionsResponse, error) {
	rsp, err := c.SlurmV0041GetPartitions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPartitionsResponse(rsp)
}

// SlurmV0041GetPingWithResponse request returning *SlurmV0041GetPingResponse
func (c *ClientWithResponses) SlurmV0041GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetPingResponse, error) {
	rsp, err := c.SlurmV0041GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetPingResponse(rsp)
}

// SlurmV0041GetReconfigureWithResponse request returning *SlurmV0041GetReconfigureResponse
func (c *ClientWithResponses) SlurmV0041GetReconfigureWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmV0041GetReconfigureResponse, error) {
	rsp, err := c.SlurmV0041GetReconfigure(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReconfigureResponse(rsp)
}

// SlurmV0041GetReservationWithResponse request returning *SlurmV0041GetReservationResponse
func (c *ClientWithResponses) SlurmV0041GetReservationWithResponse(ctx context.Context, reservationName string, params *SlurmV0041GetReservationParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationResponse, error) {
	rsp, err := c.SlurmV0041GetReservation(ctx, reservationName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationResponse(rsp)
}

// SlurmV0041GetReservationsWithResponse request returning *SlurmV0041GetReservationsResponse
func (c *ClientWithResponses) SlurmV0041GetReservationsWithResponse(ctx context.Context, params *SlurmV0041GetReservationsParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetReservationsResponse, error) {
	rsp, err := c.SlurmV0041GetReservations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetReservationsResponse(rsp)
}

// SlurmV0041GetSharesWithResponse request returning *SlurmV0041GetSharesResponse
func (c *ClientWithResponses) SlurmV0041GetSharesWithResponse(ctx context.Context, params *SlurmV0041GetSharesParams, reqEditors ...RequestEditorFn) (*SlurmV0041GetSharesResponse, error) {
	rsp, err := c.SlurmV0041GetShares(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmV0041GetSharesResponse(rsp)
}

// SlurmdbV0041DeleteAccountWithResponse request returning *SlurmdbV0041DeleteAccountResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAccountWithResponse(ctx context.Context, accountName string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAccountResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAccount(ctx, accountName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAccountResponse(rsp)
}

// SlurmdbV0041GetAccountWithResponse request returning *SlurmdbV0041GetAccountResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountWithResponse(ctx context.Context, accountName string, params *SlurmdbV0041GetAccountParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccount(ctx, accountName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountResponse(rsp)
}

// SlurmdbV0041GetAccountsWithResponse request returning *SlurmdbV0041GetAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAccountsWithResponse(ctx context.Context, params *SlurmdbV0041GetAccountsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccounts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsResponse(rsp)
}

// SlurmdbV0041PostAccountsAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAccountsAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAccountsAssociationWithResponse(ctx context.Context, body SlurmdbV0041PostAccountsAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostAccountsAssociation(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAccountsAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationWithResponse request returning *SlurmdbV0041DeleteAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationResponse(rsp)
}

// SlurmdbV0041GetAssociationWithResponse request returning *SlurmdbV0041GetAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociation(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationResponse(rsp)
}

// SlurmdbV0041DeleteAssociationsWithResponse request returning *SlurmdbV0041DeleteAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041DeleteAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteAssociationsResponse(rsp)
}

// SlurmdbV0041GetAssociationsWithResponse request returning *SlurmdbV0041GetAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041GetAssociationsWithResponse(ctx context.Context, params *SlurmdbV0041GetAssociationsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041GetAssociations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetAssociationsResponse(rsp)
}

// SlurmdbV0041PostAssociationsWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostAssociationsResponse
func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociationsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostAssociationsWithResponse(ctx context.Context, body SlurmdbV0041PostAssociationsJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostAssociationsResponse, error) {
	rsp, err := c.SlurmdbV0041PostAssociations(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostAssociationsResponse(rsp)
}

// SlurmdbV0041DeleteClusterWithResponse request returning *SlurmdbV0041DeleteClusterResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041DeleteClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteClusterResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteClusterResponse(rsp)
}

// SlurmdbV0041GetClusterWithResponse request returning *SlurmdbV0041GetClusterResponse
func (c *ClientWithResponses) SlurmdbV0041GetClusterWithResponse(ctx context.Context, clusterName string, params *SlurmdbV0041GetClusterParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClusterResponse, error) {
	rsp, err := c.SlurmdbV0041GetCluster(ctx, clusterName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClusterResponse(rsp)
}

// SlurmdbV0041GetClustersWithResponse request returning *SlurmdbV0041GetClustersResponse
func (c *ClientWithResponses) SlurmdbV0041GetClustersWithResponse(ctx context.Context, params *SlurmdbV0041GetClustersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetClustersResponse, error) {
	rsp, err := c.SlurmdbV0041GetClusters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetClustersResponse(rsp)
}

// SlurmdbV0041PostClustersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostClustersResponse
func (c *ClientWithResponses) SlurmdbV0041PostClustersWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClustersWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostClustersWithResponse(ctx context.Context, params *SlurmdbV0041PostClustersParams, body SlurmdbV0041PostClustersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostClustersResponse, error) {
	rsp, err := c.SlurmdbV0041PostClusters(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostClustersResponse(rsp)
}

// SlurmdbV0041GetConfigWithResponse request returning *SlurmdbV0041GetConfigResponse
func (c *ClientWithResponses) SlurmdbV0041GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetConfigResponse, error) {
	rsp, err := c.SlurmdbV0041GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetConfigResponse(rsp)
}

// SlurmdbV0041PostConfigWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostConfigResponse
func (c *ClientWithResponses) SlurmdbV0041PostConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostConfigWithResponse(ctx context.Context, body SlurmdbV0041PostConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostConfigResponse, error) {
	rsp, err := c.SlurmdbV0041PostConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostConfigResponse(rsp)
}

// SlurmdbV0041GetDiagWithResponse request returning *SlurmdbV0041GetDiagResponse
func (c *ClientWithResponses) SlurmdbV0041GetDiagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetDiagResponse, error) {
	rsp, err := c.SlurmdbV0041GetDiag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetDiagResponse(rsp)
}

// SlurmdbV0041GetInstanceWithResponse request returning *SlurmdbV0041GetInstanceResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstanceWithResponse(ctx context.Context, params *SlurmdbV0041GetInstanceParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstanceResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstance(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstanceResponse(rsp)
}

// SlurmdbV0041GetInstancesWithResponse request returning *SlurmdbV0041GetInstancesResponse
func (c *ClientWithResponses) SlurmdbV0041GetInstancesWithResponse(ctx context.Context, params *SlurmdbV0041GetInstancesParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetInstancesResponse, error) {
	rsp, err := c.SlurmdbV0041GetInstances(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetInstancesResponse(rsp)
}

// SlurmdbV0041GetJobWithResponse request returning *SlurmdbV0041GetJobResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobWithResponse(ctx context.Context, jobId string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobResponse, error) {
	rsp, err := c.SlurmdbV0041GetJob(ctx, jobId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobResponse(rsp)
}

// SlurmdbV0041GetJobsWithResponse request returning *SlurmdbV0041GetJobsResponse
func (c *ClientWithResponses) SlurmdbV0041GetJobsWithResponse(ctx context.Context, params *SlurmdbV0041GetJobsParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetJobsResponse, error) {
	rsp, err := c.SlurmdbV0041GetJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetJobsResponse(rsp)
}

// SlurmdbV0041GetQosWithResponse request returning *SlurmdbV0041GetQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetQosWithResponse(ctx context.Context, params *SlurmdbV0041GetQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetQos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetQosResponse(rsp)
}

// SlurmdbV0041PostQosWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostQosResponse
func (c *ClientWithResponses) SlurmdbV0041PostQosWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQosWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostQosWithResponse(ctx context.Context, params *SlurmdbV0041PostQosParams, body SlurmdbV0041PostQosJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostQosResponse, error) {
	rsp, err := c.SlurmdbV0041PostQos(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostQosResponse(rsp)
}

// SlurmdbV0041DeleteSingleQosWithResponse request returning *SlurmdbV0041DeleteSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteSingleQosWithResponse(ctx context.Context, qos string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteSingleQos(ctx, qos, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteSingleQosResponse(rsp)
}

// SlurmdbV0041GetSingleQosWithResponse request returning *SlurmdbV0041GetSingleQosResponse
func (c *ClientWithResponses) SlurmdbV0041GetSingleQosWithResponse(ctx context.Context, qos string, params *SlurmdbV0041GetSingleQosParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetSingleQosResponse, error) {
	rsp, err := c.SlurmdbV0041GetSingleQos(ctx, qos, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetSingleQosResponse(rsp)
}

// SlurmdbV0041GetTresWithResponse request returning *SlurmdbV0041GetTresResponse
func (c *ClientWithResponses) SlurmdbV0041GetTresWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetTresResponse, error) {
	rsp, err := c.SlurmdbV0041GetTres(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetTresResponse(rsp)
}

// SlurmdbV0041PostTresWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostTresResponse
func (c *ClientWithResponses) SlurmdbV0041PostTresWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTresWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostTresWithResponse(ctx context.Context, body SlurmdbV0041PostTresJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostTresResponse, error) {
	rsp, err := c.SlurmdbV0041PostTres(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostTresResponse(rsp)
}

// SlurmdbV0041DeleteUserWithResponse request returning *SlurmdbV0041DeleteUserResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteUserWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteUserResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteUser(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteUserResponse(rsp)
}

// SlurmdbV0041GetUserWithResponse request returning *SlurmdbV0041GetUserResponse
func (c *ClientWithResponses) SlurmdbV0041GetUserWithResponse(ctx context.Context, name string, params *SlurmdbV0041GetUserParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUserResponse, error) {
	rsp, err := c.SlurmdbV0041GetUser(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUserResponse(rsp)
}

// SlurmdbV0041GetUsersWithResponse request returning *SlurmdbV0041GetUsersResponse
func (c *ClientWithResponses) SlurmdbV0041GetUsersWithResponse(ctx context.Context, params *SlurmdbV0041GetUsersParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetUsersResponse, error) {
	rsp, err := c.SlurmdbV0041GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetUsersResponse(rsp)
}

// SlurmdbV0041PostUsersWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersWithResponse(ctx context.Context, body SlurmdbV0041PostUsersJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsers(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersResponse(rsp)
}

// SlurmdbV0041PostUsersAssociationWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostUsersAssociationResponse
func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostUsersAssociationWithResponse(ctx context.Context, params *SlurmdbV0041PostUsersAssociationParams, body SlurmdbV0041PostUsersAssociationJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	rsp, err := c.SlurmdbV0041PostUsersAssociation(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostUsersAssociationResponse(rsp)
}

// SlurmdbV0041DeleteWckeyWithResponse request returning *SlurmdbV0041DeleteWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041DeleteWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041DeleteWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041DeleteWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041DeleteWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeyWithResponse request returning *SlurmdbV0041GetWckeyResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeyWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeyResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckey(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeyResponse(rsp)
}

// SlurmdbV0041GetWckeysWithResponse request returning *SlurmdbV0041GetWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041GetWckeysWithResponse(ctx context.Context, params *SlurmdbV0041GetWckeysParams, reqEditors ...RequestEditorFn) (*SlurmdbV0041GetWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041GetWckeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041GetWckeysResponse(rsp)
}

// SlurmdbV0041PostWckeysWithBodyWithResponse request with arbitrary body returning *SlurmdbV0041PostWckeysResponse
func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithBodyWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeysWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

func (c *ClientWithResponses) SlurmdbV0041PostWckeysWithResponse(ctx context.Context, params *SlurmdbV0041PostWckeysParams, body SlurmdbV0041PostWckeysJSONRequestBody, reqEditors ...RequestEditorFn) (*SlurmdbV0041PostWckeysResponse, error) {
	rsp, err := c.SlurmdbV0041PostWckeys(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSlurmdbV0041PostWckeysResponse(rsp)
}

// ParseSlurmV0041GetDiagResponse parses an HTTP response from a SlurmV0041GetDiagWithResponse call
func ParseSlurmV0041GetDiagResponse(rsp *http.Response) (*SlurmV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiDiagResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobAllocateResponse parses an HTTP response from a SlurmV0041PostJobAllocateWithResponse call
func ParseSlurmV0041PostJobAllocateResponse(rsp *http.Response) (*SlurmV0041PostJobAllocateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobAllocateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobAllocResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobSubmitResponse parses an HTTP response from a SlurmV0041PostJobSubmitWithResponse call
func ParseSlurmV0041PostJobSubmitResponse(rsp *http.Response) (*SlurmV0041PostJobSubmitResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobSubmitResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobSubmitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobResponse parses an HTTP response from a SlurmV0041DeleteJobWithResponse call
func ParseSlurmV0041DeleteJobResponse(rsp *http.Response) (*SlurmV0041DeleteJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobResponse parses an HTTP response from a SlurmV0041GetJobWithResponse call
func ParseSlurmV0041GetJobResponse(rsp *http.Response) (*SlurmV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostJobResponse parses an HTTP response from a SlurmV0041PostJobWithResponse call
func ParseSlurmV0041PostJobResponse(rsp *http.Response) (*SlurmV0041PostJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobPostResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteJobsResponse parses an HTTP response from a SlurmV0041DeleteJobsWithResponse call
func ParseSlurmV0041DeleteJobsResponse(rsp *http.Response) (*SlurmV0041DeleteJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiKillJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsResponse parses an HTTP response from a SlurmV0041GetJobsWithResponse call
func ParseSlurmV0041GetJobsResponse(rsp *http.Response) (*SlurmV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetJobsStateResponse parses an HTTP response from a SlurmV0041GetJobsStateWithResponse call
func ParseSlurmV0041GetJobsStateResponse(rsp *http.Response) (*SlurmV0041GetJobsStateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetJobsStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiJobInfoResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetLicensesResponse parses an HTTP response from a SlurmV0041GetLicensesWithResponse call
func ParseSlurmV0041GetLicensesResponse(rsp *http.Response) (*SlurmV0041GetLicensesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetLicensesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiLicensesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041DeleteNodeResponse parses an HTTP response from a SlurmV0041DeleteNodeWithResponse call
func ParseSlurmV0041DeleteNodeResponse(rsp *http.Response) (*SlurmV0041DeleteNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041DeleteNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodeResponse parses an HTTP response from a SlurmV0041GetNodeWithResponse call
func ParseSlurmV0041GetNodeResponse(rsp *http.Response) (*SlurmV0041GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041PostNodeResponse parses an HTTP response from a SlurmV0041PostNodeWithResponse call
func ParseSlurmV0041PostNodeResponse(rsp *http.Response) (*SlurmV0041PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetNodesResponse parses an HTTP response from a SlurmV0041GetNodesWithResponse call
func ParseSlurmV0041GetNodesResponse(rsp *http.Response) (*SlurmV0041GetNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiNodesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionResponse parses an HTTP response from a SlurmV0041GetPartitionWithResponse call
func ParseSlurmV0041GetPartitionResponse(rsp *http.Response) (*SlurmV0041GetPartitionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPartitionsResponse parses an HTTP response from a SlurmV0041GetPartitionsWithResponse call
func ParseSlurmV0041GetPartitionsResponse(rsp *http.Response) (*SlurmV0041GetPartitionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPartitionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPartitionResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetPingResponse parses an HTTP response from a SlurmV0041GetPingWithResponse call
func ParseSlurmV0041GetPingResponse(rsp *http.Response) (*SlurmV0041GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiPingArrayResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReconfigureResponse parses an HTTP response from a SlurmV0041GetReconfigureWithResponse call
func ParseSlurmV0041GetReconfigureResponse(rsp *http.Response) (*SlurmV0041GetReconfigureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReconfigureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationResponse parses an HTTP response from a SlurmV0041GetReservationWithResponse call
func ParseSlurmV0041GetReservationResponse(rsp *http.Response) (*SlurmV0041GetReservationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetReservationsResponse parses an HTTP response from a SlurmV0041GetReservationsWithResponse call
func ParseSlurmV0041GetReservationsResponse(rsp *http.Response) (*SlurmV0041GetReservationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetReservationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiReservationResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmV0041GetSharesResponse parses an HTTP response from a SlurmV0041GetSharesWithResponse call
func ParseSlurmV0041GetSharesResponse(rsp *http.Response) (*SlurmV0041GetSharesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmV0041GetSharesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSharesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAccountResponse parses an HTTP response from a SlurmdbV0041DeleteAccountWithResponse call
func ParseSlurmdbV0041DeleteAccountResponse(rsp *http.Response) (*SlurmdbV0041DeleteAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountResponse parses an HTTP response from a SlurmdbV0041GetAccountWithResponse call
func ParseSlurmdbV0041GetAccountResponse(rsp *http.Response) (*SlurmdbV0041GetAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAccountsResponse parses an HTTP response from a SlurmdbV0041GetAccountsWithResponse call
func ParseSlurmdbV0041GetAccountsResponse(rsp *http.Response) (*SlurmdbV0041GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsResponse parses an HTTP response from a SlurmdbV0041PostAccountsWithResponse call
func ParseSlurmdbV0041PostAccountsResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAccountsAssociationResponse parses an HTTP response from a SlurmdbV0041PostAccountsAssociationWithResponse call
func ParseSlurmdbV0041PostAccountsAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostAccountsAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAccountsAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAccountsAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationWithResponse call
func ParseSlurmdbV0041DeleteAssociationResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationResponse parses an HTTP response from a SlurmdbV0041GetAssociationWithResponse call
func ParseSlurmdbV0041GetAssociationResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteAssociationsResponse parses an HTTP response from a SlurmdbV0041DeleteAssociationsWithResponse call
func ParseSlurmdbV0041DeleteAssociationsResponse(rsp *http.Response) (*SlurmdbV0041DeleteAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetAssociationsResponse parses an HTTP response from a SlurmdbV0041GetAssociationsWithResponse call
func ParseSlurmdbV0041GetAssociationsResponse(rsp *http.Response) (*SlurmdbV0041GetAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiAssocsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostAssociationsResponse parses an HTTP response from a SlurmdbV0041PostAssociationsWithResponse call
func ParseSlurmdbV0041PostAssociationsResponse(rsp *http.Response) (*SlurmdbV0041PostAssociationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostAssociationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteClusterResponse parses an HTTP response from a SlurmdbV0041DeleteClusterWithResponse call
func ParseSlurmdbV0041DeleteClusterResponse(rsp *http.Response) (*SlurmdbV0041DeleteClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClusterResponse parses an HTTP response from a SlurmdbV0041GetClusterWithResponse call
func ParseSlurmdbV0041GetClusterResponse(rsp *http.Response) (*SlurmdbV0041GetClusterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClusterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetClustersResponse parses an HTTP response from a SlurmdbV0041GetClustersWithResponse call
func ParseSlurmdbV0041GetClustersResponse(rsp *http.Response) (*SlurmdbV0041GetClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiClustersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostClustersResponse parses an HTTP response from a SlurmdbV0041PostClustersWithResponse call
func ParseSlurmdbV0041PostClustersResponse(rsp *http.Response) (*SlurmdbV0041PostClustersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostClustersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetConfigResponse parses an HTTP response from a SlurmdbV0041GetConfigWithResponse call
func ParseSlurmdbV0041GetConfigResponse(rsp *http.Response) (*SlurmdbV0041GetConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdConfigResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostConfigResponse parses an HTTP response from a SlurmdbV0041PostConfigWithResponse call
func ParseSlurmdbV0041PostConfigResponse(rsp *http.Response) (*SlurmdbV0041PostConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetDiagResponse parses an HTTP response from a SlurmdbV0041GetDiagWithResponse call
func ParseSlurmdbV0041GetDiagResponse(rsp *http.Response) (*SlurmdbV0041GetDiagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetDiagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdStatsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstanceResponse parses an HTTP response from a SlurmdbV0041GetInstanceWithResponse call
func ParseSlurmdbV0041GetInstanceResponse(rsp *http.Response) (*SlurmdbV0041GetInstanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetInstancesResponse parses an HTTP response from a SlurmdbV0041GetInstancesWithResponse call
func ParseSlurmdbV0041GetInstancesResponse(rsp *http.Response) (*SlurmdbV0041GetInstancesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetInstancesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiInstancesResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobResponse parses an HTTP response from a SlurmdbV0041GetJobWithResponse call
func ParseSlurmdbV0041GetJobResponse(rsp *http.Response) (*SlurmdbV0041GetJobResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetJobsResponse parses an HTTP response from a SlurmdbV0041GetJobsWithResponse call
func ParseSlurmdbV0041GetJobsResponse(rsp *http.Response) (*SlurmdbV0041GetJobsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdJobsResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetQosResponse parses an HTTP response from a SlurmdbV0041GetQosWithResponse call
func ParseSlurmdbV0041GetQosResponse(rsp *http.Response) (*SlurmdbV0041GetQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostQosResponse parses an HTTP response from a SlurmdbV0041PostQosWithResponse call
func ParseSlurmdbV0041PostQosResponse(rsp *http.Response) (*SlurmdbV0041PostQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteSingleQosResponse parses an HTTP response from a SlurmdbV0041DeleteSingleQosWithResponse call
func ParseSlurmdbV0041DeleteSingleQosResponse(rsp *http.Response) (*SlurmdbV0041DeleteSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetSingleQosResponse parses an HTTP response from a SlurmdbV0041GetSingleQosWithResponse call
func ParseSlurmdbV0041GetSingleQosResponse(rsp *http.Response) (*SlurmdbV0041GetSingleQosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetSingleQosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiSlurmdbdQosResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetTresResponse parses an HTTP response from a SlurmdbV0041GetTresWithResponse call
func ParseSlurmdbV0041GetTresResponse(rsp *http.Response) (*SlurmdbV0041GetTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiTresResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostTresResponse parses an HTTP response from a SlurmdbV0041PostTresWithResponse call
func ParseSlurmdbV0041PostTresResponse(rsp *http.Response) (*SlurmdbV0041PostTresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostTresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteUserResponse parses an HTTP response from a SlurmdbV0041DeleteUserWithResponse call
func ParseSlurmdbV0041DeleteUserResponse(rsp *http.Response) (*SlurmdbV0041DeleteUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUserResponse parses an HTTP response from a SlurmdbV0041GetUserWithResponse call
func ParseSlurmdbV0041GetUserResponse(rsp *http.Response) (*SlurmdbV0041GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetUsersResponse parses an HTTP response from a SlurmdbV0041GetUsersWithResponse call
func ParseSlurmdbV0041GetUsersResponse(rsp *http.Response) (*SlurmdbV0041GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersResponse parses an HTTP response from a SlurmdbV0041PostUsersWithResponse call
func ParseSlurmdbV0041PostUsersResponse(rsp *http.Response) (*SlurmdbV0041PostUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostUsersAssociationResponse parses an HTTP response from a SlurmdbV0041PostUsersAssociationWithResponse call
func ParseSlurmdbV0041PostUsersAssociationResponse(rsp *http.Response) (*SlurmdbV0041PostUsersAssociationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostUsersAssociationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiUsersAddCondRespStr
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041DeleteWckeyResponse parses an HTTP response from a SlurmdbV0041DeleteWckeyWithResponse call
func ParseSlurmdbV0041DeleteWckeyResponse(rsp *http.Response) (*SlurmdbV0041DeleteWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041DeleteWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyRemovedResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeyResponse parses an HTTP response from a SlurmdbV0041GetWckeyWithResponse call
func ParseSlurmdbV0041GetWckeyResponse(rsp *http.Response) (*SlurmdbV0041GetWckeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041GetWckeysResponse parses an HTTP response from a SlurmdbV0041GetWckeysWithResponse call
func ParseSlurmdbV0041GetWckeysResponse(rsp *http.Response) (*SlurmdbV0041GetWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041GetWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiWckeyResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseSlurmdbV0041PostWckeysResponse parses an HTTP response from a SlurmdbV0041PostWckeysWithResponse call
func ParseSlurmdbV0041PostWckeysResponse(rsp *http.Response) (*SlurmdbV0041PostWckeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SlurmdbV0041PostWckeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest V0041OpenapiResp
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// get diagnostics
	// (GET /slurm/v0.0.41/diag/)
	SlurmV0041GetDiag(w http.ResponseWriter, r *http.Request)
	// submit new job allocation without any steps that must be signaled to stop
	// (POST /slurm/v0.0.41/job/allocate)
	SlurmV0041PostJobAllocate(w http.ResponseWriter, r *http.Request)
	// submit new job
	// (POST /slurm/v0.0.41/job/submit)
	SlurmV0041PostJobSubmit(w http.ResponseWriter, r *http.Request)
	// cancel or signal job
	// (DELETE /slurm/v0.0.41/job/{job_id})
	SlurmV0041DeleteJob(w http.ResponseWriter, r *http.Request, jobId string, params SlurmV0041DeleteJobParams)
	// get job info
	// (GET /slurm/v0.0.41/job/{job_id})
	SlurmV0041GetJob(w http.ResponseWriter, r *http.Request, jobId string, params SlurmV0041GetJobParams)
	// update job
	// (POST /slurm/v0.0.41/job/{job_id})
	SlurmV0041PostJob(w http.ResponseWriter, r *http.Request, jobId string)
	// send signal to list of jobs
	// (DELETE /slurm/v0.0.41/jobs/)
	SlurmV0041DeleteJobs(w http.ResponseWriter, r *http.Request)
	// get list of jobs
	// (GET /slurm/v0.0.41/jobs/)
	SlurmV0041GetJobs(w http.ResponseWriter, r *http.Request, params SlurmV0041GetJobsParams)
	// get list of job states
	// (GET /slurm/v0.0.41/jobs/state/)
	SlurmV0041GetJobsState(w http.ResponseWriter, r *http.Request, params SlurmV0041GetJobsStateParams)
	// get all Slurm tracked license info
	// (GET /slurm/v0.0.41/licenses/)
	SlurmV0041GetLicenses(w http.ResponseWriter, r *http.Request)
	// delete node
	// (DELETE /slurm/v0.0.41/node/{node_name})
	SlurmV0041DeleteNode(w http.ResponseWriter, r *http.Request, nodeName string)
	// get node info
	// (GET /slurm/v0.0.41/node/{node_name})
	SlurmV0041GetNode(w http.ResponseWriter, r *http.Request, nodeName string, params SlurmV0041GetNodeParams)
	// update node properties
	// (POST /slurm/v0.0.41/node/{node_name})
	SlurmV0041PostNode(w http.ResponseWriter, r *http.Request, nodeName string)
	// get node(s) info
	// (GET /slurm/v0.0.41/nodes/)
	SlurmV0041GetNodes(w http.ResponseWriter, r *http.Request, params SlurmV0041GetNodesParams)
	// get partition info
	// (GET /slurm/v0.0.41/partition/{partition_name})
	SlurmV0041GetPartition(w http.ResponseWriter, r *http.Request, partitionName string, params SlurmV0041GetPartitionParams)
	// get all partition info
	// (GET /slurm/v0.0.41/partitions/)
	SlurmV0041GetPartitions(w http.ResponseWriter, r *http.Request, params SlurmV0041GetPartitionsParams)
	// ping test
	// (GET /slurm/v0.0.41/ping/)
	SlurmV0041GetPing(w http.ResponseWriter, r *http.Request)
	// request slurmctld reconfigure
	// (GET /slurm/v0.0.41/reconfigure/)
	SlurmV0041GetReconfigure(w http.ResponseWriter, r *http.Request)
	// get reservation info
	// (GET /slurm/v0.0.41/reservation/{reservation_name})
	SlurmV0041GetReservation(w http.ResponseWriter, r *http.Request, reservationName string, params SlurmV0041GetReservationParams)
	// get all reservation info
	// (GET /slurm/v0.0.41/reservations/)
	SlurmV0041GetReservations(w http.ResponseWriter, r *http.Request, params SlurmV0041GetReservationsParams)
	// get fairshare info
	// (GET /slurm/v0.0.41/shares)
	SlurmV0041GetShares(w http.ResponseWriter, r *http.Request, params SlurmV0041GetSharesParams)
	// Delete account
	// (DELETE /slurmdb/v0.0.41/account/{account_name})
	SlurmdbV0041DeleteAccount(w http.ResponseWriter, r *http.Request, accountName string)
	// Get account info
	// (GET /slurmdb/v0.0.41/account/{account_name})
	SlurmdbV0041GetAccount(w http.ResponseWriter, r *http.Request, accountName string, params SlurmdbV0041GetAccountParams)
	// Get account list
	// (GET /slurmdb/v0.0.41/accounts/)
	SlurmdbV0041GetAccounts(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetAccountsParams)
	// Add/update list of accounts
	// (POST /slurmdb/v0.0.41/accounts/)
	SlurmdbV0041PostAccounts(w http.ResponseWriter, r *http.Request)
	// Add accounts with conditional association
	// (POST /slurmdb/v0.0.41/accounts_association/)
	SlurmdbV0041PostAccountsAssociation(w http.ResponseWriter, r *http.Request)
	// Delete association
	// (DELETE /slurmdb/v0.0.41/association/)
	SlurmdbV0041DeleteAssociation(w http.ResponseWriter, r *http.Request, params SlurmdbV0041DeleteAssociationParams)
	// Get association info
	// (GET /slurmdb/v0.0.41/association/)
	SlurmdbV0041GetAssociation(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetAssociationParams)
	// Delete associations
	// (DELETE /slurmdb/v0.0.41/associations/)
	SlurmdbV0041DeleteAssociations(w http.ResponseWriter, r *http.Request, params SlurmdbV0041DeleteAssociationsParams)
	// Get association list
	// (GET /slurmdb/v0.0.41/associations/)
	SlurmdbV0041GetAssociations(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetAssociationsParams)
	// Set associations info
	// (POST /slurmdb/v0.0.41/associations/)
	SlurmdbV0041PostAssociations(w http.ResponseWriter, r *http.Request)
	// Delete cluster
	// (DELETE /slurmdb/v0.0.41/cluster/{cluster_name})
	SlurmdbV0041DeleteCluster(w http.ResponseWriter, r *http.Request, clusterName string, params SlurmdbV0041DeleteClusterParams)
	// Get cluster info
	// (GET /slurmdb/v0.0.41/cluster/{cluster_name})
	SlurmdbV0041GetCluster(w http.ResponseWriter, r *http.Request, clusterName string, params SlurmdbV0041GetClusterParams)
	// Get cluster list
	// (GET /slurmdb/v0.0.41/clusters/)
	SlurmdbV0041GetClusters(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetClustersParams)
	// Get cluster list
	// (POST /slurmdb/v0.0.41/clusters/)
	SlurmdbV0041PostClusters(w http.ResponseWriter, r *http.Request, params SlurmdbV0041PostClustersParams)
	// Dump all configuration information
	// (GET /slurmdb/v0.0.41/config)
	SlurmdbV0041GetConfig(w http.ResponseWriter, r *http.Request)
	// Load all configuration information
	// (POST /slurmdb/v0.0.41/config)
	SlurmdbV0041PostConfig(w http.ResponseWriter, r *http.Request)
	// Get slurmdb diagnostics
	// (GET /slurmdb/v0.0.41/diag/)
	SlurmdbV0041GetDiag(w http.ResponseWriter, r *http.Request)
	// Get instance info
	// (GET /slurmdb/v0.0.41/instance/)
	SlurmdbV0041GetInstance(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetInstanceParams)
	// Get instance list
	// (GET /slurmdb/v0.0.41/instances/)
	SlurmdbV0041GetInstances(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetInstancesParams)
	// Get job info
	// (GET /slurmdb/v0.0.41/job/{job_id})
	SlurmdbV0041GetJob(w http.ResponseWriter, r *http.Request, jobId string)
	// Get job list
	// (GET /slurmdb/v0.0.41/jobs/)
	SlurmdbV0041GetJobs(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetJobsParams)
	// Get QOS list
	// (GET /slurmdb/v0.0.41/qos/)
	SlurmdbV0041GetQos(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetQosParams)
	// Add or update QOSs
	// (POST /slurmdb/v0.0.41/qos/)
	SlurmdbV0041PostQos(w http.ResponseWriter, r *http.Request, params SlurmdbV0041PostQosParams)
	// Delete QOS
	// (DELETE /slurmdb/v0.0.41/qos/{qos})
	SlurmdbV0041DeleteSingleQos(w http.ResponseWriter, r *http.Request, qos string)
	// Get QOS info
	// (GET /slurmdb/v0.0.41/qos/{qos})
	SlurmdbV0041GetSingleQos(w http.ResponseWriter, r *http.Request, qos string, params SlurmdbV0041GetSingleQosParams)
	// Get TRES info
	// (GET /slurmdb/v0.0.41/tres/)
	SlurmdbV0041GetTres(w http.ResponseWriter, r *http.Request)
	// Add TRES
	// (POST /slurmdb/v0.0.41/tres/)
	SlurmdbV0041PostTres(w http.ResponseWriter, r *http.Request)
	// Delete user
	// (DELETE /slurmdb/v0.0.41/user/{name})
	SlurmdbV0041DeleteUser(w http.ResponseWriter, r *http.Request, name string)
	// Get user info
	// (GET /slurmdb/v0.0.41/user/{name})
	SlurmdbV0041GetUser(w http.ResponseWriter, r *http.Request, name string, params SlurmdbV0041GetUserParams)
	// Get user list
	// (GET /slurmdb/v0.0.41/users/)
	SlurmdbV0041GetUsers(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetUsersParams)
	// Update users
	// (POST /slurmdb/v0.0.41/users/)
	SlurmdbV0041PostUsers(w http.ResponseWriter, r *http.Request)
	// Add users with conditional association
	// (POST /slurmdb/v0.0.41/users_association/)
	SlurmdbV0041PostUsersAssociation(w http.ResponseWriter, r *http.Request, params SlurmdbV0041PostUsersAssociationParams)
	// Delete wckey
	// (DELETE /slurmdb/v0.0.41/wckey/{id})
	SlurmdbV0041DeleteWckey(w http.ResponseWriter, r *http.Request, id string)
	// Get wckey info
	// (GET /slurmdb/v0.0.41/wckey/{id})
	SlurmdbV0041GetWckey(w http.ResponseWriter, r *http.Request, id string)
	// Get wckey list
	// (GET /slurmdb/v0.0.41/wckeys/)
	SlurmdbV0041GetWckeys(w http.ResponseWriter, r *http.Request, params SlurmdbV0041GetWckeysParams)
	// Add or update wckeys
	// (POST /slurmdb/v0.0.41/wckeys/)
	SlurmdbV0041PostWckeys(w http.ResponseWriter, r *http.Request, params SlurmdbV0041PostWckeysParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// SlurmV0041GetDiag operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetDiag(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetDiag(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041PostJobAllocate operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041PostJobAllocate(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041PostJobAllocate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041PostJobSubmit operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041PostJobSubmit(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041PostJobSubmit(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041DeleteJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041DeleteJobParams

	// ------------- Optional query parameter "signal" -------------

	err = runtime.BindQueryParameter("form", false, false, "signal", r.URL.Query(), &params.Signal)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "signal", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041DeleteJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetJob operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetJobParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetJob(w, r, jobId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041PostJob operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041PostJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041PostJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041DeleteJobs operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041DeleteJobs(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041DeleteJobs(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetJobs operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetJobsParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetJobsState operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetJobsState(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetJobsStateParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetJobsState(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetLicenses operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetLicenses(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetLicenses(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041DeleteNode operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041DeleteNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "node_name" -------------
	var nodeName string

	err = runtime.BindStyledParameterWithOptions("simple", "node_name", r.PathValue("node_name"), &nodeName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041DeleteNode(w, r, nodeName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetNode operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "node_name" -------------
	var nodeName string

	err = runtime.BindStyledParameterWithOptions("simple", "node_name", r.PathValue("node_name"), &nodeName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetNodeParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetNode(w, r, nodeName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041PostNode operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041PostNode(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "node_name" -------------
	var nodeName string

	err = runtime.BindStyledParameterWithOptions("simple", "node_name", r.PathValue("node_name"), &nodeName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041PostNode(w, r, nodeName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetNodes operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetNodes(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetNodesParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetNodes(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetPartition operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetPartition(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "partition_name" -------------
	var partitionName string

	err = runtime.BindStyledParameterWithOptions("simple", "partition_name", r.PathValue("partition_name"), &partitionName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetPartitionParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetPartition(w, r, partitionName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetPartitions operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetPartitions(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetPartitionsParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetPartitions(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetPing operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetPing(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetPing(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetReconfigure operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetReconfigure(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetReconfigure(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetReservation operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetReservation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "reservation_name" -------------
	var reservationName string

	err = runtime.BindStyledParameterWithOptions("simple", "reservation_name", r.PathValue("reservation_name"), &reservationName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reservation_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetReservationParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetReservation(w, r, reservationName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetReservations operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetReservations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetReservationsParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetReservations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmV0041GetShares operation middleware
func (siw *ServerInterfaceWrapper) SlurmV0041GetShares(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmV0041GetSharesParams

	// ------------- Optional query parameter "accounts" -------------

	err = runtime.BindQueryParameter("form", false, false, "accounts", r.URL.Query(), &params.Accounts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "accounts", Err: err})
		return
	}

	// ------------- Optional query parameter "users" -------------

	err = runtime.BindQueryParameter("form", false, false, "users", r.URL.Query(), &params.Users)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "users", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmV0041GetShares(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteAccount operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account_name" -------------
	var accountName string

	err = runtime.BindStyledParameterWithOptions("simple", "account_name", r.PathValue("account_name"), &accountName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteAccount(w, r, accountName)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetAccount operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "account_name" -------------
	var accountName string

	err = runtime.BindStyledParameterWithOptions("simple", "account_name", r.PathValue("account_name"), &accountName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetAccountParams

	// ------------- Optional query parameter "with_assocs" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_assocs", r.URL.Query(), &params.WithAssocs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_assocs", Err: err})
		return
	}

	// ------------- Optional query parameter "with_coords" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_coords", r.URL.Query(), &params.WithCoords)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_coords", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetAccount(w, r, accountName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetAccounts operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetAccounts(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetAccountsParams

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", false, false, "description", r.URL.Query(), &params.Description)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "description", Err: err})
		return
	}

	// ------------- Optional query parameter "DELETED" -------------

	err = runtime.BindQueryParameter("form", false, false, "DELETED", r.URL.Query(), &params.DELETED)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "DELETED", Err: err})
		return
	}

	// ------------- Optional query parameter "WithAssociations" -------------

	err = runtime.BindQueryParameter("form", false, false, "WithAssociations", r.URL.Query(), &params.WithAssociations)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "WithAssociations", Err: err})
		return
	}

	// ------------- Optional query parameter "WithCoordinators" -------------

	err = runtime.BindQueryParameter("form", false, false, "WithCoordinators", r.URL.Query(), &params.WithCoordinators)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "WithCoordinators", Err: err})
		return
	}

	// ------------- Optional query parameter "NoUsersAreCoords" -------------

	err = runtime.BindQueryParameter("form", false, false, "NoUsersAreCoords", r.URL.Query(), &params.NoUsersAreCoords)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "NoUsersAreCoords", Err: err})
		return
	}

	// ------------- Optional query parameter "UsersAreCoords" -------------

	err = runtime.BindQueryParameter("form", false, false, "UsersAreCoords", r.URL.Query(), &params.UsersAreCoords)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "UsersAreCoords", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetAccounts(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostAccounts operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostAccounts(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostAccounts(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostAccountsAssociation operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostAccountsAssociation(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostAccountsAssociation(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteAssociation operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteAssociation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041DeleteAssociationParams

	// ------------- Optional query parameter "account" -------------

	err = runtime.BindQueryParameter("form", false, false, "account", r.URL.Query(), &params.Account)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "default_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_qos", r.URL.Query(), &params.DefaultQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "parent_account" -------------

	err = runtime.BindQueryParameter("form", false, false, "parent_account", r.URL.Query(), &params.ParentAccount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "parent_account", Err: err})
		return
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", false, false, "partition", r.URL.Query(), &params.Partition)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition", Err: err})
		return
	}

	// ------------- Optional query parameter "qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "qos", r.URL.Query(), &params.Qos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_raw_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_raw_qos", r.URL.Query(), &params.WithRawQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_raw_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "with_sub_accts" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_sub_accts", r.URL.Query(), &params.WithSubAccts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_sub_accts", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_info" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_info", r.URL.Query(), &params.WithoutParentInfo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_info", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_limits" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_limits", r.URL.Query(), &params.WithoutParentLimits)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_limits", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteAssociation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetAssociation operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetAssociation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetAssociationParams

	// ------------- Optional query parameter "account" -------------

	err = runtime.BindQueryParameter("form", false, false, "account", r.URL.Query(), &params.Account)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "default_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_qos", r.URL.Query(), &params.DefaultQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "parent_account" -------------

	err = runtime.BindQueryParameter("form", false, false, "parent_account", r.URL.Query(), &params.ParentAccount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "parent_account", Err: err})
		return
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", false, false, "partition", r.URL.Query(), &params.Partition)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition", Err: err})
		return
	}

	// ------------- Optional query parameter "qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "qos", r.URL.Query(), &params.Qos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_raw_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_raw_qos", r.URL.Query(), &params.WithRawQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_raw_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "with_sub_accts" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_sub_accts", r.URL.Query(), &params.WithSubAccts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_sub_accts", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_info" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_info", r.URL.Query(), &params.WithoutParentInfo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_info", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_limits" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_limits", r.URL.Query(), &params.WithoutParentLimits)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_limits", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetAssociation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteAssociations operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteAssociations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041DeleteAssociationsParams

	// ------------- Optional query parameter "account" -------------

	err = runtime.BindQueryParameter("form", false, false, "account", r.URL.Query(), &params.Account)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "default_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_qos", r.URL.Query(), &params.DefaultQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "parent_account" -------------

	err = runtime.BindQueryParameter("form", false, false, "parent_account", r.URL.Query(), &params.ParentAccount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "parent_account", Err: err})
		return
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", false, false, "partition", r.URL.Query(), &params.Partition)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition", Err: err})
		return
	}

	// ------------- Optional query parameter "qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "qos", r.URL.Query(), &params.Qos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_raw_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_raw_qos", r.URL.Query(), &params.WithRawQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_raw_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "with_sub_accts" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_sub_accts", r.URL.Query(), &params.WithSubAccts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_sub_accts", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_info" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_info", r.URL.Query(), &params.WithoutParentInfo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_info", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_limits" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_limits", r.URL.Query(), &params.WithoutParentLimits)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_limits", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteAssociations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetAssociations operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetAssociations(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetAssociationsParams

	// ------------- Optional query parameter "account" -------------

	err = runtime.BindQueryParameter("form", false, false, "account", r.URL.Query(), &params.Account)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "default_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_qos", r.URL.Query(), &params.DefaultQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "parent_account" -------------

	err = runtime.BindQueryParameter("form", false, false, "parent_account", r.URL.Query(), &params.ParentAccount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "parent_account", Err: err})
		return
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", false, false, "partition", r.URL.Query(), &params.Partition)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition", Err: err})
		return
	}

	// ------------- Optional query parameter "qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "qos", r.URL.Query(), &params.Qos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_raw_qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_raw_qos", r.URL.Query(), &params.WithRawQos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_raw_qos", Err: err})
		return
	}

	// ------------- Optional query parameter "with_sub_accts" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_sub_accts", r.URL.Query(), &params.WithSubAccts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_sub_accts", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_info" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_info", r.URL.Query(), &params.WithoutParentInfo)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_info", Err: err})
		return
	}

	// ------------- Optional query parameter "without_parent_limits" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_parent_limits", r.URL.Query(), &params.WithoutParentLimits)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_parent_limits", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetAssociations(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostAssociations operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostAssociations(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostAssociations(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteCluster operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteCluster(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "cluster_name" -------------
	var clusterName string

	err = runtime.BindStyledParameterWithOptions("simple", "cluster_name", r.PathValue("cluster_name"), &clusterName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041DeleteClusterParams

	// ------------- Optional query parameter "classification" -------------

	err = runtime.BindQueryParameter("form", false, false, "classification", r.URL.Query(), &params.Classification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "classification", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "federation" -------------

	err = runtime.BindQueryParameter("form", false, false, "federation", r.URL.Query(), &params.Federation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "federation", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "rpc_version" -------------

	err = runtime.BindQueryParameter("form", false, false, "rpc_version", r.URL.Query(), &params.RpcVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rpc_version", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteCluster(w, r, clusterName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetCluster operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetCluster(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "cluster_name" -------------
	var clusterName string

	err = runtime.BindStyledParameterWithOptions("simple", "cluster_name", r.PathValue("cluster_name"), &clusterName, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster_name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetClusterParams

	// ------------- Optional query parameter "classification" -------------

	err = runtime.BindQueryParameter("form", false, false, "classification", r.URL.Query(), &params.Classification)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "classification", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "federation" -------------

	err = runtime.BindQueryParameter("form", false, false, "federation", r.URL.Query(), &params.Federation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "federation", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "rpc_version" -------------

	err = runtime.BindQueryParameter("form", false, false, "rpc_version", r.URL.Query(), &params.RpcVersion)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rpc_version", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetCluster(w, r, clusterName, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetClusters operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetClusters(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetClustersParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetClusters(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostClusters operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostClusters(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041PostClustersParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostClusters(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetConfig operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetConfig(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostConfig operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostConfig(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostConfig(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetDiag operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetDiag(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetDiag(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetInstance operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetInstance(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetInstanceParams

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "extra" -------------

	err = runtime.BindQueryParameter("form", false, false, "extra", r.URL.Query(), &params.Extra)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "extra", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "instance_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "instance_id", r.URL.Query(), &params.InstanceId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instance_id", Err: err})
		return
	}

	// ------------- Optional query parameter "instance_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "instance_type", r.URL.Query(), &params.InstanceType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instance_type", Err: err})
		return
	}

	// ------------- Optional query parameter "node_list" -------------

	err = runtime.BindQueryParameter("form", false, false, "node_list", r.URL.Query(), &params.NodeList)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node_list", Err: err})
		return
	}

	// ------------- Optional query parameter "time_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "time_end", r.URL.Query(), &params.TimeEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time_end", Err: err})
		return
	}

	// ------------- Optional query parameter "time_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "time_start", r.URL.Query(), &params.TimeStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time_start", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetInstance(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetInstances operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetInstances(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetInstancesParams

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "extra" -------------

	err = runtime.BindQueryParameter("form", false, false, "extra", r.URL.Query(), &params.Extra)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "extra", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "instance_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "instance_id", r.URL.Query(), &params.InstanceId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instance_id", Err: err})
		return
	}

	// ------------- Optional query parameter "instance_type" -------------

	err = runtime.BindQueryParameter("form", false, false, "instance_type", r.URL.Query(), &params.InstanceType)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "instance_type", Err: err})
		return
	}

	// ------------- Optional query parameter "node_list" -------------

	err = runtime.BindQueryParameter("form", false, false, "node_list", r.URL.Query(), &params.NodeList)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node_list", Err: err})
		return
	}

	// ------------- Optional query parameter "time_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "time_end", r.URL.Query(), &params.TimeEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time_end", Err: err})
		return
	}

	// ------------- Optional query parameter "time_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "time_start", r.URL.Query(), &params.TimeStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "time_start", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetInstances(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetJob operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetJob(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "job_id" -------------
	var jobId string

	err = runtime.BindStyledParameterWithOptions("simple", "job_id", r.PathValue("job_id"), &jobId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetJob(w, r, jobId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetJobs operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetJobs(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetJobsParams

	// ------------- Optional query parameter "account" -------------

	err = runtime.BindQueryParameter("form", false, false, "account", r.URL.Query(), &params.Account)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "account", Err: err})
		return
	}

	// ------------- Optional query parameter "association" -------------

	err = runtime.BindQueryParameter("form", false, false, "association", r.URL.Query(), &params.Association)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "association", Err: err})
		return
	}

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "constraints" -------------

	err = runtime.BindQueryParameter("form", false, false, "constraints", r.URL.Query(), &params.Constraints)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "constraints", Err: err})
		return
	}

	// ------------- Optional query parameter "scheduler_unset" -------------

	err = runtime.BindQueryParameter("form", false, false, "scheduler_unset", r.URL.Query(), &params.SchedulerUnset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scheduler_unset", Err: err})
		return
	}

	// ------------- Optional query parameter "scheduled_on_submit" -------------

	err = runtime.BindQueryParameter("form", false, false, "scheduled_on_submit", r.URL.Query(), &params.ScheduledOnSubmit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scheduled_on_submit", Err: err})
		return
	}

	// ------------- Optional query parameter "scheduled_by_main" -------------

	err = runtime.BindQueryParameter("form", false, false, "scheduled_by_main", r.URL.Query(), &params.ScheduledByMain)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scheduled_by_main", Err: err})
		return
	}

	// ------------- Optional query parameter "scheduled_by_backfill" -------------

	err = runtime.BindQueryParameter("form", false, false, "scheduled_by_backfill", r.URL.Query(), &params.ScheduledByBackfill)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "scheduled_by_backfill", Err: err})
		return
	}

	// ------------- Optional query parameter "job_started" -------------

	err = runtime.BindQueryParameter("form", false, false, "job_started", r.URL.Query(), &params.JobStarted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_started", Err: err})
		return
	}

	// ------------- Optional query parameter "exit_code" -------------

	err = runtime.BindQueryParameter("form", false, false, "exit_code", r.URL.Query(), &params.ExitCode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "exit_code", Err: err})
		return
	}

	// ------------- Optional query parameter "show_duplicates" -------------

	err = runtime.BindQueryParameter("form", false, false, "show_duplicates", r.URL.Query(), &params.ShowDuplicates)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "show_duplicates", Err: err})
		return
	}

	// ------------- Optional query parameter "skip_steps" -------------

	err = runtime.BindQueryParameter("form", false, false, "skip_steps", r.URL.Query(), &params.SkipSteps)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "skip_steps", Err: err})
		return
	}

	// ------------- Optional query parameter "disable_truncate_usage_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "disable_truncate_usage_time", r.URL.Query(), &params.DisableTruncateUsageTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "disable_truncate_usage_time", Err: err})
		return
	}

	// ------------- Optional query parameter "whole_hetjob" -------------

	err = runtime.BindQueryParameter("form", false, false, "whole_hetjob", r.URL.Query(), &params.WholeHetjob)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "whole_hetjob", Err: err})
		return
	}

	// ------------- Optional query parameter "disable_whole_hetjob" -------------

	err = runtime.BindQueryParameter("form", false, false, "disable_whole_hetjob", r.URL.Query(), &params.DisableWholeHetjob)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "disable_whole_hetjob", Err: err})
		return
	}

	// ------------- Optional query parameter "disable_wait_for_result" -------------

	err = runtime.BindQueryParameter("form", false, false, "disable_wait_for_result", r.URL.Query(), &params.DisableWaitForResult)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "disable_wait_for_result", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_time_as_submit_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_time_as_submit_time", r.URL.Query(), &params.UsageTimeAsSubmitTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_time_as_submit_time", Err: err})
		return
	}

	// ------------- Optional query parameter "show_batch_script" -------------

	err = runtime.BindQueryParameter("form", false, false, "show_batch_script", r.URL.Query(), &params.ShowBatchScript)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "show_batch_script", Err: err})
		return
	}

	// ------------- Optional query parameter "show_job_environment" -------------

	err = runtime.BindQueryParameter("form", false, false, "show_job_environment", r.URL.Query(), &params.ShowJobEnvironment)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "show_job_environment", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "groups" -------------

	err = runtime.BindQueryParameter("form", false, false, "groups", r.URL.Query(), &params.Groups)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groups", Err: err})
		return
	}

	// ------------- Optional query parameter "job_name" -------------

	err = runtime.BindQueryParameter("form", false, false, "job_name", r.URL.Query(), &params.JobName)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "job_name", Err: err})
		return
	}

	// ------------- Optional query parameter "partition" -------------

	err = runtime.BindQueryParameter("form", false, false, "partition", r.URL.Query(), &params.Partition)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "partition", Err: err})
		return
	}

	// ------------- Optional query parameter "qos" -------------

	err = runtime.BindQueryParameter("form", false, false, "qos", r.URL.Query(), &params.Qos)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	// ------------- Optional query parameter "reason" -------------

	err = runtime.BindQueryParameter("form", false, false, "reason", r.URL.Query(), &params.Reason)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reason", Err: err})
		return
	}

	// ------------- Optional query parameter "reservation" -------------

	err = runtime.BindQueryParameter("form", false, false, "reservation", r.URL.Query(), &params.Reservation)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reservation", Err: err})
		return
	}

	// ------------- Optional query parameter "reservation_id" -------------

	err = runtime.BindQueryParameter("form", false, false, "reservation_id", r.URL.Query(), &params.ReservationId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reservation_id", Err: err})
		return
	}

	// ------------- Optional query parameter "state" -------------

	err = runtime.BindQueryParameter("form", false, false, "state", r.URL.Query(), &params.State)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "state", Err: err})
		return
	}

	// ------------- Optional query parameter "step" -------------

	err = runtime.BindQueryParameter("form", false, false, "step", r.URL.Query(), &params.Step)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "step", Err: err})
		return
	}

	// ------------- Optional query parameter "end_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "end_time", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "end_time", Err: err})
		return
	}

	// ------------- Optional query parameter "start_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "start_time", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "start_time", Err: err})
		return
	}

	// ------------- Optional query parameter "node" -------------

	err = runtime.BindQueryParameter("form", false, false, "node", r.URL.Query(), &params.Node)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "node", Err: err})
		return
	}

	// ------------- Optional query parameter "users" -------------

	err = runtime.BindQueryParameter("form", false, false, "users", r.URL.Query(), &params.Users)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "users", Err: err})
		return
	}

	// ------------- Optional query parameter "wckey" -------------

	err = runtime.BindQueryParameter("form", false, false, "wckey", r.URL.Query(), &params.Wckey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "wckey", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetJobs(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetQos operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetQos(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetQosParams

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", false, false, "description", r.URL.Query(), &params.Description)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "description", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "preempt_mode" -------------

	err = runtime.BindQueryParameter("form", false, false, "preempt_mode", r.URL.Query(), &params.PreemptMode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "preempt_mode", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetQos(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostQos operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostQos(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041PostQosParams

	// ------------- Optional query parameter "description" -------------

	err = runtime.BindQueryParameter("form", false, false, "description", r.URL.Query(), &params.Description)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "description", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "preempt_mode" -------------

	err = runtime.BindQueryParameter("form", false, false, "preempt_mode", r.URL.Query(), &params.PreemptMode)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "preempt_mode", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostQos(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteSingleQos operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteSingleQos(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "qos" -------------
	var qos string

	err = runtime.BindStyledParameterWithOptions("simple", "qos", r.PathValue("qos"), &qos, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteSingleQos(w, r, qos)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetSingleQos operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetSingleQos(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "qos" -------------
	var qos string

	err = runtime.BindStyledParameterWithOptions("simple", "qos", r.PathValue("qos"), &qos, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "qos", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetSingleQosParams

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetSingleQos(w, r, qos, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetTres operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetTres(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetTres(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostTres operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostTres(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostTres(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteUser operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteUser(w, r, name)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetUser operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetUser(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithOptions("simple", "name", r.PathValue("name"), &name, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetUserParams

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_assocs" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_assocs", r.URL.Query(), &params.WithAssocs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_assocs", Err: err})
		return
	}

	// ------------- Optional query parameter "with_coords" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_coords", r.URL.Query(), &params.WithCoords)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_coords", Err: err})
		return
	}

	// ------------- Optional query parameter "with_wckeys" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_wckeys", r.URL.Query(), &params.WithWckeys)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_wckeys", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetUser(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetUsers operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetUsers(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetUsersParams

	// ------------- Optional query parameter "admin_level" -------------

	err = runtime.BindQueryParameter("form", false, false, "admin_level", r.URL.Query(), &params.AdminLevel)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "admin_level", Err: err})
		return
	}

	// ------------- Optional query parameter "default_account" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_account", r.URL.Query(), &params.DefaultAccount)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_account", Err: err})
		return
	}

	// ------------- Optional query parameter "default_wckey" -------------

	err = runtime.BindQueryParameter("form", false, false, "default_wckey", r.URL.Query(), &params.DefaultWckey)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "default_wckey", Err: err})
		return
	}

	// ------------- Optional query parameter "with_assocs" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_assocs", r.URL.Query(), &params.WithAssocs)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_assocs", Err: err})
		return
	}

	// ------------- Optional query parameter "with_coords" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_coords", r.URL.Query(), &params.WithCoords)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_coords", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	// ------------- Optional query parameter "with_wckeys" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_wckeys", r.URL.Query(), &params.WithWckeys)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_wckeys", Err: err})
		return
	}

	// ------------- Optional query parameter "without_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "without_defaults", r.URL.Query(), &params.WithoutDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "without_defaults", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetUsers(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostUsers operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostUsers(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostUsers(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostUsersAssociation operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostUsersAssociation(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041PostUsersAssociationParams

	// ------------- Optional query parameter "update_time" -------------

	err = runtime.BindQueryParameter("form", false, false, "update_time", r.URL.Query(), &params.UpdateTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "update_time", Err: err})
		return
	}

	// ------------- Optional query parameter "flags" -------------

	err = runtime.BindQueryParameter("form", false, false, "flags", r.URL.Query(), &params.Flags)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "flags", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostUsersAssociation(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041DeleteWckey operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041DeleteWckey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041DeleteWckey(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetWckey operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetWckey(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", r.PathValue("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetWckey(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041GetWckeys operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041GetWckeys(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041GetWckeysParams

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041GetWckeys(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SlurmdbV0041PostWckeys operation middleware
func (siw *ServerInterfaceWrapper) SlurmdbV0041PostWckeys(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, UserScopes, []string{})

	ctx = context.WithValue(ctx, TokenScopes, []string{})

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params SlurmdbV0041PostWckeysParams

	// ------------- Optional query parameter "cluster" -------------

	err = runtime.BindQueryParameter("form", false, false, "cluster", r.URL.Query(), &params.Cluster)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "cluster", Err: err})
		return
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", false, false, "format", r.URL.Query(), &params.Format)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "format", Err: err})
		return
	}

	// ------------- Optional query parameter "id" -------------

	err = runtime.BindQueryParameter("form", false, false, "id", r.URL.Query(), &params.Id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	// ------------- Optional query parameter "name" -------------

	err = runtime.BindQueryParameter("form", false, false, "name", r.URL.Query(), &params.Name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// ------------- Optional query parameter "only_defaults" -------------

	err = runtime.BindQueryParameter("form", false, false, "only_defaults", r.URL.Query(), &params.OnlyDefaults)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "only_defaults", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_end" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_end", r.URL.Query(), &params.UsageEnd)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_end", Err: err})
		return
	}

	// ------------- Optional query parameter "usage_start" -------------

	err = runtime.BindQueryParameter("form", false, false, "usage_start", r.URL.Query(), &params.UsageStart)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "usage_start", Err: err})
		return
	}

	// ------------- Optional query parameter "user" -------------

	err = runtime.BindQueryParameter("form", false, false, "user", r.URL.Query(), &params.User)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "user", Err: err})
		return
	}

	// ------------- Optional query parameter "with_usage" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_usage", r.URL.Query(), &params.WithUsage)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_usage", Err: err})
		return
	}

	// ------------- Optional query parameter "with_deleted" -------------

	err = runtime.BindQueryParameter("form", false, false, "with_deleted", r.URL.Query(), &params.WithDeleted)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "with_deleted", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SlurmdbV0041PostWckeys(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{})
}

// ServeMux is an abstraction of http.ServeMux.
type ServeMux interface {
	HandleFunc(pattern string, handler func(http.ResponseWriter, *http.Request))
	ServeHTTP(w http.ResponseWriter, r *http.Request)
}

type StdHTTPServerOptions struct {
	BaseURL          string
	BaseRouter       ServeMux
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, m ServeMux) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseRouter: m,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, m ServeMux, baseURL string) http.Handler {
	return HandlerWithOptions(si, StdHTTPServerOptions{
		BaseURL:    baseURL,
		BaseRouter: m,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options StdHTTPServerOptions) http.Handler {
	m := options.BaseRouter

	if m == nil {
		m = http.NewServeMux()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}

	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/diag/", wrapper.SlurmV0041GetDiag)
	m.HandleFunc("POST "+options.BaseURL+"/slurm/v0.0.41/job/allocate", wrapper.SlurmV0041PostJobAllocate)
	m.HandleFunc("POST "+options.BaseURL+"/slurm/v0.0.41/job/submit", wrapper.SlurmV0041PostJobSubmit)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurm/v0.0.41/job/{job_id}", wrapper.SlurmV0041DeleteJob)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/job/{job_id}", wrapper.SlurmV0041GetJob)
	m.HandleFunc("POST "+options.BaseURL+"/slurm/v0.0.41/job/{job_id}", wrapper.SlurmV0041PostJob)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurm/v0.0.41/jobs/", wrapper.SlurmV0041DeleteJobs)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/jobs/", wrapper.SlurmV0041GetJobs)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/jobs/state/", wrapper.SlurmV0041GetJobsState)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/licenses/", wrapper.SlurmV0041GetLicenses)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurm/v0.0.41/node/{node_name}", wrapper.SlurmV0041DeleteNode)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/node/{node_name}", wrapper.SlurmV0041GetNode)
	m.HandleFunc("POST "+options.BaseURL+"/slurm/v0.0.41/node/{node_name}", wrapper.SlurmV0041PostNode)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/nodes/", wrapper.SlurmV0041GetNodes)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/partition/{partition_name}", wrapper.SlurmV0041GetPartition)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/partitions/", wrapper.SlurmV0041GetPartitions)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/ping/", wrapper.SlurmV0041GetPing)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/reconfigure/", wrapper.SlurmV0041GetReconfigure)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/reservation/{reservation_name}", wrapper.SlurmV0041GetReservation)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/reservations/", wrapper.SlurmV0041GetReservations)
	m.HandleFunc("GET "+options.BaseURL+"/slurm/v0.0.41/shares", wrapper.SlurmV0041GetShares)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/account/{account_name}", wrapper.SlurmdbV0041DeleteAccount)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/account/{account_name}", wrapper.SlurmdbV0041GetAccount)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/accounts/", wrapper.SlurmdbV0041GetAccounts)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/accounts/", wrapper.SlurmdbV0041PostAccounts)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/accounts_association/", wrapper.SlurmdbV0041PostAccountsAssociation)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/association/", wrapper.SlurmdbV0041DeleteAssociation)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/association/", wrapper.SlurmdbV0041GetAssociation)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/associations/", wrapper.SlurmdbV0041DeleteAssociations)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/associations/", wrapper.SlurmdbV0041GetAssociations)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/associations/", wrapper.SlurmdbV0041PostAssociations)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/cluster/{cluster_name}", wrapper.SlurmdbV0041DeleteCluster)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/cluster/{cluster_name}", wrapper.SlurmdbV0041GetCluster)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/clusters/", wrapper.SlurmdbV0041GetClusters)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/clusters/", wrapper.SlurmdbV0041PostClusters)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/config", wrapper.SlurmdbV0041GetConfig)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/config", wrapper.SlurmdbV0041PostConfig)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/diag/", wrapper.SlurmdbV0041GetDiag)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/instance/", wrapper.SlurmdbV0041GetInstance)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/instances/", wrapper.SlurmdbV0041GetInstances)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/job/{job_id}", wrapper.SlurmdbV0041GetJob)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/jobs/", wrapper.SlurmdbV0041GetJobs)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/qos/", wrapper.SlurmdbV0041GetQos)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/qos/", wrapper.SlurmdbV0041PostQos)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/qos/{qos}", wrapper.SlurmdbV0041DeleteSingleQos)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/qos/{qos}", wrapper.SlurmdbV0041GetSingleQos)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/tres/", wrapper.SlurmdbV0041GetTres)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/tres/", wrapper.SlurmdbV0041PostTres)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/user/{name}", wrapper.SlurmdbV0041DeleteUser)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/user/{name}", wrapper.SlurmdbV0041GetUser)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/users/", wrapper.SlurmdbV0041GetUsers)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/users/", wrapper.SlurmdbV0041PostUsers)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/users_association/", wrapper.SlurmdbV0041PostUsersAssociation)
	m.HandleFunc("DELETE "+options.BaseURL+"/slurmdb/v0.0.41/wckey/{id}", wrapper.SlurmdbV0041DeleteWckey)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/wckey/{id}", wrapper.SlurmdbV0041GetWckey)
	m.HandleFunc("GET "+options.BaseURL+"/slurmdb/v0.0.41/wckeys/", wrapper.SlurmdbV0041GetWckeys)
	m.HandleFunc("POST "+options.BaseURL+"/slurmdb/v0.0.41/wckeys/", wrapper.SlurmdbV0041PostWckeys)

	return m
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
